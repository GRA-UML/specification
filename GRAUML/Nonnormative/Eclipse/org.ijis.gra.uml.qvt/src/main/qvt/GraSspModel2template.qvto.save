// TODO: import from org.search.niem.uml.qvt.NIEMplatformBinding; remove local copy
//  but it was not exported, may need an OSGi fragment to recover it
//	but it also was changed from omg version and does not work so well
//import org.search.niem.uml.qvt.NIEMplatformBinding;
// due to excessive QVT compilation time, combine several modules into this
import GRAcommon;
//import GRAsoaml2wsdl;
import NIEMmpdmodel2artifact;
import NIEMpsm2xsd;

//import GRAsoaml2wsdlannotations;
//modeltype UML uses 'http://www.omg.org/spec/UML/20110701';
modeltype UML uses 'http://www.eclipse.org/uml2/4.0.0/UML';
modeltype XSD  uses 'http://www.eclipse.org/xsd/2002/XSD';
modeltype SPPCAT  uses 'http://gra.ijis.org/catalog/1.0.0';
modeltype METADATA  uses 'http://it.ojp.gov/gsp/services/1.0.0';

modeltype EBXML uses 'http://www.ebxml.org/BusinessProcess';// no current models use this
modeltype XMLDSIG uses 'http://www.w3.org/2000/09/xmldsig#';// this is used
modeltype WSDL uses 'http://www.eclipse.org/wsdl/2003/WSDL';// TODO: change to http://schemas.xmlsoap.org/wsdl/
modeltype BPMN2 uses 'http://www.omg.org/spec/BPMN/20100524/MODEL-XMI';// no current models use this

modeltype CMOF  uses 'http://www.eclipse.org/emf/2002/Ecore';

modeltype CAT  uses 'http://reference.niem.gov/niem/resource/mpd/catalog/1.0/';
modeltype SOAP uses 'http://www.eclipse.org/wsdl/2003/SOAP';

modeltype GRAA uses 'http://ijis.org/GRA/Annotations';
modeltype GRAW uses 'http:/ijis.org/GRA/WSDLAnnotations';
// TODO:
//modeltype CHANGELOG  uses '???????????????';
/*
modeltype WSDL_HTTP uses 'http://schemas.xmlsoap.org/wsdl/http/';// used in wsdl
modeltype WSDL_MIME uses 'http://schemas.xmlsoap.org/wsdl/mime/';// used in policy wsdl
modeltype WSDL_SOAP uses 'http://schemas.xmlsoap.org/wsdl/soap/';// used in wsdl
modeltype SOAP12 uses 'http://schemas.xmlsoap.org/wsdl/soap12/';// used in wsdl

modeltype SOAP_ENV uses 'http://schemas.xmlsoap.org/soap/envelope/';// this is used in SOAP instance documents and xsd
modeltype SOAP_ENC uses 'http://schemas.xmlsoap.org/soap/encoding/';// this is used in SOAP instance documents and wsdl
modeltype WSRM uses 'http://docs.oasis-open.org/ws-rx/wsrm/200608';// this is used in SOAP instance documents
modeltype WSRM2 uses 'http://schemas.xmlsoap.org/ws/2005/02/rm/policy';// this is used in SOAP instance documents
modeltype WSA uses 'http://www.w3.org/2005/08/addressing';// used in SOAP instance docs, wsdl
modeltype WSAW uses 'http://www.w3.org/2006/05/addressing/wsdl';// used in SOAP instance docs, wsdl
modeltype WSAM uses 'http://www.w3.org/2007/05/addressing/metadata';// used in SOAP instance docs, wsdl
modeltype WSU uses 'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd';// used in SOAP instance docs, wsdl
modeltype WSP uses 'http://schemas.xmlsoap.org/ws/2004/09/policy';// used in SOAP instance docs, wsdl
modeltype SP uses 'http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702';// used in SOAP instance docs, wsdl
modeltype WSX uses 'http://schemas.xmlsoap.org/ws/2004/09/mex';// used in wsdl

modeltype BPMN uses 'http://stp.eclipse.org/bpmn';// some ssp references this?
*/
//vii.	WSDL (Added per questions)
//viii.	BPM XMI (Added per questions)
//ix.	Service Change Log (Added per questions) ????????
//x.	ebXML XSD (Added per questions)

transformation GraSspModel2artifact (in uml:UML,in schemaForProxy:XSD,out cat:SPPCAT,out metadata:METADATA,out wsdl:WSDL,out graa:GRAA)
	;
main() {
	GraSspModel2artifact_run();
}	
property graRoot:UML::Model=null;
property sppCatalogUml:UML::InstanceSpecification=null;
property metadataDocument:METADATA::DocumentRoot=null;	
property theServiceCollaboration:UML::Collaboration=null;
helper GraSspModel2artifact_run() {
	umlSchemaForProxy:=schemaForProxy.objectsOfType(XSD::XSDSchema)->asSequence()->first();
	// initialize the Schema for Schemas
	umlSchemaForSchema:=umlSchemaForProxy.schemaForSchema;
	
	graRoot:=
			uml.rootObjects()
			->select(r|r.oclIsKindOf(UML::Model)).oclAsType(UML::Model)
			->asSequence()->first();
    log('GRA uml model root '+graRoot.repr());    

	graRoot.initializeProfileGlobals();	
	graRoot.initializeSppProfileGlobals();
	// locate the uml spp catalog and map it to target catalog
    log('GRA soamlServicesArchitectureStereotype '+soamlServicesArchitectureStereotype.repr());    
	graRoot.allSubobjectsOfKind(UML::Package).oclAsType(UML::Package).packagedElement
		->select(e|e.isGraCatalog()).oclAsType(UML::InstanceSpecification)
		.map SppCatalog_DocumentRoot();	 
	return;
	}
query UML::Element::isGraCatalog():Boolean=
	self.oclIsKindOf(UML::InstanceSpecification) 
	and 
//	self.oclAsType(UML::InstanceSpecification).classifier->exists(c|c.name='GRA Service Specification');
	self.oclAsType(UML::InstanceSpecification).classifier->exists(c|c.name='ServiceDescription');
	 
//	self.oclIsKindOf(UML::Collaboration);
/////////////////////////////////////////////////catalog mappings
// represents the ssp model as a whole, all elements will be contained in the model
// within the model, it is also a servicesArchitecture
// context is GRA Service Specification
mapping 	UML::InstanceSpecification::SppCatalog_DocumentRoot():SPPCAT::DocumentRoot@cat{
	catalog:=self.map SppCatalog_ProvisioningComponent();
}

// context is GRA Service Specification
mapping 	UML::InstanceSpecification::SppCatalog_ProvisioningComponent():SPPCAT::CatalogType1@cat{
	sppCatalogUml:=self;
	
	//  get metadata and other artifacts during Catalog processing
	//  fully expand wsdl target content
	//  in the process, expand the spp schemas
	// process all content
	// create the items, establish containment, set stereotypes and apply tags discretely
	// catalog implicit
	// metadata : combine-in
	// service-description implicit
	// 	service-interface-description implicit from wsdl-schema
	//  wsdl-schema : similar to NIEM FileType
	//  soap-sample : similar to NIEM FileType
	// iepd-catalog : similar to NIEM FileType
	self.map Catalog(result);
	self.map Metadata(result);
	self.map ServiceDescriptionType(result);

	self.wsdlInterfaceSchema().map ServiceInterfaceDescriptionType(self,result);
	/*
	self.soapSample().map SoapSampleType(result);

	*/
	self.wsdlSchema().map WsdlSchemaType(result);
	self.iepdCatalog().map IepdCatalogType(result);
	self.map GRA_WSDL();
	
}
/*
    - <!--   Service Description Files Section    -->
	<service-description href="artifacts/SIRS_SDD_v_1.0.0.doc">Service Description Document</service-description>
    - <!--   Service Interface Files Section    -->
	<service-interface-description href="artifacts/Notification Service Interface/SIRS_SIDD_NSI_v_1.0.0.doc">Service Interface Description Document</service-interface-description>
	<service-interface-description href="artifacts/Relocation Service Interface/SIRS_SIDD_RSI_v_1.0.0.doc">Service Interface Description Document</service-interface-description>

*/
// context is property whose type is a component representing ServiceInterfaceDescription
// spp is GRA Service Specification
query UML::Property::SIDDhref(serviceMetadata:METADATA::ServiceMetadataType):String{
		
	var serviceIdentification:METADATA::ServiceIdentificationType=serviceMetadata.serviceIdentification;
	var abbrev:String=serviceIdentification.serviceNameAbbreviationText->first();	
	if(abbrev.oclIsUndefined())then{
		abbrev:='UNK';
	}endif;
	var versionInformation:METADATA::VersionInformationType=serviceMetadata.versionInformation;
	var majorVersion:Integer=versionInformation.majorVersion;
	var minorVersion:Integer=versionInformation.minorVersion;
	var revisionVersion:Integer=versionInformation.revisionVersion;
	if(majorVersion.oclIsUndefined())then{majorVersion:=1;}endif;
	if(minorVersion.oclIsUndefined())then{minorVersion:=0;}endif;
	var ifcAbbrev:String=self.name.replace(' ','');
//	var ifcName:String=self.slot->select(s|s.definingFeature.name='Service').value.oclAsType(UML::InstanceValue).instance.name->first();
	var ifcName:String=self.type.name;
	var href:String='artifacts/'+ifcName+'/'+abbrev+'_SIDD_'+ifcAbbrev+'_v_'+majorVersion.toString()+'.'+minorVersion.toString()+'.'+revisionVersion.toString()+'.docx';
	return href;
	
}
mapping 	UML::Property::ServiceInterfaceDescriptionType(spp:UML::InstanceSpecification,inout catalog:SPPCAT::CatalogType1):SPPCAT::ServiceInterfaceDescriptionType@cat{
	catalog.serviceInterfaceDescription+=result;
	var serviceMetadata:METADATA::ServiceMetadataType=spp.map MetadataDocument(catalog.metadata).serviceMetadata->asSequence()->first();
	/*
		
	var serviceIdentification:METADATA::ServiceIdentificationType=serviceMetadata.serviceIdentification;
	var abbrev:String=serviceIdentification.serviceNameAbbreviationText->first();	
	if(abbrev.oclIsUndefined())then{
		abbrev:='UNK';
	}endif;
	var versionInformation:METADATA::VersionInformationType=serviceMetadata.versionInformation;
	var majorVersion:Integer=versionInformation.majorVersion;
	var minorVersion:Integer=versionInformation.minorVersion;
	var revisionVersion:Integer=versionInformation.revisionVersion;
	if(majorVersion.oclIsUndefined())then{majorVersion:=1;}endif;
	if(minorVersion.oclIsUndefined())then{minorVersion:=0;}endif;
	var ifcAbbrev:String=self.name.replace(' ','');
//	var ifcName:String=self.slot->select(s|s.definingFeature.name='Service').value.oclAsType(UML::InstanceValue).instance.name->first();
	var ifcName:String=self.type.name;
	href:='artifacts/'+ifcName+'/'+abbrev+'_SIDD_'+ifcAbbrev+'_v_'+majorVersion.toString()+'.'+minorVersion.toString()+'.'+revisionVersion.toString()+'.docx';
	*/
	href:=self.SIDDhref(serviceMetadata);
	value:='Service Interface Description Document';
}
query 	METADATA::ServiceMetadataType::SDDhref():String{
	var serviceIdentification:METADATA::ServiceIdentificationType=self.serviceIdentification;
	var abbrev:String=serviceIdentification.serviceNameAbbreviationText->first();
	if(abbrev.oclIsUndefined())	then{
		abbrev:='UNK';
	}endif;
	var versionInformation:METADATA::VersionInformationType=self.versionInformation;
	
	var majorVersion:Integer=versionInformation.majorVersion;
	var minorVersion:Integer=versionInformation.minorVersion;
	var revisionVersion:Integer=versionInformation.revisionVersion;
	var href:String='artifacts/'+abbrev+'_SDD_v_'+majorVersion.toString()+'.'+minorVersion.toString()+'.'+revisionVersion.toString()+'.docx';
	return href;
}
mapping 	UML::InstanceSpecification::ServiceDescriptionType(inout catalog:SPPCAT::CatalogType1):SPPCAT::ServiceDescriptionType@cat{
	catalog.serviceDescription:=result;
	var serviceMetadata:METADATA::ServiceMetadataType=self.map MetadataDocument(catalog.metadata).serviceMetadata->asSequence()->first();
		/*
	var serviceIdentification:METADATA::ServiceIdentificationType=serviceMetadata.serviceIdentification;
	var abbrev:String=serviceIdentification.serviceNameAbbreviationText->first();
	if(abbrev.oclIsUndefined())	then{
		abbrev:='UNK';
	}endif;
	var versionInformation:METADATA::VersionInformationType=serviceMetadata.versionInformation;
	
	var majorVersion:Integer=versionInformation.majorVersion;
	var minorVersion:Integer=versionInformation.minorVersion;
	var revisionVersion:Integer=versionInformation.revisionVersion;
	href:='artifacts/'+abbrev+'_SDD_v_'+majorVersion.toString()+'.'+minorVersion.toString()+'.'+revisionVersion.toString()+'.docx';
	*/
	href:=serviceMetadata.SDDhref();
	value:='Service Description Document';
}
	
query UML::NamedElement::clientRealization():Sequence(UML::Realization)=
	self.clientDependency->select(s|s.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization)->asSequence();
query UML::NamedElement::realizedCollaboration():Sequence(UML::Collaboration)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Collaboration)).oclAsType(UML::Collaboration)->asSequence();
query UML::NamedElement::realizedNamedElement():Sequence(UML::NamedElement)=
	self.clientRealization().supplier->select(s|s.oclIsKindOf(UML::NamedElement)).oclAsType(UML::NamedElement)->asSequence();
query UML::NamedElement::realizedPackage():Sequence(UML::Package)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Package)).oclAsType(UML::Package)->asSequence();
query UML::NamedElement::realizedComponent():Sequence(UML::Component)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Component)).oclAsType(UML::Component)->asSequence();
query UML::NamedElement::realizedPort():Sequence(UML::Port)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Port)).oclAsType(UML::Port)->asSequence();
query UML::NamedElement::realizedParameter():Sequence(UML::Parameter)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Parameter)).oclAsType(UML::Parameter)->asSequence();
query UML::NamedElement::realizedTypedElement():Sequence(UML::TypedElement)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::TypedElement)).oclAsType(UML::TypedElement)->asSequence();
query UML::NamedElement::realizedBehavioralFeature():Sequence(UML::BehavioralFeature)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::BehavioralFeature)).oclAsType(UML::BehavioralFeature)->asSequence();
query UML::NamedElement::realizedInterface():Sequence(UML::Interface)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Interface)).oclAsType(UML::Interface)->asSequence();
query UML::NamedElement::realizedActor():Sequence(UML::Actor)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSequence();
query UML::NamedElement::realizedInteraction():Sequence(UML::Interaction)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Interaction)).oclAsType(UML::Interaction)->asSequence();
query UML::NamedElement::realizedType():Sequence(UML::Type)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Type)).oclAsType(UML::Type)->asSequence();
query UML::Type::isWsdlComponent():Boolean=
	self.oclIsKindOf(UML::Component)
	and
	self.oclAsType(UML::Component).ownedPort->exists(p|p.provided->notEmpty());
	
query UML::InstanceSpecification::wsdlInterfaceSchema():Sequence(UML::Property)=
//	self.slot->select(s|s.definingFeature.name='ServiceInteractionProfile').value.oclAsType(UML::InstanceValue).instance
	self.realizedCollaboration().ownedAttribute->select(a|a.type.isWsdlComponent())
	->asSequence();
query UML::InstanceSpecification::wsdlSchema():Sequence(UML::Property)=
	self.wsdlInterfaceSchema();
query UML::InstanceSpecification::iepdCatalog():Sequence(UML::Usage)=
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).oclAsType(UML::Usage)
		->select(d|d.supplier->forAll(s|s.isStereotypeApplied(prompdStereotype)))->asSequence();
query UML::InstanceSpecification::soapSample():Sequence(UML::Usage)=
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).oclAsType(UML::Usage)
		->select(d|d.supplier->forAll(s|s.oclIsKindOf(UML::InstanceSpecification)))->asSequence();
// adjust href, if necessary, to be relative to spp package
query UML::Usage::toRelativeSppLocation():String{
	// client is spp catalog, we want relative path to supplier from catalog's package
	// 	<service-interface-description href="artifacts/Notification Service Interface/SIRS_SIDD_NSI_v_1.0.0.doc">Service Interface Description Document</service-interface-description>
	var sppRootPackage:UML::Package=self.client->asSequence()->first().getNearestPackage();
	var target:UML::NamedElement=self.supplier->asSequence()->first();
	// if not in containment of spp package, then assume it is an iepd
	var relativePackagePath:String=target.qualifiedName.substringAfter(sppRootPackage.qualifiedName+'::');
	if(relativePackagePath.oclIsUndefined())then{
		relativePackagePath:='artifacts::service model::information model::'+target.name;
	}endif;
	return relativePackagePath.replace('::','/');
};
query UML::InstanceSpecification::toRelativeSppLocation():String{
	// have to assume this is wsdl at standard location, plus name of instance
	var relativePackagePath:String:='schema::SIP::'+self.name;
	return relativePackagePath.replace('::','/');
};
query UML::Component::toRelativeSppLocation():String{
	// have to assume this is wsdl at standard location, plus name of instance
	var relativePackagePath:String:='schema::SIP::'+self.name;
	return relativePackagePath.replace('::','/');
};
// context is GRA Service Specification

mapping 	UML::InstanceSpecification::Metadata(inout catalog:SPPCAT::CatalogType1):SPPCAT::MetadataType@cat{
	catalog.metadata:=result;
	href:='metadata.xml';
	value:='Metadata';
	//	<metadata href="metadata.xml">Metadata</metadata>
	self.map MetadataDocument(result);
}
query UML::NamedElement::supplierRealization():Sequence(UML::Realization)=
	self.getTargetDirectedRelationships()->select(d|d.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization)->asSequence();
query UML::NamedElement::realizingInstance(artifactName:String):Sequence(InstanceSpecification)=
	self.supplierRealization().client
		->select(d|d.oclIsKindOf(UML::InstanceSpecification) 
			and d.oclAsType(UML::InstanceSpecification).classifier->exists(c|c.name=artifactName))
			.oclAsType(UML::InstanceSpecification)->asSequence();
query UML::NamedElement::realizingInstance():Sequence(InstanceSpecification)=
	self.supplierRealization().client
		->select(d|d.oclIsKindOf(UML::InstanceSpecification)).oclAsType(UML::InstanceSpecification);
query UML::Property::wsdlLocation():String{
	var wsdlComponent:UML::Component=self.type.oclAsType(UML::Component);
	var serviceInterfaceDescription:UML::InstanceSpecification=wsdlComponent.realizingInstance('ServiceInterfaceDescription')->first();
	var value:String=self.name;
	if(value.oclIsUndefined())then{
		value:=wsdlComponent.name;
	}endif;
	var wsdlLocation:String:='schema/SIP/'+value+'.wsdl';
	return wsdlLocation;
}		
query UML::Property::wsdlDescription():String{
	var wsdlComponent:UML::Component=self.type.oclAsType(UML::Component);
	var serviceInterfaceDescription:UML::InstanceSpecification=wsdlComponent.realizingInstance('ServiceInterfaceDescription')->first();
	var value:String=serviceInterfaceDescription.name;
	if(value.oclIsUndefined())then{
		value:=wsdlComponent.name;
	}endif;
	return value+' Service Schema';
}		
// context is property in collaboration whose type is a component corresponding to wsdl
mapping 	UML::Property::WsdlSchemaType(inout catalog:SPPCAT::CatalogType1):SPPCAT::WsdlSchemaType@cat
{
	catalog.wsdlSchema+=result;
	var wsdlComponent:UML::Component=self.type.oclAsType(UML::Component);
	var serviceInterfaceDescription:UML::InstanceSpecification=wsdlComponent.realizingInstance('ServiceInterfaceDescription')->first();
	/*
	var wsdlLocation:String:=serviceInterfaceDescription.toRelativeSppLocation();
	if(wsdlLocation.oclIsUndefined())then{
		wsdlLocation:=wsdlComponent.toRelativeSppLocation();
	}endif;
	if(not(wsdlLocation.endsWith('.wsdl')))then{wsdlLocation:=wsdlLocation+'.wsdl';}endif;
	*/
	value:=self.wsdlDescription();
	var wsdlLocation:String:=self.wsdlLocation();
	href:=wsdlLocation;
	log('Catalog WsdlSchemaType reference '+result.href);
	//wsdlComponent.);// no wsdl
	
}
mapping 	UML::Usage::IepdCatalogType(inout catalog:SPPCAT::CatalogType1):SPPCAT::IepdCatalogType@cat
{
	catalog.iepdCatalog:=result;
	href:=self.toRelativeSppLocation();
	if(not(result.href.endsWith('catalog.xml')))then{href:=result.href+'/catalog.xml';}endif;
	value:=self.name;
	if(value.oclIsUndefined())then{
		self.supplier->forEach(s){
			value:=s.name;
		};
	}endif;
	// TODO: assume this is handled as a separate process
	//self.supplier.oclAsType(UML::Component).map IepdCatalogType(result);
}

mapping 	UML::Usage::SoapSampleType(inout catalog:SPPCAT::CatalogType1):SPPCAT::SoapSampleType@cat
{
	catalog.soapSample+=result;
	href:=self.toRelativeSppLocation();
	value:=self.name;
	// defer creation of xml
	//self.supplier.oclAsType(UML::InstanceSpecification).map SoapSampleType(result);
}
mapping 	UML::InstanceSpecification::Catalog(inout catalog:SPPCAT::CatalogType1):SPPCAT::CatalogType@cat{
	catalog.catalog:=result;
	href:='catalog.html';
	value:='Catalog';
}
////////////////////////////////////////////metadata
// context is GRA Service Specification

mapping 	UML::InstanceSpecification::MetadataDocument(inout metadataType:SPPCAT::MetadataType):METADATA::DocumentRoot@metadata{
	metadataDocument:=result;
	self.map ServiceMetadataType(result);
	var metadataLocation:CMOF::EStringToStringMapEntry=new CMOF::EStringToStringMapEntry();
	metadataLocation.key:='http://it.ojp.gov/gsp/services/1.0.0';
	metadataLocation.value:='Metadata.xsd';
	 
	result.xSISchemaLocation+=metadataLocation;
}
query UML::Element::isServiceIdentification():Boolean=
//	self.isStereotypeApplied(graServiceInterfaceSpecificationStereotype)
//	self.oclIsKindOf(UML::Class) or self.oclIsKindOf(UML::Interface)
	self.oclIsKindOf(UML::Component) and self.oclAsType(UML::Component).ownedPort->exists(p|p.provided->notEmpty())
	;
	
query UML::Element::isServiceInterfaceSpecification():Boolean=
	//self.isStereotypeApplied(graServiceIdentificationStereotype)
//	self.oclIsKindOf(UML::Component) and self.oclAsType(UML::Component).ownedPort->exists(p|p.provided->notEmpty())
	self.oclIsKindOf(UML::Class) or self.oclIsKindOf(UML::Interface)
	;
//query UML::InstanceSpecification::serviceIdentifications():Sequence(UML::InstanceSpecification)=
//	self.slot->select(s|s.definingFeature.name='ServiceIdentification').value.oclAsType(UML::InstanceValue).instance->asSequence();
//query UML::Collaboration::serviceIdentifications():Sequence(UML::Component)=
//	self.role.type->select(s|s.isServiceIdentification()).oclAsType(UML::Component)->asSequence();
query UML::Collaboration::serviceIdentifications():Sequence(UML::InstanceSpecification)=
//	self.role.type->select(s|s.isServiceIdentification()).oclAsType(UML::Component)->asSequence();
	self.realizingInstance();
	
query UML::Collaboration::serviceIdentification():METADATA::ServiceIdentificationType=
	self.serviceIdentifications()->first().map ServiceIdentificationType();
	
// context is GRA Service Specification
mapping 	UML::InstanceSpecification::ServiceMetadataType(inout document:METADATA::DocumentRoot):METADATA::ServiceMetadataType@metadata
{
	document.serviceMetadata:=result;
	//self.useCase.map RelatedOrganizationInformationType(result);
	var serviceCollaboration:UML::Collaboration=self.realizedCollaboration()->first();
	theServiceCollaboration:=serviceCollaboration;
	// serviceIdentification is a participant component and a role of the services architecture 
	serviceIdentification:=serviceCollaboration.serviceIdentification();
	serviceCollaboration.map RelatedOrganizationInformationType(result);
	
//	self.getNearestPackage().packagedElement
//		->select(s|s.()).oclAsType(UML::Class).map ServiceInterfaceSpecification(result);
	serviceCollaboration.ownedAttribute
//		->select(a|a.aggregation=UML::AggregationKind::composite).type
//		->select(a|a.aggregation<>UML::AggregationKind::composite).type
		.type
		->select(t|t.isServiceIdentification()).oclAsType(UML::Component)
//		.ownedPort.type
//		->select(s|s.isServiceInterfaceSpecification()).oclAsType(UML::Classifier)
		.map ServiceInterfaceSpecification(result);
		
	self.map ServiceDescription(result);
	self.map VersionInformation(result);
	self.map BusinessContext(result);
	/*
	serviceCollaboration.ownedAttribute
		->select(a|a.aggregation<>UML::AggregationKind::composite).type
		->select(t|t.isServiceIdentification()).oclAsType(UML::Component).map BusinessContext(result);
	*/
	/*
	serviceCollaboration.collaborationUse.type
		->select(t|t.isStereotypeApplied(graServiceLevelAgreementsStereotype))
		->asSequence()->first().oclAsType(UML::Collaboration).map ServiceLevelAgreements(result);
		*/
	self.slot->select(s|s.definingFeature.name='ServiceLevelAgreement').value.oclAsType(UML::InstanceValue).instance	
		.map ServiceLevelAgreements(result);
}

//mapping UML::Collaboration::ServiceLevelAgreements(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceLevelAgreementsType
mapping UML::InstanceSpecification::ServiceLevelAgreements(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceLevelAgreementsType
{
	serviceMetadata.serviceLevelAgreements:=result;
	//var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
	self.map ServicePolicyAndContracts(result);
	self.map PerformanceMetrics(result);
	self.map ServiceUsageDetails(result);
}

mapping UML::InstanceSpecification::ServiceUsageDetails(inout serviceLevelAgreementsType:METADATA::ServiceLevelAgreementsType):METADATA::ServiceUsageType
{
	serviceLevelAgreementsType.serviceUsageDetails:=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	approvalRequiredIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='ApprovalRequiredIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	licensingRequiredIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='LicensingRequiredIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	
	self.map LicensingAgreement(result);
	self.map ServiceCost(result);
}
mapping UML::InstanceSpecification::ServiceCost(inout serviceUsageDetailsType:METADATA::ServiceUsageType):METADATA::CostType
{
	serviceUsageDetailsType.serviceCost:=result;
	self.map UsageCostAmount(result);
	self.map UsageUnitCostAmount(result);
	self.map CreationCostAmount(result);
}
mapping UML::InstanceSpecification::CreationCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.creationCostAmount:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	value:=appliedStereotype.getTagValue('creationCostAmountValue').oclAsType(Real);
	currencyText:=appliedStereotype.getTagValue('creationCostAmountCurrencyText').oclAsType(String);
	*/
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='CreationCostAmount').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	value:=appliedStereotype.slot->select(s|s.definingFeature.name='value').value.oclAsType(UML::LiteralReal).value->asSequence()->first();
	currencyText:=appliedStereotype.slot->select(s|s.definingFeature.name='currencyText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}
mapping UML::InstanceSpecification::UsageUnitCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.usageUnitCostAmount:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	value:=appliedStereotype.getTagValue('usageUnitCostAmountValue').oclAsType(Real);
	currencyText:=appliedStereotype.getTagValue('usageUnitCostAmountCurrencyText').oclAsType(String);
	*/
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='UsageUnitCostAmount').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	value:=appliedStereotype.slot->select(s|s.definingFeature.name='value').value.oclAsType(UML::LiteralReal).value->asSequence()->first();
	currencyText:=appliedStereotype.slot->select(s|s.definingFeature.name='currencyText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}
mapping UML::InstanceSpecification::UsageCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.usageCostAmount:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	value:=appliedStereotype.getTagValue('usageCostAmountValue').oclAsType(Real);
	currencyText:=appliedStereotype.getTagValue('usageCostAmountCurrencyText').oclAsType(String);
	*/
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='UsageCostAmount').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	value:=appliedStereotype.slot->select(s|s.definingFeature.name='value').value.oclAsType(UML::LiteralReal).value->asSequence()->first();
	currencyText:=appliedStereotype.slot->select(s|s.definingFeature.name='currencyText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}
mapping UML::InstanceSpecification::LicensingAgreement(inout serviceUsageDetailsType:METADATA::ServiceUsageType):METADATA::AgreementType
{
	serviceUsageDetailsType.licensingAgreement:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	agreementDescriptionText:=appliedStereotype.getTagValue('licensingAgreementDescriptionText').oclAsType(String);
	agreementURI:=appliedStereotype.getTagValue('licensingAgreementURI').oclAsType(String);
	*/
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='LicensingAgreement').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
//	agreementDescriptionText:=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
//	agreementDescriptionText:=appliedStereotype.realizedNamedElement().ownedComment.body->asSequence()->first();
	agreementDescriptionText:=appliedStereotype.ownedComment.body->asSequence()->first();
	agreementURI:=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementURI').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}
mapping UML::InstanceSpecification::PerformanceMetrics(inout serviceLevelAgreementsType:METADATA::ServiceLevelAgreementsType):METADATA::PerformanceMetricsType
{
	serviceLevelAgreementsType.performanceMetrics:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	
	serviceResponseTime:=appliedStereotype.getTagValue('performanceResponseDuration').oclAsType(String).toDuration();
	serviceAverageThroughput:=appliedStereotype.getTagValue('serviceAverageThroughput').oclAsType(String);
	serviceMaximumThroughput:=appliedStereotype.getTagValue('serviceMaximumThroughput').oclAsType(String);
	serviceAvailability:=appliedStereotype.getTagValue('serviceAvailability').oclAsType(String);
	*/
	var appliedStereotype:UML::InstanceSpecification=self;
	serviceResponseTime:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceResponseTime').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDuration();
	serviceAverageThroughput:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceAverageThroughput').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	serviceMaximumThroughput:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceMaximumThroughput').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	serviceAvailability:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceAvailability').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}

/*
mapping UML::Collaboration::CreationCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.creationCostAmount:=result;
	/ *
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	value:=appliedStereotype.getTagValue('creationCostAmountValue').oclAsType(Real);
	currencyText:=appliedStereotype.getTagValue('creationCostAmountCurrencyText').oclAsType(String);
	* /
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	value:=appliedStereotype.slot->select(s|s.definingFeature.name='creationCostAmountValue').value.oclAsType(UML::LiteralReal).value->asSequence()->first();
	currencyText:=appliedStereotype.slot->select(s|s.definingFeature.name='creationCostAmountCurrencyText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}
mapping UML::Collaboration::UsageUnitCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.usageUnitCostAmount:=result;
	/ *
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	value:=appliedStereotype.getTagValue('usageUnitCostAmountValue').oclAsType(Real);
	currencyText:=appliedStereotype.getTagValue('usageUnitCostAmountCurrencyText').oclAsType(String);
	* /
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	value:=appliedStereotype.slot->select(s|s.definingFeature.name='usageUnitCostAmountValue').value.oclAsType(UML::LiteralReal).value->asSequence()->first();
	currencyText:=appliedStereotype.slot->select(s|s.definingFeature.name='usageUnitCostAmountCurrencyText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}
mapping UML::Collaboration::UsageCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.usageCostAmount:=result;
	/ *
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	value:=appliedStereotype.getTagValue('usageCostAmountValue').oclAsType(Real);
	currencyText:=appliedStereotype.getTagValue('usageCostAmountCurrencyText').oclAsType(String);
	* /
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	value:=appliedStereotype.slot->select(s|s.definingFeature.name='usageCostAmountValue').value.oclAsType(UML::LiteralReal).value->asSequence()->first();
	currencyText:=appliedStereotype.slot->select(s|s.definingFeature.name='usageCostAmountCurrencyText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}

mapping UML::Collaboration::LicensingAgreement(inout serviceUsageDetailsType:METADATA::ServiceUsageType):METADATA::AgreementType
{
	serviceUsageDetailsType.licensingAgreement:=result;
	/ *
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	agreementDescriptionText:=appliedStereotype.getTagValue('licensingAgreementDescriptionText').oclAsType(String);
	agreementURI:=appliedStereotype.getTagValue('licensingAgreementURI').oclAsType(String);
	* /
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	agreementDescriptionText:=appliedStereotype.slot->select(s|s.definingFeature.name='licensingAgreementDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	agreementURI:=appliedStereotype.slot->select(s|s.definingFeature.name='licensingAgreementURI').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}
mapping UML::Collaboration::PerformanceMetrics(inout serviceLevelAgreementsType:METADATA::ServiceLevelAgreementsType):METADATA::PerformanceMetricsType
{
	serviceLevelAgreementsType.performanceMetrics:=result;
	/ *
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	
	serviceResponseTime:=appliedStereotype.getTagValue('performanceResponseDuration').oclAsType(String).toDuration();
	serviceAverageThroughput:=appliedStereotype.getTagValue('serviceAverageThroughput').oclAsType(String);
	serviceMaximumThroughput:=appliedStereotype.getTagValue('serviceMaximumThroughput').oclAsType(String);
	serviceAvailability:=appliedStereotype.getTagValue('serviceAvailability').oclAsType(String);
	* /
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	serviceResponseTime:=appliedStereotype.slot->select(s|s.definingFeature.name='performanceResponseDuration').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDuration();
	serviceAverageThroughput:=appliedStereotype.slot->select(s|s.definingFeature.name='serviceAverageThroughput').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	serviceMaximumThroughput:=appliedStereotype.slot->select(s|s.definingFeature.name='serviceMaximumThroughput').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	serviceAvailability:=appliedStereotype.slot->select(s|s.definingFeature.name='serviceAvailability').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}
*/
mapping UML::InstanceSpecification::ServicePolicyAndContracts(inout serviceLevelAgreementsType:METADATA::ServiceLevelAgreementsType):METADATA::ServicePolicyAndContractsType
{
	serviceLevelAgreementsType.servicePolicyAndContracts:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	applicablePoliciesIndicator:=appliedStereotype.getTagValue('applicablePoliciesIndicator').oclAsType(Boolean);
	self.map ApplicablePolicies(result);	
	applicableContractsIndicator:=appliedStereotype.getTagValue('applicableContractsIndicator').oclAsType(Boolean);
	
	applicableAgreementsIndicator:=appliedStereotype.getTagValue('applicableAgreementsIndicator').oclAsType(Boolean);
	applicableUmbrellaAgreementsIndicator:=appliedStereotype.getTagValue('applicableUmbrellaAgreementsIndicator').oclAsType(Boolean);
	*/
	var appliedStereotype:UML::InstanceSpecification=self;
	applicablePoliciesIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='ApplicablePoliciesIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	self.map ApplicablePolicies(result);	
	applicableContractsIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='ApplicableContractsIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	
	applicableAgreementsIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='ApplicableAgreementsIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	applicableUmbrellaAgreementsIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='ApplicableUmbrellaAgreementsIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	
	//domainNameText:=appliedStereotype.getTagValue('domainNameText');
	self.map ApplicableContracts(result);	
	self.map ApplicableAgreements(result);	
	self.map ApplicableUmbrellaAgreements(result);	
}
mapping UML::InstanceSpecification::ApplicablePolicies(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicablePoliciesType
{
	servicePolicyAndContractsType.applicablePolicies:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	policyText:=appliedStereotype.getTagValue('policyText').oclAsType(String);
	*/
	var appliedStereotype:UML::InstanceSpecification=self;
	policyText:=appliedStereotype.slot->select(s|s.definingFeature.name='ApplicablePolicies').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}

mapping UML::InstanceSpecification::ApplicableUmbrellaAgreements(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicableUmbrellaAgreementsType
{
	servicePolicyAndContractsType.applicableUmbrellaAgreements:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	var umbrellaAgreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.getTagValues('umbrellaAgreementAgreementDescriptionText').oclAsType(String)	;
	var umbrellaAgreementAgreementURIs:Sequence(String)=appliedStereotype.getTagValues('umbrellaAgreementAgreementURI').oclAsType(String)	;
	*/
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='UmbrellaAgreement').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
//	var umbrellaAgreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence();
//	var umbrellaAgreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.realizedNamedElement().ownedComment.body->asSequence();
	var umbrellaAgreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.ownedComment.body->asSequence();
	var umbrellaAgreementAgreementURIs:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementURI').value.oclAsType(UML::LiteralString).value->asSequence();
	
	umbrellaAgreementAgreementDescriptionTexts->forEach(umbrellaAgreementAgreementDescriptionText){
		umbrellaAgreementAgreementDescriptionText.map UmbrellaAgreement(result,umbrellaAgreementAgreementURIs->at(umbrellaAgreementAgreementDescriptionTexts->indexOf(umbrellaAgreementAgreementDescriptionText))); 
	};
}
mapping String::UmbrellaAgreement(inout applicableUmbrellaAgreementsType:METADATA::ApplicableUmbrellaAgreementsType,umbrellaAgreementAgreementURIIn:String):METADATA::AgreementType
{
	applicableUmbrellaAgreementsType.umbrellaAgreement+=result;
	agreementDescriptionText:=self;
	agreementURI:=umbrellaAgreementAgreementURIIn;
}

mapping UML::InstanceSpecification::ApplicableAgreements(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicableAgreementsType
{
	servicePolicyAndContractsType.applicableAgreements:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	var agreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.getTagValues('agreementAgreementDescriptionText').oclAsType(String)	;
	var agreementAgreementURIs:Sequence(String)=appliedStereotype.getTagValues('agreementAgreementURI').oclAsType(String)	;
	*/
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='Agreement').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
//	var agreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence();
//	var agreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.realizedNamedElement().ownedComment.body->asSequence();
	var agreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.ownedComment.body->asSequence();
	
	var agreementAgreementURIs:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementURI').value.oclAsType(UML::LiteralString).value->asSequence();
	
	agreementAgreementDescriptionTexts->forEach(agreementAgreementDescriptionText){
		agreementAgreementDescriptionText.map Agreement(result,agreementAgreementURIs->at(agreementAgreementDescriptionTexts->indexOf(agreementAgreementDescriptionText))); 
	};
}
mapping String::Agreement(inout applicableAgreementsType:METADATA::ApplicableAgreementsType,agreementAgreementURIIn:String):METADATA::AgreementType
{
	applicableAgreementsType.agreement+=result;
	agreementDescriptionText:=self;
	agreementURI:=agreementAgreementURIIn;
}
mapping UML::InstanceSpecification::ApplicableContracts(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicableContractsType
{
	servicePolicyAndContractsType.applicableContracts:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	var contractAgreementDescriptionTexts:Sequence(String)=appliedStereotype.getTagValues('contractAgreementDescriptionText').oclAsType(String)	;
	var contractAgreementURIs:Sequence(String)=appliedStereotype.getTagValues('contractAgreementURI').oclAsType(String)	;
	*/
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='ApplicableContract').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
//	var contractAgreementDescriptionTexts:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence();
//	var contractAgreementDescriptionTexts:Sequence(String)=appliedStereotype.realizedNamedElement().ownedComment.body->asSequence();
	var contractAgreementDescriptionTexts:Sequence(String)=appliedStereotype.ownedComment.body->asSequence();
	
	var contractAgreementURIs:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementURI').value.oclAsType(UML::LiteralString).value->asSequence();
	log('ApplicableContracts '+contractAgreementDescriptionTexts->size().repr()+', '+contractAgreementURIs->size().repr());
	contractAgreementDescriptionTexts->forEach(contractAgreementDescriptionText){
		contractAgreementDescriptionText.map Contract(result,contractAgreementURIs->at(contractAgreementDescriptionTexts->indexOf(contractAgreementDescriptionText))); 
	};
}
mapping String::Contract(inout applicableContractsType:METADATA::ApplicableContractsType,contractAgreementURIIn:String):METADATA::AgreementType
{
	applicableContractsType.contract+=result;
	agreementDescriptionText:=self;
	agreementURI:=contractAgreementURIIn;
	log('Contract  '+self+', '+contractAgreementURIIn);
}
// context is exchange partner 
//mapping UML::Component::BusinessContext(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::BusinessContextType
mapping UML::InstanceSpecification::BusinessContext(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::BusinessContextType
{
	serviceMetadata.businessContext:=result;
	//var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
			
	self.map DomainDescription(result);
	self.map Classifications(result);
	self.map ExchangePartnerTypes(result);
	self.map Endorsements(result);
	self.map Sponsors(result);
}
//mapping UML::Component::Classifications(inout businessContext:METADATA::BusinessContextType):METADATA::ClassificationsType
mapping UML::InstanceSpecification::Classifications(inout businessContext:METADATA::BusinessContextType):METADATA::ClassificationsType
{
	businessContext.classifications:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graBusinessContextStereotype).oclAsType(Stdlib::Element);
	classification:=appliedStereotype.getTagValue('classification').oclAsType(String);
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	classification:=appliedStereotype.slot->select(s|s.definingFeature.name='contractAgreementDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	*/
	var appliedStereotype:UML::InstanceSpecification=self;
	classification:=appliedStereotype.slot->select(s|s.definingFeature.name='Classification').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
}
mapping UML::InstanceSpecification::DomainDescription(inout businessContext:METADATA::BusinessContextType):METADATA::DomainDescriptionType
{
	businessContext.domainDescription:=result;
	//var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
//	domainNameText:=appliedStereotype.getTagValue('domainNameText').oclAsType(String);
//	domainNameText:=self.name;
//	domainNameText:=self.slot->select(s|s.definingFeature.name='DomainDescription').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	var serviceCollaboration:UML::Collaboration=self.realizedCollaboration()->first();
	domainNameText:=serviceCollaboration.ownedComment.body->asSequence()->first();
}

mapping UML::InstanceSpecification::Sponsors(inout businessContext:METADATA::BusinessContextType):METADATA::SponsorsType
{
	businessContext.sponsors:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graBusinessContextStereotype).oclAsType(Stdlib::Element);
	sponsor+=appliedStereotype.getTagValues('sponsor').oclAsType(String);
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	sponsor+=appliedStereotype.slot->select(s|s.definingFeature.name='sponsor').value.oclAsType(UML::LiteralString).value->asSequence();
	*/
	var appliedStereotype:UML::InstanceSpecification=self;
	sponsor+=appliedStereotype.slot->select(s|s.definingFeature.name='Sponsors').value.oclAsType(UML::LiteralString).value->asSequence();
	
}
mapping UML::InstanceSpecification::Endorsements(inout businessContext:METADATA::BusinessContextType):METADATA::EndorsementsType
{
	businessContext.endorsements:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graBusinessContextStereotype).oclAsType(Stdlib::Element);
	endorser+=appliedStereotype.getTagValues('endorser').oclAsType(String);
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	endorser+=appliedStereotype.slot->select(s|s.definingFeature.name='endorser').value.oclAsType(UML::LiteralString).value->asSequence();
	*/
	var appliedStereotype:UML::InstanceSpecification=self;
	endorser+=appliedStereotype.slot->select(s|s.definingFeature.name='Endorsements').value.oclAsType(UML::LiteralString).value->asSequence();
	
}
mapping UML::InstanceSpecification::ExchangePartnerTypes(inout businessContext:METADATA::BusinessContextType):METADATA::ExchangePartnerTypesType
{
	businessContext.exchangePartnerTypes:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graBusinessContextStereotype).oclAsType(Stdlib::Element);
	exchangePartnerTypeDescriptionText:=appliedStereotype.getTagValue('exchangePartnerTypeDescriptionText').oclAsType(String);
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	exchangePartnerTypeDescriptionText:=appliedStereotype.slot->select(s|s.definingFeature.name='exchangePartnerTypeDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	*/
//	var appliedStereotype:Sequence(UML::InstanceSpecification)=self.slot->select(s|s.definingFeature.name='ExchangePartner').value.oclAsType(UML::InstanceValue).instance->asSequence();
//	exchangePartnerTypeDescriptionText:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationRoleDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	var serviceCollaboration:UML::Collaboration=self.realizedCollaboration()->first();
	exchangePartnerTypeDescriptionText:=serviceCollaboration.role
		->select(r|r.oclIsKindOf(UML::Property) and r.oclAsType(UML::Property).isComposite).type
		->select(s|s.oclIsKindOf(UML::Component)).ownedComment.body->asSequence()->first();
}
// context is GRA Service Specification

mapping UML::InstanceSpecification::VersionInformation(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::VersionInformationType
{
	serviceMetadata.versionInformation:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
			
	majorVersion:=appliedStereotype.getTagValue('majorVersion').oclAsType(Integer);
	minorVersion:=appliedStereotype.getTagValue('minorVersion').oclAsType(Integer);
	revisionVersion:=appliedStereotype.getTagValue('revisionVersion').oclAsType(Integer);
	creationDate:=appliedStereotype.getTagValue('creationDate').oclAsType(String).toDate();
	activationDate:=appliedStereotype.getTagValue('activationDate').oclAsType(String).toDate();
	lastRevisionDate:=appliedStereotype.getTagValue('lastRevisionDate').oclAsType(String).toDate();
	nextRevisionDate:=appliedStereotype.getTagValue('nextRevisionDate').oclAsType(String).toDate();
	expirationDate:=appliedStereotype.getTagValue('expirationDate').oclAsType(String).toDate();
	lifecycleStatus:=appliedStereotype.getTagValue('lifecycleStatus').oclAsType(String);
	alertsAndNotifications:=appliedStereotype.getTagValue('alertsAndNotification').oclAsType(String);
	*/
	/*
	var appliedStereotype:UML::InstanceSpecification=self;
	majorVersion:=appliedStereotype.slot->select(s|s.definingFeature.name='majorVersion').value.oclAsType(UML::LiteralInteger).value->asSequence()->first();
	minorVersion:=appliedStereotype.slot->select(s|s.definingFeature.name='minorVersion').value.oclAsType(UML::LiteralInteger).value->asSequence()->first();
	lastRevisionDate:=appliedStereotype.slot->select(s|s.definingFeature.name='lastRevisionDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	lifecycleStatus:=appliedStereotype.slot->select(s|s.definingFeature.name='lifecycleStatus').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
	revisionVersion:=appliedStereotype.slot->select(s|s.definingFeature.name='revisionVersion').value.oclAsType(UML::LiteralInteger).value->asSequence()->first();
	creationDate:=appliedStereotype.slot->select(s|s.definingFeature.name='creationDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	activationDate:=appliedStereotype.slot->select(s|s.definingFeature.name='activationDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	nextRevisionDate:=appliedStereotype.slot->select(s|s.definingFeature.name='nextRevisionDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	expirationDate:=appliedStereotype.slot->select(s|s.definingFeature.name='expirationDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	alertsAndNotifications:=appliedStereotype.slot->select(s|s.definingFeature.name='alertsAndNotification').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	*/
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='Version').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	majorVersion:=appliedStereotype.slot->select(s|s.definingFeature.name='MajorVersion').value.oclAsType(UML::LiteralInteger).value->asSequence()->first();
	minorVersion:=appliedStereotype.slot->select(s|s.definingFeature.name='MinorVersion').value.oclAsType(UML::LiteralInteger).value->asSequence()->first();
	if(result.majorVersion.oclIsUndefined())then{
		majorVersion:=1;
	}endif;
	if(result.minorVersion.oclIsUndefined())then{
		minorVersion:=0;
	}endif;
	lastRevisionDate:=appliedStereotype.slot->select(s|s.definingFeature.name='LastRevisionDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	lifecycleStatus:=appliedStereotype.slot->select(s|s.definingFeature.name='LifecycleStatus').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
	revisionVersion:=appliedStereotype.slot->select(s|s.definingFeature.name='RevisionVersion').value.oclAsType(UML::LiteralInteger).value->asSequence()->first();
	creationDate:=appliedStereotype.slot->select(s|s.definingFeature.name='CreationDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	activationDate:=appliedStereotype.slot->select(s|s.definingFeature.name='ActivationDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	nextRevisionDate:=appliedStereotype.slot->select(s|s.definingFeature.name='NextRevisionDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	expirationDate:=appliedStereotype.slot->select(s|s.definingFeature.name='ExpirationDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	alertsAndNotifications+=appliedStereotype.slot->select(s|s.definingFeature.name='AlertsAndNotification').value.oclAsType(UML::LiteralString).value->asSequence();
	if(result.revisionVersion.oclIsUndefined())then{
		revisionVersion:=0;
	}endif;
}
// context is GRA Service Specification

mapping UML::InstanceSpecification::ServiceDescription(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceDescriptionType
{
	serviceMetadata.serviceDescription:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
	
	servicePurposeText:=appliedStereotype.getTagValue('servicePurposeText').oclAsType(String);
	serviceScopeDescriptionText:=appliedStereotype.getTagValue('serviceScopeDescriptionText').oclAsType(String);
	serviceDescriptionSummaryText:=appliedStereotype.getTagValue('serviceDescriptionSummaryText').oclAsType(String);
	serviceDescriptionText:=appliedStereotype.getTagValue('serviceDescriptionText').oclAsType(String);
	serviceDescriptionKeywordText:=appliedStereotype.getTagValue('serviceDescriptionKeywordText').oclAsType(String);
	self.map ServiceCapabilities(result);
	self.map ServiceRealWorldEffects(result);
	securityClassificationText:=appliedStereotype.getTagValue('securityClassificationText').oclAsType(String);
	*/
	var appliedStereotype:UML::InstanceSpecification=self;
	
	servicePurposeText:=appliedStereotype.descriptionText('ServicePurpose');
	serviceScopeDescriptionText:=appliedStereotype.descriptionText('ServiceScopeDescription');
	serviceDescriptionSummaryText:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceDescriptionSummaryText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	serviceDescriptionText:=appliedStereotype.descriptionText('ServiceDescription');
	
	serviceDescriptionKeywordText+=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceDescriptionKeywordText').value.oclAsType(UML::LiteralString).value->asSequence();
	self.map ServiceCapabilities(result);
	self.map ServiceRealWorldEffects(result);
	
	// TODO
//	securityClassificationText:=appliedStereotype.slot->select(s|s.definingFeature.name='securityClassificationText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	securityClassificationText:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceSecurityClassification').value.oclAsType(UML::InstanceValue).instance.name->asSequence()->first();
	
	self.map ServiceDependencies(result);
	self.map IEPDReferences(result);
}
query UML::InstanceSpecification::descriptionText(featureName:String):String=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::InstanceValue).instance
//		.slot->select(s|s.definingFeature.name='Description').value.oclAsType(UML::LiteralString).value->asSequence()->first();
		.realizedNamedElement().ownedComment.body->asSequence()->first();
// context is GRA Service Specification
mapping UML::InstanceSpecification::ServiceRealWorldEffects(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::ServiceRealWorldEffectsType
{
	serviceDescription.serviceRealWorldEffects:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
	realWorldEffectDescriptionText+=appliedStereotype.getTagValues('realWorldEffectDescriptionText').oclAsType(String);
	*/
	var appliedStereotype:Sequence(UML::InstanceSpecification)=self.slot->select(s|s.definingFeature.name='RealWorldEffect').value.oclAsType(UML::InstanceValue).instance->asSequence();
//	realWorldEffectDescriptionText+=appliedStereotype.realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::UseCase)).ownedComment.body;
	realWorldEffectDescriptionText+=appliedStereotype.realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::UseCase)).name;
	
}
// context is GRA Service Specification
mapping UML::InstanceSpecification::ServiceCapabilities(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::ServiceCapabilitiesType
{
	serviceDescription.serviceCapabilities:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceInterfaceSpecificationStereotype).oclAsType(Stdlib::Element);
	capabilityDescriptionText:=appliedStereotype.getTagValue('capabilityDescriptionText').oclAsType(String);
	*/
	/*
	var sspCollaboration:UML::Collaboration=self.realizedCollaboration()->first();
//	var primaryServiceParticipant:UML::Component=self.ownedAttribute
	var primaryServiceParticipant:UML::Component=sspCollaboration.ownedAttribute
		->select(a|a.aggregation=UML::AggregationKind::composite).type
		->select(t|t.isServiceIdentification()).oclAsType(UML::Component)->asSequence()->first();
	primaryServiceParticipant.realization.realizingClassifier
		->select(c|c.isStereotypeApplied(graServiceCapabilityStereotype))->forEach(capability){
		var appliedStereotype:Stdlib::Element=capability.GetStereotypeApplication(graServiceCapabilityStereotype).oclAsType(Stdlib::Element);
			capabilityDescriptionText+=appliedStereotype.getTagValue('capabilityDescriptionText').toString();
		
	};
	*/
	capabilityDescriptionText+=self.slot->select(s|s.definingFeature.name='ServiceCapabilities').value.oclAsType(UML::InstanceValue).instance
//		.slot->select(s|s.definingFeature.name='CapabilityDescriptionText').value.oclAsType(UML::LiteralString).value;
		.realizedNamedElement().ownedComment.body;
}

// context is GRA Service Specification
mapping UML::InstanceSpecification::IEPDReferences(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::IEPDReferencesType
{
	serviceDescription.iEPDReferences:=result;
	// assume indexes align and no significance to grouping
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
	var iEPDNames:Sequence(String)=appliedStereotype.getTagValues('iEPDName').oclAsType(String)	;
	var iEPDURLs:Sequence(String)=appliedStereotype.getTagValues('iEPDURL').oclAsType(String)	;
	*/
	/*
	var appliedStereotype:UML::InstanceSpecification=self;
	var iEPDNames:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='iEPDName').value.oclAsType(UML::LiteralString).value->asSequence();
	var iEPDURLs:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='iEPDURL').value.oclAsType(UML::LiteralString).value->asSequence();
	iEPDNames->forEach(iEPDName){
		iEPDName.map IEPDReference(result,iEPDURLs->at(iEPDNames->indexOf(iEPDName))); 
	};
	*/
	//self.slot->select(s|s.definingFeature.name='IEPDReference').value.oclAsType(UML::InstanceValue).instance.IEPDReference(result);
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).supplier->select(s|s.isStereotypeApplied(prompdStereotype)).oclAsType(UML::Component)->forEach(mpd){
		mpd.map IEPDReference(result);
	};
}
mapping 	UML::Component::IEPDReference(inout iEPDReferencesType:METADATA::IEPDReferencesType):METADATA::IEPDReferenceType
{
	iEPDReferencesType.iEPDReference+=result;
	var pimmpd:Stdlib::Element=self.GetStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
	var baseURI:String=pimmpd.getMpdBaseURI();
	iEPDURL+=baseURI;
	iEPDName+=baseURI.getLastSegmentGRA();
//	iEPDName+=self.name;
}
/*
//mapping 	UML::InstanceSpecification::IEPDReference(inout iEPDReferencesType:METADATA::IEPDReferencesType):METADATA::IEPDReferenceType
mapping 	UML::Component::IEPDReference(inout iEPDReferencesType:METADATA::IEPDReferencesType):METADATA::IEPDReferenceType
{
	iEPDReferencesType.iEPDReference+=result;
	Usage
	iEPDName:=self.slot->select(s|s.definingFeature.name='IEPDName').value.oclAsType(UML::LiteralString).value;
	iEPDURL:=self.slot->select(s|s.definingFeature.name='IEPDURL').value.oclAsType(UML::LiteralString).value;
}
*/
/*
mapping 	String::IEPDReference(inout iEPDReferencesType:METADATA::IEPDReferencesType,sIPVersionIn:String):METADATA::IEPDReferenceType
{
	iEPDReferencesType.iEPDReference+=result;
	iEPDName:=self;
}
*/
// context is GRA Service Specification
mapping UML::InstanceSpecification::ServiceDependencies(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::ServiceDependenciesType
{
	serviceDescription.serviceDependencies:=result;
	/*
	var sspCollaboration:UML::Collaboration=self.realizedCollaboration()->first();
	var serviceIdentifications:Sequence(UML::Component)=
		sspCollaboration.role.type->select(s|s.isServiceIdentification()).oclAsType(UML::Component)->asSequence();
	serviceDependency+=serviceIdentifications->select(s|s<>serviceIdentifications->first()).map ServiceIdentificationType();
	*/
	serviceDependency+=self.slot->select(s|s.definingFeature.name='ServiceDependency').value.oclAsType(UML::InstanceValue).instance
		.map ServiceIdentificationType();
}

// seems like this should also be in ServiceInterface via wsdl, possibly bpmn
// for now, map to ServiceInterface class
// TODO: we should be doing port on spp participant whose type is serviceInterface
// context is a ServiceInterface, a Class or Interface
//mapping UML::Classifier::ServiceInterfaceSpecification(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceInterfaceSpecificationType
mapping UML::Component::ServiceInterfaceSpecification(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceInterfaceSpecificationType
{
	serviceMetadata.serviceInterface+=result;
	//var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceInterfaceSpecificationStereotype).oclAsType(Stdlib::Element);
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	
//	securityImplementedIndicator:=appliedStereotype.getTagValue('securityImplementedIndicator').oclAsType(Boolean);
//	securityDescriptionText:=appliedStereotype.getTagValue('securityDescriptionText').oclAsType(String);
	securityImplementedIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='SecurityImplementedIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	securityDescriptionText:=appliedStereotype.slot->select(s|s.definingFeature.name='SecurityDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
	appliedStereotype.map URIDetails(result);
	self
		.ownedPort.type
		->select(s|s.isServiceInterfaceSpecification()).oclAsType(UML::Classifier)
	.map ServiceActions(result);
	appliedStereotype.map ServiceInteractionProfiles(result);
}
// context is a ServiceInterface, a Class or Interface
mapping 	UML::InstanceSpecification::ServiceInteractionProfiles(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType):METADATA::ServiceInteractionProfilesType
{
	serviceInterfaceSpecification.serviceInteractionProfiles:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceInterfaceSpecificationStereotype).oclAsType(Stdlib::Element);
	var sIPNames:Sequence(String)=appliedStereotype.getTagValues('sIPName').oclAsType(String)	;
	var sIPVersions:Sequence(String)=appliedStereotype.getTagValues('sIPVersion').oclAsType(String)	;
	*/
	/*
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	var sIPNames:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='sIPName').value.oclAsType(UML::LiteralString).value->asSequence();
	var sIPVersions:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='sIPVersion').value.oclAsType(UML::LiteralString).value->asSequence();
	*/
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='ServiceInteractionProfile').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	var sIPNames:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='SIPName').value.oclAsType(UML::LiteralString).value->asSequence();
	var sIPVersions:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='SIPVersion').value.oclAsType(UML::LiteralString).value->asSequence();
	log('ServiceInteractionProfiles '+sIPNames->size().repr()+', '+sIPVersions->size().repr());
	sIPNames->forEach(sIPName){
		sIPName.map ServiceInteractionProfile(result,sIPVersions->at(sIPNames->indexOf(sIPName))); 
	};
}
mapping 	String::ServiceInteractionProfile(inout serviceInteractionProfiles:METADATA::ServiceInteractionProfilesType,sIPVersionIn:String):METADATA::ServiceInteractionProfileType
{
	serviceInteractionProfiles.serviceInteractionProfile+=result;
	sIPName:=self;
	sIPVersion:=sIPVersionIn;
	//log('ServiceInteractionProfile '+self+', '+sIPVersionIn);
}
// context is a ServiceInterface, a Class or Interface
mapping 	UML::Classifier::ServiceActions(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType):METADATA::ServiceActionsType
{
	serviceInterfaceSpecification.serviceActions+=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceInterfaceSpecificationStereotype).oclAsType(Stdlib::Element);
	var actionNames:Sequence(String)=appliedStereotype.getTagValues('actionName').oclAsType(String)	;
	var actionPurposes:Sequence(String)=appliedStereotype.getTagValues('actionPurpose').oclAsType(String)	;
	var messageExchangePatterns:Sequence(String)=appliedStereotype.getTagValues('messageExchangePattern').oclAsType(String)	;

	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	var actionNames:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='actionName').value.oclAsType(UML::LiteralString).value->asSequence();
	var actionPurposes:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='actionPurpose').value.oclAsType(UML::LiteralString).value->asSequence();
	var messageExchangePatterns:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='messageExchangePattern').value.oclAsType(UML::LiteralString).value->asSequence();
	actionNames->forEach(actionName){
		actionName.map ServiceAction(result,actionPurposes->at(actionNames->indexOf(actionName)),
				messageExchangePatterns->at(actionNames->indexOf(actionName))); 
	};
	*/
	
	var operations:Sequence(UML::BehavioralFeature)=self.feature
		->select(f|f.oclIsKindOf(UML::BehavioralFeature)).oclAsType(UML::BehavioralFeature)->asSequence();
	if(operations->isEmpty() and self.oclIsKindOf(UML::BehavioredClassifier))then{
		operations:=self.oclAsType(UML::BehavioredClassifier).getAllImplementedInterfaces().feature
			->select(f|f.oclIsKindOf(UML::BehavioralFeature)).oclAsType(UML::BehavioralFeature)->asSequence();		
	}endif;
	operations->forEach(operation){
		var appliedStereotype:UML::InstanceSpecification=operation.realizingInstance()->first();
	//log('operation at '+operation.qualifiedName+', '+appliedStereotype.oclIsUndefined().repr());
		var actionName:String=operation.name;
		if((actionName.oclIsUndefined() or (actionName=''))and operation.oclIsKindOf(UML::Reception))then{
			actionName:=operation.oclAsType(UML::Reception).signal.name;
		}endif;
		actionName.map ServiceAction(result,operation.ownedComment.body->asSequence()->first(),
				appliedStereotype.slot->select(s|s.definingFeature.name='MessageExchangePattern').value.oclAsType(UML::InstanceValue).instance.oclAsType(UML::EnumerationLiteral).name->asSequence()->first()); 
	};
}
mapping 	String::ServiceAction(inout serviceActions:METADATA::ServiceActionsType,actionPurposeIn:String,messageExchangePatternIn:String):METADATA::ServiceActionType
{
	//log('ServiceAction  ');
	serviceActions.serviceAction+=result;
	actionName:=self;
	actionPurpose:=actionPurposeIn;
	messageExchangePattern:=messageExchangePatternIn;
}

// context is a ServiceInterface, a Class or Interface
mapping 	UML::InstanceSpecification::URIDetails(
	inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType):METADATA::URIDetailsType
{
	serviceInterfaceSpecification.uRIDetails:=result;
//	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceInterfaceSpecificationStereotype).oclAsType(Stdlib::Element);
//	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	var appliedStereotype:UML::InstanceSpecification=self;
//	var uRIAddresss:Sequence(String)=appliedStereotype.getTagValues('uRIAddress').oclAsType(String)	;
//	var uRIDescriptions:Sequence(String)=appliedStereotype.getTagValues('uRIDescription').oclAsType(String)	;
/*
	var uRIAddresss:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='uRIAddress').value.oclAsType(UML::LiteralString).value->asSequence();
	var uRIDescriptions:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='uRIDescription').value.oclAsType(UML::LiteralString).value->asSequence();
	
	uRIAddresss->forEach(uRIAddress){
		uRIAddress.map URIDetail(result,uRIDescriptions->at(uRIAddresss->indexOf(uRIAddress))); 
	};
*/	
// uriAddress, uriDescription
var uriDescription:String=appliedStereotype.slot
	->select(s|s.definingFeature.name='URIDescription').value
	.oclAsType(UML::LiteralString).value->asSequence()->first();
appliedStereotype.slot
	->select(s|s.definingFeature.name='URIAddress').value
//	.oclAsType(UML::InstanceValue).instance
	.oclAsType(UML::LiteralString).value
	.map URIDetail(result,uriDescription);
}
//mapping 	UML::InstanceSpecification::URIDetail(inout uriDetails:METADATA::URIDetailsType):METADATA::URIDetailType
mapping 	String::URIDetail(inout uriDetails:METADATA::URIDetailsType,uRIDescriptionIn:String):METADATA::URIDetailType
{
	uriDetails.uRIDetail+=result;
//	uRIAddress:=self;
//	uRIDescription:=uRIDescriptionIn;
//	uRIAddress:=self.slot->select(s|s.definingFeature.name='URIAddress').value.oclAsType(UML::LiteralString).value->asSequence()->first();
//	uRIDescription:=self.slot->select(s|s.definingFeature.name='URIDescription').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	uRIAddress:=self;
	uRIDescription:=uRIDescriptionIn;
}
/*
mapping 	String::URIDetail(inout uriDetails:METADATA::URIDetailsType,uRIDescriptionIn:String):METADATA::URIDetailType
{
	uriDetails.uRIDetail+=result;
	uRIAddress:=self;
	uRIDescription:=uRIDescriptionIn;
}
*/

mapping 	UML::Collaboration::RelatedOrganizationInformationType(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::RelatedOrganizationInformationType
{
	serviceMetadata.relatedOrganizationInformation+=result;
	/*
	self.ownedAttribute.type
		->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor).map OrganizationType(result);
	*/
	var serviceDescription:UML::InstanceSpecification=self.realizingInstance()->first();
	serviceDescription.slot->select(s|s.definingFeature.name='RelatedOrganization').value.oclAsType(UML::InstanceValue).instance.map OrganizationType(result);
		
}
//mapping 	UML::Actor::OrganizationType(inout relatedOrganization:METADATA::RelatedOrganizationInformationType):METADATA::OrganizationType
mapping 	UML::InstanceSpecification::OrganizationType(inout relatedOrganization:METADATA::RelatedOrganizationInformationType):METADATA::OrganizationType
{
	relatedOrganization.organization+=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graOrganizationStereotype).oclAsType(Stdlib::Element);
	organizationAcronym:=appliedStereotype.getTagValue('organizationAcronym').oclAsType(String);
	organizationFullAddressText:=appliedStereotype.getTagValue('organizationFullAddressText').oclAsType(String);
	organizationWebSiteURL:=appliedStereotype.getTagValue('organizationWebSiteURL').oclAsType(String);
	organizationRoleDescriptionText:=appliedStereotype.getTagValue('organizationRoleDescriptionText').oclAsType(String);
	organizationRoleDetailedDescriptionText:=appliedStereotype.getTagValue('organizationRoleDetailedDescriptionText').oclAsType(String);
	*/
//	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	var appliedStereotype:UML::InstanceSpecification=self;
	organizationAcronym:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationAcronym').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	organizationFullAddressText:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationFullAddressText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	organizationWebSiteURL:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationWebSiteURL').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	organizationRoleDescriptionText:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationRoleDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	organizationRoleDetailedDescriptionText:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationRoleDetailedDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
//	organizationName:=self.name;
//	organizationName:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationName').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	organizationName:=self.realizedComponent()->first().name;
	self.map OrganizationPointOfContact(result);	
}
//mapping 	UML::Actor::OrganizationPointOfContact(inout organization:METADATA::OrganizationType):METADATA::PersonContactInformationType
mapping 	UML::InstanceSpecification::OrganizationPointOfContact(inout organization:METADATA::OrganizationType):METADATA::PersonContactInformationType
{
	organization.organizationPointOfContact:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graOrganizationStereotype).oclAsType(Stdlib::Element);
	
	contactPersonName:=appliedStereotype.getTagValue('contactPersonName').oclAsType(String);
	contactPersonEmailID:=appliedStereotype.getTagValue('contactPersonEmailID').oclAsType(String);
	contactPersonPhoneNumberID:=appliedStereotype.getTagValue('contactPersonPhoneNumberID').oclAsType(String);
	contactPersonAddress:=appliedStereotype.getTagValue('contactPersonAddress').oclAsType(String);
	*/
//	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='OrganizationPointOfContact').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
//	contactPersonName:=appliedStereotype.slot->select(s|s.definingFeature.name='ContactPersonName').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	contactPersonName:=appliedStereotype.realizedNamedElement()->first().name;
	contactPersonEmailID:=appliedStereotype.slot->select(s|s.definingFeature.name='ContactPersonEmailID').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	contactPersonPhoneNumberID:=appliedStereotype.slot->select(s|s.definingFeature.name='ContactPersonPhoneNumberID').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	contactPersonAddress:=appliedStereotype.slot->select(s|s.definingFeature.name='ContactPersonAddress').value.oclAsType(UML::LiteralString).value->asSequence()->first();
}

//mapping UML::InstanceSpecification::ServiceIdentificationType():METADATA::ServiceIdentificationType
//mapping UML::Component::ServiceIdentificationType():METADATA::ServiceIdentificationType
mapping UML::InstanceSpecification::ServiceIdentificationType():METADATA::ServiceIdentificationType
	
{
//	serviceMetadata.serviceIdentification:=result;
//	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	var appliedStereotype:UML::InstanceSpecification=self;// ServiceIdentification
	/*
	serviceFullNameText+=self.slot->select(s|s.definingFeature.name='serviceFullNameText').value.oclAsType(UML::LiteralString).value	;
	serviceID+=self.slot->select(s|s.definingFeature.name='serviceID').value.oclAsType(UML::LiteralString).value	;
	serviceURI+=self.slot->select(s|s.definingFeature.name='serviceURI').value.oclAsType(UML::LiteralString).value	;
	serviceNameAbbreviationText+=self.slot->select(s|s.definingFeature.name='serviceNameAbbreviationText').value.oclAsType(UML::LiteralString).value	;
	*/
	// 
//	serviceFullNameText+=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceFullNameText').value.oclAsType(UML::LiteralString).value	;
	serviceFullNameText+=self.realizedCollaboration().name;
	serviceID+=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceID').value.oclAsType(UML::LiteralString).value	;
	serviceURI+=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceURI').value.oclAsType(UML::LiteralString).value	;
	serviceNameAbbreviationText+=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceNameAbbreviationText').value.oclAsType(UML::LiteralString).value	;
}


///////////////////////////////////////////iepd
//////////////////////////////////soap sample
/*
mapping 	SPPCAT::SoapSampleType::SoapSampleType(inout pimComponent:UML::Collaboration):UML::Usage
{
 //           <soap-sample href="sample/SIP/Service Interface 1/SSA-SARInformationMessage-SOAP.xml">SSA-SAR Information Message SOAP Sample</soap-sample>
	// create a package/instance for the xml; create Usage to it and include name
	var umlPackagePath:String=self.href.toRelativeSppLocation();
	var ownerPackage:UML::Package=umlPackagePath.getSppOwnerPackage(sppRootPackage);
	var fileTypePackage:UML::InstanceSpecification=null;
	/ * TODO
		var soap:SOAP::Soap=self.oclAsType(Stdlib::Element).getSoapAtRelativeURI(self.href).oclAsType(SOAP::Soap);
		log('getSoapAt '+self.href+' = '+soap.repr());
		if(not(soap.oclIsUndefined()))then{
			// and map it as soap
			fileTypePackage:=wsdl.mapAbstractSoap();
			if(fileTypePackage.oclIsUndefined())then{return null;}endif;
			ownerPackage.packagedElement+=fileTypePackage;
		}endif;
	* /	
	if((fileTypePackage=null))then{
		fileTypePackage:=new UML::InstanceSpecification();
		ownerPackage.packagedElement+=fileTypePackage;
		fileTypePackage.name:=umlPackagePath.toSppBaseName();
	}endif;
	supplier+=fileTypePackage;
	client+=pimComponent;
	name=self.value;
	pimComponent.getNearestPackage().packagedElement+=result;
}
*/
////////////////////////////////////////////wsdl
//SPPCAT::WsdlSchemaType
// create a WSDL::Definition from 
/*
mapping 	SPPCAT::WsdlSchemaType::WsdlSchemaType(inout pimComponent:UML::Collaboration):UML::Usage
{
	pimComponent.getNearestPackage().packagedElement+=result;
 //       <wsdl-schema href="schema\SIP\NotificationServiceInterface.wsdl">Notification Service Schema</wsdl-schema>
	// create a package/component Participant for the wsdl; create Usage to it and include name
	var umlPackagePath:String=self.href.toRelativeSppLocation();
	//log('WsdlSchemaType '+self.href);
	//log('WsdlSchemaType '+umlPackagePath+', '+self.href);
	var ownerPackage:UML::Package=umlPackagePath.getSppOwnerPackage(sppRootPackage);
	var fileTypePackage:UML::Component=null;
		var wsdl:WSDL::Definition=self.oclAsType(Stdlib::Element).getWsdlAtRelativeURI(self.href).oclAsType(WSDL::Definition);
		log('getWsdlAt '+self.href+' = '+wsdl.repr());
		if(not(wsdl.oclIsUndefined()))then{
			// and map it as wsdl
			fileTypePackage:=wsdl.map Definition(ownerPackage);
		}endif;
	if((fileTypePackage=null))then{
		//fileTypePackage:=self.map FileTypePackage(ownerPackage);
		fileTypePackage:=new UML::Component();
		ownerPackage.packagedElement+=fileTypePackage;
		fileTypePackage.name:=umlPackagePath.toSppBaseName();
	}endif;
	supplier+=fileTypePackage;
	client+=pimComponent;
	name=self.value;
}
*/
/*
mapping 	UML::Component::Definition(inout wsdlSchemaType:SPPCAT::WsdlSchemaType):WSDL::Definition@wsdl
{
	// TODO: use the GRAsoaml2wsdl* transforms for rest of this..................
	
	
	// create and populate the wsdl definition
	// nested components are services
	location:=self.toRelativePathName(sppCatalogUml.getNearestPackage(),false);
	targetNamespace:=self.name;
	self.elementImport.importedElement->forEach(importElement){
		// create the wsdlImport, add to definition, set relativeFilePath and namespace
		var wsdlImport:WSDL::Import=new WSDL::Import();
		eImports+=wsdlImport;
		wsdlImport.namespace:=importElement.name;
		wsdlImport.relativeFilePath:=importElement.toRelativePathName(self.getNearestPackage(),false);
		// the actual wsdl should be created via the catalog
	};
			
			// TODO: hook up schemas to mpd component
			if(not(wsdlDefinition.eTypes.oclIsUndefined()))then{
				wsdlDefinition.eTypes.getSchemas().oclAsType(XSD::XSDSchema)->forEach(schema){
					// this will be schema embedded in wsdl; need to go one more level
					schema.contents->select(content|content.oclIsKindOf(XSD::XSDImport)).oclAsType(XSD::XSDImport)->forEach(xsdImport){
						if(xsdImport.resolvedSchema.oclIsUndefined())then{
							var wsdlschema:XSD::XSDSchema=self.oclAsType(CMOF::EObject).getWsdlSchemaAtRelativeURI(xsdImport.schemaLocation).oclAsType(XSD::XSDSchema);
							if(wsdlschema.oclIsUndefined())then{
								log('wsdl schema resolved '+wsdlschema.targetNamespace);
								xsdImport.resolvedSchema:=wsdlschema;
							}else{
								log('wsdl schema not found at '+xsdImport.schemaLocation);
							}endif;
						}endif;
					
						// force resolution of imported schema, if necessary;  
						//if(xsdImport.resolvedSchema.oclIsUndefined())then{xsdImport.importSchema();}endif;
					
						//xsdImport.importSchema();
						assert error (not(xsdImport.resolvedSchema.oclIsUndefined())) with log('failed to resolve schema at '+xsdImport.schemaLocation+' from schema '+xsdImport.schema.targetNamespace+' at '+xsdImport.schema.schemaLocation);
					
						var importedSchema:XSD::XSDSchema=xsdImport.resolvedSchema;
						//var importedSchema:XSD::XSDSchema=xsdImport.getResolvedSchema();
						//var fileTypePackage:UML::Package=importedSchema.XSDSchema();
						var fileTypePackage:UML::Package=importedSchema.mapAbstractXSDSchema();
						
					};
				};
			}endif;
	// TODO: Definition specific 
	//encoding
	//location
	//qName?
	//import?
	// resolve extensibilityElements so they can be subsequently referenced 
		self.eExtensibilityElements->forEach(ee){
			switch{
				case(ee.()){
					// wsp
					// should be applied to a Constraint
					ee.mapPolicy(result);
				};
				else{
					log('ERROR: Unsupported WSDL::Definition extension '+ee.repr());
				};
			};
	};		
	// transitive closure of references from services should encompass entire wsdl
	self.packagedElement->select(c|c.oclIsKindOf(UML::Component)).map ServicePoint(result);
	
}
*/
/*
mapping UML::Component::ServicePoint(inout pimOwner:WSDL::Definition):WSDL::Service@wsdl
{
	pimOwner.eServices+=result;
	result.setServiceQnameLocaPart(self.name);
	self.ownedAttribute->select(p|p.oclIsKindOf(UML::Port)).map WsdlPort(result);
	// TODO: Service specific 
	// qName
	// undefined
}
mapping UML::Port::WsdlPort(inout pimOwner:WSDL::Service):WSDL::Port@wsdl
{
	pimOwner.ePorts+=result;
	
	name:=self.name;
	self.type.map AbstractWsdlBinding(result);
	
//	type:=self.eBinding.map AbstractWsdlBinding(pimOwner);
//	var wsdlPortInstance:Stdlib::Element=result.applyStereotype(wsdlSoapAddressStereotype);
	
		self.eExtensibilityElements->forEach(ee){
			switch{
				case(ee.oclIsKindOf(SOAP::SOAPAddress)){
					var soapAddress:SOAP::SOAPAddress=ee.oclAsType(SOAP::SOAPAddress);
					var soapAddressInstance:Stdlib::Element=wsdlPortInstance;
					soapAddressInstance.setSoapAddressLocation(soapAddress.locationURI);
					soapAddressInstance.setSoapAddressWsdlRequired(soapAddress.required);
				};
				case(ee.getExtensibilityElementQNameLocalPart()='EndpointReference'){
					var endpointReferenceInstance:Stdlib::Element=result.applyStereotype(wsdlWsaEndpointReferenceStereotype);
					// TODO
					//endpointReferenceInstance.setEndpointReferenceAddress(endpointReference.getEndpointReferenceAddress());
				};
				else{
					log('ERROR: Unsupported WSDL::Port extension '+ee.repr());
				};
			};
			};		
	
}
*/

////////////////////////////////////////////bpmn  - no hooks from catalog
////////////////////////////////////////////ebxml  - how are these referenced?


/////////////////////////////////////////////was GRAsoaml2wsdlannotations
/*
helper UML::Classifier::DefinitionWsdlAnnotation(element:WSDL::WSDLElement){
	self.wsdlAnnotation(element);
	self.getRealizedInterfaces()->forEach(interface){
		var portType:WSDL::PortType=interface.map PortType(element.getEnclosingDefinition());
		interface.wsdlAnnotation(portType);
		interface.allBehavioralFeatures()->forEach(behavioralFeature){
			var operation:WSDL::Operation=behavioralFeature.map Operation(portType,interface);
			operation.setMpoModifiable();
			
			behavioralFeature.wsdlAnnotation(operation);
			var inputParameter:UML::NamedElement=behavioralFeature.getInputParameter();
			var outputParameter:UML::NamedElement=behavioralFeature.getOutputParameter();
			if(inputParameter.oclIsUndefined())then{}else{
				var eInput:WSDL::Input=inputParameter.map Input(portType,interface);
				inputParameter.wsdlAnnotation(eInput);
			}endif;
			if(outputParameter.oclIsUndefined())then{}else{
				var eOutput:WSDL::Output=outputParameter.map Output(portType);
				outputParameter.wsdlAnnotation(eOutput);
			}endif;
			//var eFaults:=behavioralFeature.raisedException.map Fault(portType);
			
		};
	};
	return;
}
*/	
/*
//helper UML::Collaboration::ServiceDefinitionWsdlAnnotation(element:WSDL::Definition){
helper UML::Artifact::ServiceDefinitionWsdlAnnotation(element:WSDL::Definition){
	self.wsdlAnnotation(element);
	self.service()->forEach(participant){
//		var service:WSDL::Service=self.map Service(element);
		var service:WSDL::Service=participant.map Service(element);
//		self.wsdlAnnotation(service);
//		self.getRealizedInterfaces()->forEach(interface){
		participant.wsdlAnnotation(service);
		participant.port()->forEach(participantPort){
//			var port:WSDL::Port=interface.map Port(element,service,self);
			var port:WSDL::Port=participantPort.map Port(element,service,participant);
//			interface.wsdlAnnotation(port);
			participantPort.wsdlAnnotation(port);
		};
	};
	return;
}	
*/
//helper UML::Class::BindingDefinitionWsdlAnnotation(element:WSDL::Definition){
/* no longer used	
helper UML::Class::BindingDefinitionWsdlAnnotation(element:WSDL::Definition,port:UML::Port){
	var isReliability:Boolean=false;
	var isAuthentication:Boolean=false;
	self.wsdlAnnotation(element);
	//
	self.getRealizedInterfaces()->forEach(interface){
//		var binding:WSDL::Binding=interface.map Binding(self);
		var binding:WSDL::Binding=self.map Binding(port,element);
		interface.wsdlAnnotation(binding);
		
//		if(self.stereotypedBy(policyProfileAuthentication))then{
		if(self.isStereotypeApplied(policyAuthenticationStereotype))then{
			binding.eExtensibilityElements+=wspPolicyReference('#PasswordAuthenticationOverSSL');
			isAuthentication:=true;
		}else{}endif;
//		if(self.stereotypedBy(policyProfileReliability))then{
		if(self.isStereotypeApplied(policyReliabilityStereotype))then{
			binding.eExtensibilityElements+=wspPolicyReference('#ReliableMessaging');
			isReliability:=true;
		}else{}endif;
		
		var ePortType:WSDL::PortType=interface.map PortType(element);
		ePortType.eOperations->forEach(eOperation){
//			var eBindingOperation:WSDL::BindingOperation=eOperation.map BindingOperation(interface);
			var eBindingOperation:WSDL::BindingOperation=eOperation.map BindingOperation(self);
			var umlOperation:UML::BehavioralFeature=eOperation.findUmlOperation();
			eBindingOperation.setMpoModifiable();
			var eBindingInput:WSDL::BindingInput=eOperation.eInput.map BindingInput();
			var eBindingOutput:WSDL::BindingOutput=eOperation.eOutput.map BindingOutput();
			if(eBindingInput.oclIsUndefined())then{}else{
//				eBindingInput.eExtensibilityElements+=new SOAPBody(umlOperation.use(),eOperation.eInput.parts());
				new SOAPBody(umlOperation.use(),eOperation.eInput.parts(),eBindingInput);
// DEBUG temp suppress TODO: where is the failure?
				eBindingInput.setElementAttribute(wsawsNamespace,'wsaws:Action',umlOperation.soapActionURI());
			}endif;
			if(eBindingOutput.oclIsUndefined())then{}else{
//				eBindingOutput.eExtensibilityElements+=new SOAPBody(umlOperation.use(),eOperation.eOutput.parts(),eBindingOutput);
				new SOAPBody(umlOperation.use(),eOperation.eOutput.parts(),eBindingOutput);
				eBindingOutput.setElementAttribute(wsawsNamespace,'wsaws:Action',umlOperation.soapActionURI()+'Response');
			}endif;
			eOperation.eFaults->forEach(eFault){
				var eBindingFault:WSDL::BindingFault=eFault.map BindingFault();
				eBindingFault.eExtensibilityElements+=new SOAPFault(eFault.name,umlOperation.use());
			};
		};
	};
	if(isReliability)then{
		wspPolicyReliableMessaging(element); 
	}else{}endif;
	if(isAuthentication)then{
		wspPolicyAuthentication(element); 
	}else{}endif;
	
	return;
}	
*/
helper UML::Element::wsdlAnnotation(element:WSDL::WSDLElement){
/*
	// element-specific additional information
	var appinfoElement:OclAny=null;
	if(self.ownedComment->isEmpty())then{appinfoElement:=element.warning(appinfoElement,'undocumented element');}else{}endif;
	if(self.oclIsKindOf(UML::NamedElement))then{
		var prop:UML::NamedElement=self.oclAsType(UML::NamedElement);
		if(prop.name="")then{appinfoElement:=element.warning(appinfoElement,'unnamed element');}else{
			if(prop.name<>prop.getName())then{appinfoElement:=element.warning(appinfoElement,'original uml element name '+prop.name);}else{}endif;
		}endif;
	}else{}endif;
	if(self.oclIsKindOf(UML::BehavioralFeature))then{
		var bf:UML::BehavioralFeature=self.oclAsType(UML::BehavioralFeature);
		if(bf.ownedParameter->select(p|
			(p.direction=UML::ParameterDirectionKind::_in)or(p.direction=UML::ParameterDirectionKind::_inout)
			)->size()>1)then{appinfoElement:=element.warning(appinfoElement,'operation has more than 1 in parameter');}else{}endif;
		if(bf.ownedParameter->select(p|
			(p.direction=UML::ParameterDirectionKind::_out)or(p.direction=UML::ParameterDirectionKind::_inout)or(p.direction=UML::ParameterDirectionKind::_return)
			)->size()>1)then{appinfoElement:=element.warning(appinfoElement,'operation has more than 1 out parameter');}else{}endif;
	}else{}endif;
	if(element.oclIsKindOf(WSDL::Input))then{
		var prop:UML::NamedElement=self.oclAsType(UML::NamedElement);
		if(element.oclAsType(WSDL::Input).name<>prop.getName())then{appinfoElement:=element.warning(appinfoElement,'WSDL input name not unique within PortType, original name: '+prop.name);}else{}endif;
	}else{}endif;
	if(self.oclIsKindOf(UML::Parameter))then{
		var type:UML::Type=self.oclAsType(UML::Parameter).type;
		if(type.stereotypedBy(soaMLProfileMessageType))then{}else{appinfoElement:=element.warning(appinfoElement,'parameter type is not MessageType');}endif;
	}else{}endif;

	if(self.ownedComment->notEmpty())then{
		var documentationElement:OclAny=element.createDocumentationElement();
		self.ownedComment->forEach(comment){
			var userInformationElement:OclAny='documentation'.createChildElement(documentationElement);
			comment.body.setTextContent(userInformationElement);
		};
	}else{}endif;
	if(self.oclIsKindOf(UML::Classifier)and element.oclIsKindOf(WSDL::Service))then{
		// Application Information
		appinfoElement:=element.getAppinfoElement(appinfoElement);
		var umlelement:OclAny=self.createUmlElement(appinfoElement);
		self.wsdlServiceAnnotation(element,umlelement);
	}else{}endif;
	if(self.oclIsKindOf(UML::BehavioralFeature)and element.oclIsKindOf(WSDL::Operation))then{
		// Application Information
		appinfoElement:=element.getAppinfoElement(appinfoElement);
		var umlelement:OclAny=self.createUmlElement(appinfoElement);
		var serviceInterface:UML::Classifier=self.owner.oclAsType(UML::Classifier);
		self.oclAsType(UML::BehavioralFeature).wsdlOperationAnnotation(element,umlelement,serviceInterface);
	}else{}endif;
*/	
	return;
}	
/*
helper WSDL::WSDLElement::getAppinfoElement(appinfoElementIn:OclAny):OclAny{
	var appinfoElement:OclAny=appinfoElementIn;
	if(appinfoElement=null)then{
		appinfoElement:='appinfo'.createChildElement(self.createDocumentationElement());
		'source'.setAttribute(appinfoElement,umlAnnotationSource);
	}else{}endif;
	return appinfoElement;
}
helper WSDL::WSDLElement::warning(appinfoElementIn:OclAny,text:String):OclAny{
	var appinfoElement:OclAny=self.getAppinfoElement(appinfoElementIn);
	var warningElement:OclAny='warning'.createChildElement(appinfoElement);
	text.setTextValue(warningElement);
	return appinfoElement;
}
*/
helper UML::Element::wsdlServiceAnnotation(element:WSDL::WSDLElement,inout umlelement:OclAny){
/*
	var newLine:String='';
		var serviceInterface:UML::Classifier=self.oclAsType(UML::Classifier);
		var service:WSDL::Service=element.oclAsType(WSDL::Service);
			if(serviceInterface.getAllUsedInterfaces()->isEmpty())then{
					('WARNING: service has no used interfaces'+newLine).setTextValue('warning'.createChildElement(umlelement));
			}else{
				serviceInterface.getAllUsedInterfaces()->forEach(usedInterface){
					var usedInterfaceElement:OclAny='usedInterface'.createChildElement(umlelement);
					('uses interface (wsdl port) defined by '+usedInterface.qualifiedName+newLine).setTextValue(usedInterfaceElement);
					// find implementors
					var usedInterfaceImplementors:Set(UML::BehavioredClassifier)=
						uml.objectsOfType(UML::BehavioredClassifier)
						->select(e|e.getAllImplementedInterfaces()->includes(usedInterface));
					var usedServices:Set(UML::Classifier)=usedInterfaceImplementors;
					if(usedServices->isEmpty())then{usedServices:=Set{usedInterface};}else{}endif;
					usedServices->forEach(usedService){
						('defined in service  '+usedService.qualifiedName+newLine).setTextValue('usesServiceInterface'.createChildElement(usedInterfaceElement));
					};	
				};
			}endif;
			// find all ports which reference the serviceInterface
			uml.objectsOfType(UML::Port)->select(e|e.type=serviceInterface).classifier->select(c|c.oclIsKindOf(UML::Class)).oclAsType(UML::Class)->forEach(owningClass){
				//var participantElement:OclAny='participant'.createChildElement(umlelement);
				var participantElement:OclAny=owningClass.createUmlChildElement(umlelement,'implementedByParticipant',true);
				//('serviceInterface implemented by participant '+owningClass.qualifiedName+newLine).setTextValue(participantElement);
				// find architectures
				uml.objectsOfType(UML::Collaboration).role->select(e|e.type=owningClass)->forEach(collaborationRole){
					var systemArchitectureElement:OclAny='systemArchitecture'.createChildElement(participantElement);
					('participant '+owningClass.qualifiedName+' collaborates in  '+collaborationRole.oclAsType(UML::Property).owner.oclAsType(UML::NamedElement).qualifiedName+newLine).setTextValue(systemArchitectureElement);
					if(not(collaborationRole.owner.oclAsType(UML::Collaboration).collaborationRole->includes(collaborationRole)))then{
						('WARNING: participant is not a collaborationRole'+newLine).setTextValue('warning'.createChildElement(systemArchitectureElement));
					}else{}endif;
					// find contracts	
					collaborationRole.clientDependency.supplier
						->select(s|s.oclIsKindOf(UML::Property)and (s.oclAsType(UML::Property).type=serviceInterface))
						->forEach(contractProperty){
							var contract:UML::Collaboration=contractProperty.owner.oclAsType(UML::Collaboration);
							var contractElement:OclAny='contract'.createChildElement(systemArchitectureElement);
							('service contract '+contract.qualifiedName+newLine).setTextValue(contractElement);
							// get connectors
							contract.feature
								->select(c|
									c.oclIsKindOf(UML::Connector) 
									and (c.oclAsType(UML::Connector)._end.role->asSet()->includes(contractProperty.oclAsType(UML::ConnectableElement)))
									).oclAsType(UML::Connector)._end.role
								->select(r|r<>contractProperty)
								->forEach(otherContractProperty){
									var contractServiceInterfaceElement:OclAny='serviceInterface'.createChildElement(contractElement);
									('contract for serviceInterface '+otherContractProperty.type.qualifiedName+newLine).setTextValue(contractServiceInterfaceElement);
									otherContractProperty.getTargetDirectedRelationships().source
										->select(s|s.oclIsKindOf(UML::Property)).oclAsType(UML::Property).type
										->forEach(otherParticipant){
											var contractServiceInterfaceParticipantElement:OclAny='participant'.createChildElement(contractServiceInterfaceElement);
											('contract with participant '+otherParticipant.qualifiedName+newLine).setTextValue(contractServiceInterfaceParticipantElement);
										};
								};
							if(contract.classifierBehavior.oclIsUndefined())then{}else{contract.classifierBehavior.contractBehavior(contractElement,serviceInterface);}endif;	
					};
				};
				// find activityPartition
				uml.objectsOfType(UML::ActivityPartition)->select(e|e.represents=owningClass)->forEach(activityPartition){
					var activityPartitionElement:OclAny=activityPartition.createUmlChildElement(participantElement,'hasActivityPartition',false);
					'inActivity'.setAttribute(activityPartitionElement,activityPartition.inActivity.displayQualifiedName(serviceInterface));
					activityPartition.node->forEach(node){
						var nodeElement:OclAny=node.createUmlChildElement(activityPartitionElement,'hasNode',false);
						'name'.setAttribute(nodeElement,node.name);
						if(node.oclIsKindOf(UML::CallBehaviorAction))then{
							
						}else{}endif;
					};
				};
			};
			*/
	return;
}	
/*
helper UML::BehavioralFeature::wsdlOperationAnnotation(element:WSDL::WSDLElement,inout umlelement:OclAny,serviceInterface:UML::Classifier){
	// find all behavioral references to the feature
	if(self.oclIsKindOf(UML::Operation))then{
		var operation:UML::Operation=self.oclAsType(UML::Operation);
		uml.objectsOfType(UML::CallEvent)->select(e|e.operation=self)->forEach(callEvent){
			callEvent.wsdlEventAnnotation(element,umlelement,serviceInterface);
		};
		/ *
		uml.objectsOfType(UML::ReceiveOperationEvent)->select(e|e.operation=self)->forEach(callEvent){
			callEvent.wsdlEventAnnotation(element,umlelement,serviceInterface);
		};
		uml.objectsOfType(UML::SendOperationEvent)->select(e|e.operation=self)->forEach(callEvent){
			callEvent.wsdlEventAnnotation(element,umlelement,serviceInterface);
		};
		* /
	}else{
		var reception:UML::Reception=self.oclAsType(UML::Reception);
		var signal:UML::Signal=reception.signal;
		uml.objectsOfType(UML::SignalEvent)->select(e|e.signal=signal)->forEach(signalEvent){
			signalEvent.wsdlSignalEventAnnotation(element,umlelement,serviceInterface);
		};
		/ *
	
}		uml.objectsOfType(UML::SendSignalEvent)->select(e|e.signal=signal)->forEach(signalEvent){
			signalEvent.wsdlSignalEventAnnotation(element,umlelement,serviceInterface);
		};
		uml.objectsOfType(UML::ReceiveSignalEvent)->select(e|e.signal=signal)->forEach(signalEvent){
			signalEvent.wsdlSignalEventAnnotation(element,umlelement,serviceInterface);
		};
		* /
 
	}endif;
	return;
}
	
helper UML::Event::wsdlSignalEventAnnotation(element:WSDL::WSDLElement,inout umlelement:OclAny,serviceInterface:UML::Classifier){
	var eventElement:OclAny=self.createUmlChildElement(umlelement,'event',false);
	uml.objectsOfType(UML::OccurrenceSpecification)->select(s|(s.event=self)and(s.isCoveredType(serviceInterface)))->forEach(occurrence){
		var fragmentElement:OclAny=occurrence.createUmlChildElement(eventElement,'interaction',false);
		occurrence.interactionFragmentSequence(fragmentElement,serviceInterface,true);
	};
	return;
}	
helper UML::Event::wsdlEventAnnotation(element:WSDL::WSDLElement,inout umlelement:OclAny,serviceInterface:UML::Classifier){
	var eventElement:OclAny=self.createUmlChildElement(umlelement,'event',false);
	uml.objectsOfType(UML::OccurrenceSpecification)->select(s|s.event=self)->forEach(occurrence){
		var fragmentElement:OclAny=occurrence.createUmlChildElement(eventElement,'interaction',false);
		occurrence.interactionFragmentSequence(fragmentElement,serviceInterface,true);
	};
	return;
}	

helper UML::NamedElement::createUmlChildElement(inout parentElement:OclAny,label:String,includeName:Boolean):OclAny{
	var interactionElement:OclAny=label.createChildElement(parentElement);
	if(includeName)then{'qualifiedName'.setAttribute(interactionElement,self.qualifiedName);}else{}endif;
	'metaClass'.setAttribute(interactionElement,self.oclAsType(ECORE::EObject).eClass().name);
	return interactionElement;
}
helper UML::Behavior::contractBehavior(inout contractElement:OclAny,serviceInterface:UML::Classifier){
	var interactionElement:OclAny=self.createUmlChildElement(contractElement,'contractBehavior',true);
	if(self.oclIsKindOf(UML::Interaction))then{
		var interaction:UML::Interaction=self.oclAsType(UML::Interaction);
		interaction.fragment->forEach(fragment){
			var fragmentElement:OclAny=fragment.createUmlChildElement(interactionElement,'fragment',false);
			fragment.interactionFragment(fragmentElement,serviceInterface);
		};
	}else{}endif;	
	return;
}	
*/	
helper UML::NamedElement::displayQualifiedName(serviceInterface:UML::NamedElement):String{
	if(self=serviceInterface)then{return 'this';}else{}endif;
	return self.qualifiedName;
}
//helper UML::InteractionFragment::getCoveredType():UML::Type=self.covered.represents.type->asSequence()->first();
helper UML::InteractionFragment::getCoveredTypes():Set(UML::Type)=self.covered.represents.type->asSet();
helper UML::InteractionFragment::isCoveredType(type:UML::Type):Boolean=self.covered.represents.type->includes(type);
helper UML::InteractionFragment::interactionFragmentSequence(inout fragmentElement:OclAny,serviceInterface:UML::Classifier,useDelegation:Boolean){
	//  get prior and next
	if(self.enclosingInteraction.oclIsUndefined())then{
		if(self.enclosingOperand.oclIsUndefined())then{}else{
			self.fromToInteraction(self.enclosingOperand.fragment,fragmentElement,serviceInterface,useDelegation);
		}endif;
	}else{
		self.fromToInteraction(self.enclosingInteraction.fragment,fragmentElement,serviceInterface,useDelegation);
	}endif;
}	
helper UML::InteractionFragment::interactionFragment(inout fragmentElement:OclAny,serviceInterface:UML::Classifier){
	//  get prior and next
	self.interactionFragmentSequence(fragmentElement,serviceInterface,false);
	/*
	if(self.oclIsKindOf(UML::MessageOccurrenceSpecification))then{
		var sendMOS:UML::MessageOccurrenceSpecification=self.oclAsType(UML::MessageOccurrenceSpecification);
		var fromTypes:Set(UML::Type)=sendMOS.getCoveredTypes();
		fromTypes->forEach(fromType){
			var fromClassifier:String=fromType.displayQualifiedName(serviceInterface);
			var fromElement:OclAny=fromType.createUmlChildElement(fragmentElement,'from',false);
			'serviceInterface'.setAttribute(fromElement,fromClassifier);
		};
		var event:UML::Event=sendMOS.event;
		if(event.oclIsUndefined())then{}else{
			var fromEvent:String=event.oclAsType(ECORE::EObject).eClass().name;
			'event'.setAttribute(fragmentElement,fromEvent);
			if(event.oclIsKindOf(UML::CallEvent))then{
				var operation:UML::Operation=event.oclAsType(UML::CallEvent).operation;
				'operation'.setAttribute(fragmentElement,operation.owner.oclAsType(UML::NamedElement).displayQualifiedName(serviceInterface)+'::'+operation.name);
			}else{}endif;
//			if(event.oclIsKindOf(UML::SendSignalEvent))then{
//				var signal:UML::Signal=event.oclAsType(UML::SendSignalEvent).signal;
			if(event.oclIsKindOf(UML::SignalEvent))then{
				var signal:UML::Signal=event.oclAsType(UML::SignalEvent).signal;
				'signal'.setAttribute(fragmentElement,signal.displayQualifiedName(serviceInterface));
			}else{}endif;
		}endif;
	}else{}endif;
	if(self.oclIsKindOf(UML::CombinedFragment))then{
		var combinedFragment:UML::CombinedFragment=self.oclAsType(UML::CombinedFragment);
		combinedFragment.operand->forEach(operand){
			var operandElement:OclAny=operand.createUmlChildElement(fragmentElement,'operand',false);
			operand.interactionFragment(operandElement,serviceInterface);
		};
	}else{}endif;	
	if(self.oclIsKindOf(UML::InteractionOperand))then{
		var interactionOperandFragment:UML::InteractionOperand=self.oclAsType(UML::InteractionOperand);
		interactionOperandFragment.fragment->forEach(fragment){
			var operandfragmentElement:OclAny=fragment.createUmlChildElement(fragmentElement,'fragment',false);
			fragment.interactionFragment(operandfragmentElement,serviceInterface);
		};
	}else{}endif;	
	if(self.oclIsKindOf(UML::ExecutionSpecification))then{
		var executionSpecification:UML::ExecutionSpecification=self.oclAsType(UML::ExecutionSpecification);
		var start:UML::OccurrenceSpecification=executionSpecification.start;
		var finish:UML::OccurrenceSpecification=executionSpecification.finish;
		
		if(start.oclIsUndefined())then{}else{
			var fromTypes:Set(UML::Type)=start.getCoveredTypes();
			fromTypes->forEach(fromType){
				var fromClassifier:String=fromType.displayQualifiedName(serviceInterface);
				var fromElement:OclAny=fromType.createUmlChildElement(fragmentElement,'start',false);
				'serviceInterface'.setAttribute(fromElement,fromClassifier);
			};
		}endif;

		if(finish.oclIsUndefined())then{}else{
			var fromTypes:Set(UML::Type)=finish.getCoveredTypes();
			fromTypes->forEach(fromType){
				var fromClassifier:String=fromType.displayQualifiedName(serviceInterface);
				var fromElement:OclAny=fromType.createUmlChildElement(fragmentElement,'finish',false);
				'serviceInterface'.setAttribute(fromElement,fromClassifier);
			};
		}endif;

	}else{}endif;	
	*/	
	return;
}	
helper UML::InteractionFragment::getFromFragment(fragmentsIn:OrderedSet(UML::InteractionFragment),
	serviceInterface:UML::Classifier,useDelegation:Boolean):UML::InteractionFragment{
	var fragments:OrderedSet(UML::InteractionFragment)=fragmentsIn;
	if(useDelegation)then{
		fragments:=fragmentsIn->select(f|f.oclIsKindOf(UML::MessageOccurrenceSpecification));
	}else{}endif;
	var myIndex:Integer=fragments->indexOf(self);
	if(myIndex>1)then{
		var fromFragment:UML::InteractionFragment=fragments->at(myIndex-1);
		/*
		if(useDelegation and (fromFragment.isCoveredType(serviceInterface)))then{
			var fromPriorFragment:UML::InteractionFragment=fromFragment.getFromFragment(fragments,serviceInterface,useDelegation);
			if(fromPriorFragment=null)then{}else{return fromPriorFragment;}endif;
		}else{}endif;
		*/
		return fromFragment;
	}else{}endif;
	return null;
}	
query UML::InteractionFragment::isCombinedMOS():Boolean=
	self.oclIsKindOf(UML::MessageOccurrenceSpecification)or self.oclIsKindOf(UML::CombinedFragment);
query UML::CombinedFragment::getNestedMessageOccurrenceSpecifications(serviceInterface:UML::Classifier):Set(UML::MessageOccurrenceSpecification){
	var operands:Set(UML::InteractionOperand)=self.operand
		->select(o|o.fragment->select(f|f.isCombinedMOS())->first().isCoveredType(serviceInterface))
		->select(o|o.fragment->select(f|f.isCombinedMOS())->size()>1 or o.fragment->select(f|f.oclIsKindOf(UML::CombinedFragment))->notEmpty());
	var fragments:Set(UML::InteractionFragment)=operands
		->collect(o|
			if(o.fragment->first().oclIsKindOf(UML::CombinedFragment))
			then o.fragment->first()
			else o.fragment->select(f|f.isCombinedMOS())->at(2)
			endif
			)
		->asSet();	
	return fragments
				->collect(f|
					if(f.oclIsKindOf(UML::MessageOccurrenceSpecification))
					then Set{f.oclAsType(UML::MessageOccurrenceSpecification)}
					else f.oclAsType(UML::CombinedFragment).getNestedMessageOccurrenceSpecifications(serviceInterface)
					endif
				)	
		->asSet();
}
helper UML::InteractionFragment::getToFragments(fragmentsIn:OrderedSet(UML::InteractionFragment),
	serviceInterface:UML::Classifier,useDelegation:Boolean):Set(UML::InteractionFragment){
	var fragments:OrderedSet(UML::InteractionFragment)=fragmentsIn;
	if(useDelegation)then{
		fragments:=fragmentsIn->select(f|f.isCombinedMOS());
	}else{}endif;
	var myIndex:Integer=fragments->indexOf(self);
	if(myIndex<fragments->size())then{
		var toFragment:UML::InteractionFragment=fragments->at(myIndex+1);
		/*
		if(useDelegation and (toFragment.isCoveredType(serviceInterface)))then{
			var toPriorFragment:UML::InteractionFragment=toFragment.getToFragment(fragments,serviceInterface,useDelegation);
			if(toPriorFragment=null)then{}else{return toPriorFragment;}endif;
		}else{}endif;
		*/
		if(useDelegation and (toFragment.oclIsKindOf(UML::CombinedFragment)))then{
			return toFragment.oclAsType(UML::CombinedFragment).getNestedMessageOccurrenceSpecifications(serviceInterface);
		}else{}endif;
		return OrderedSet{toFragment};
	}else{}endif;
	return null;
}	
helper UML::InteractionFragment::fromToInteraction(fragments:OrderedSet(UML::InteractionFragment),
	inout fragmentElement:OclAny,serviceInterface:UML::Classifier,useDelegation:Boolean){
	if(fragments->includes(self))then{}else{return;}endif;
	/*
	var fromFragment:UML::InteractionFragment=self.getFromFragment(fragments,serviceInterface,useDelegation);
	var toFragments:Set(UML::InteractionFragment)=self.getToFragments(fragments,serviceInterface,useDelegation);
	if(fromFragment<>null)then{
		//var fromType:UML::Type=fromFragment.getCoveredType();
		//'from'.setAttribute(fragmentElement,fromType.displayQualifiedName(serviceInterface));
		var fromTypes:Set(UML::Type)=fromFragment.getCoveredTypes();
		fromTypes->forEach(fromType){
			var fromClassifier:String=fromType.displayQualifiedName(serviceInterface);
			var fromElement:OclAny=fromType.createUmlChildElement(fragmentElement,'from',false);
			'serviceInterface'.setAttribute(fromElement,fromClassifier);
		};
	}else{}endif;
	toFragments->forEach(toFragment){
		var toElement:OclAny=toFragment.createUmlChildElement(fragmentElement,'to',false);
		//var fromType:UML::Type=toFragment.getCoveredType();
		//'to'.setAttribute(fragmentElement,fromType.displayQualifiedName(serviceInterface));
		var toTypes:Set(UML::Type)=toFragment.getCoveredTypes();
		toTypes->forEach(fromType){
			var fromClassifier:String=fromType.displayQualifiedName(serviceInterface);
			var fromElement:OclAny=fromType.createUmlChildElement(toElement,'type',false);
			'serviceInterface'.setAttribute(fromElement,fromClassifier);
		};
		if(toFragment.enclosingOperand.oclIsUndefined())then{}else{
			if(toFragment.enclosingOperand.guard.oclIsUndefined())then{}else{
				if(toFragment.enclosingOperand.guard.specification.oclIsUndefined())then{}else{
					'guard'.setAttribute(toElement,toFragment.enclosingOperand.guard.specification.stringValue());
				}endif;
			}endif;
		}endif;
		if(toFragment.oclIsKindOf(UML::OccurrenceSpecification)
			and not(toFragment.oclAsType(UML::OccurrenceSpecification).event.oclIsUndefined()))then{
			var event:UML::Event=toFragment.oclAsType(UML::OccurrenceSpecification).event;
			'toEventMetaClass'.setAttribute(toElement,event.oclAsType(ECORE::EObject).eClass().name);
			if(event.oclIsKindOf(UML::CallEvent))then{
				'toOperation'.setAttribute(toElement,event.oclAsType(UML::CallEvent).operation.name);
			}else{}endif;
			if(event.oclIsKindOf(UML::ReceiveOperationEvent))then{
				'toOperation'.setAttribute(toElement,event.oclAsType(UML::ReceiveOperationEvent).operation.name);
			}else{}endif;
			if(event.oclIsKindOf(UML::SendOperationEvent))then{
				'toOperation'.setAttribute(toElement,event.oclAsType(UML::SendOperationEvent).operation.name);
			}else{}endif;
			if(event.oclIsKindOf(UML::SignalEvent))then{
				'toSignal'.setAttribute(toElement,event.oclAsType(UML::SignalEvent).signal.qualifiedName);
			}else{}endif;
			if(event.oclIsKindOf(UML::SendSignalEvent))then{
				'toSignal'.setAttribute(toElement,event.oclAsType(UML::SendSignalEvent).signal.qualifiedName);
			}else{}endif;
			if(event.oclIsKindOf(UML::ReceiveSignalEvent))then{
				'toSignal'.setAttribute(toElement,event.oclAsType(UML::ReceiveSignalEvent).signal.qualifiedName);
			}else{}endif;
		}else{}endif;
	};
	*/
	return;
}	
////////////////////////////////////////////was GRAsoaml2wsdl

property wsdlNamespace:String='http://schemas.xmlsoap.org/wsdl/';
property soapNamespace:String='http://schemas.xmlsoap.org/wsdl/soap/';
property soapPrefix:String='soap';
property wsawsNamespace:String='http://www.w3.org/2006/05/addressing/wsdl';
property wsawsPrefix:String='wsaws';
property wspNamespace:String='http://schemas.xmlsoap.org/ws/2004/09/policy';
property wspPrefix:String='wsp';
property wsuNamespace:String='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd';
property wsuPrefix:String='wsu';
property wsrmNamespace:String='http://schemas.xmlsoap.org/ws/2005/02/rm/policy';
property wsrmPrefix:String='wsrm';
property spNamespace:String='http://schemas.xmlsoap.org/ws/2005/07/securitypolicy';
property spPrefix:String='sp';

property templateNamespace:String='http://gra.ijis.org/template';
property templatePrefix:String='template';
//property mpoNamespace:String='http://modelDriven.org/schema/modelPro/override';
//property mpoPrefix:String='mpo';
////////////////////abstract methods
//abstract helper UML::Collaboration::ServiceDefinitionWsdlAnnotation(element:WSDL::Definition);
//abstract helper UML::Artifact::ServiceDefinitionWsdlAnnotation(element:WSDL::Definition);
//abstract helper UML::Class::BindingDefinitionWsdlAnnotation(element:WSDL::Definition,port:UML::Port);
//abstract helper UML::Classifier::DefinitionWsdlAnnotation(element:WSDL::WSDLElement);

//abstract helper UML::Class::JavaService();
///////////////////////////////queries and helpers
query WSDL::Input::parts():String="request";
query WSDL::Output::parts():String="response";
query WSDL::WSDLElement::getContainer():WSDL::WSDLElement=self.oclAsType(CMOF::EObject).eContainer().oclAsType(WSDL::WSDLElement);

query WSDL::Operation::findUmlOperation(context:UML::Classifier):UML::BehavioralFeature{
	//return self.allBehavioralFeatures()->select(f|(f.map Operation())=wsdlOperation)->first();
//	return wsdlOperation.invresolveoneIn(BindingOperation);
//	return wsdlOperation.invresolveoneIn(UML::BehavioralFeature::Operation);
//	return self.invresolveone(UML::BehavioralFeature);
	var ifcOperation:UML::BehavioralFeature=self.invresolveone(UML::BehavioralFeature);
	if(context.oclIsKindOf(UML::Interface))then{return ifcOperation;}endif;
	if(context.oclIsKindOf(UML::Class))then{
		context.oclAsType(UML::Class).ownedOperation->select(o|o.name=ifcOperation.name)->forEach(bindingOperation){
			ifcOperation:=bindingOperation;
		};
	}endif;
	// find operation in Class
	return ifcOperation;
//	return self.invresolveone(UML::Operation);
}
/*
helper WSDL::WSDLElement::setMpoModifiable(){
	//  provide some indicator as to whether or not this segment is modifiable
	self.setElementAttribute(mpoNamespace,'mpo:modifiable','');
}
*/
////////////////////////////extensions
constructor SOAP::SOAPAddress::SOAPAddress(locationURIin:String){
	locationURI:=locationURIin;
}

constructor SOAP::SOAPFault::SOAPFault(nameIn:String,useIn:String){
	name:=nameIn;
	use:=useIn;
}

constructor SOAP::SOAPBinding::SOAPBinding(transportURIin:String,stylein:String){
	transportURI:=transportURIin;
	style:=stylein;
}
constructor SOAP::SOAPBody::SOAPBody(useIn:String,partsIn:String,inout eBinding:WSDL::ExtensibleElement){
	use:=useIn;
	eBinding.eExtensibilityElements+=result;
	// defer this until containment setup?
	result.setElementAttribute('parts',partsIn);

}
constructor SOAP::SOAPOperation::SOAPOperation(soapActionIn:String,stylein:String){
	soapActionURI:=soapActionIn;
	style:=stylein;
}

constructor WSDL::UnknownExtensibilityElement::UnknownExtensibilityElement(namespace:String,name:String){
	result.setElementType(namespace,name);
}
constructor WSDL::Namespace::Namespace(uriIn:String,prefixIn:String){
	URI:=uriIn;
	prefix:=prefixIn;
}
/*	
helper wsawsUsingAddressing(inout extensibleElement:WSDL::ExtensibleElement):WSDL::UnknownExtensibilityElement{
	var wsawsUsingAddressing:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wsawsNamespace,'UsingAddressing');
	extensibleElement.eExtensibilityElements+=wsawsUsingAddressing;
	
	wsawsUsingAddressing.setElementAttribute(wsdlNamespace,'wsdl:required','true');
	return wsawsUsingAddressing;
}
*/
helper wsrmRMAssertion():WSDL::UnknownExtensibilityElement{
	var wsrmRMAssertion:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wsrmNamespace,'RMAssertion');
	return wsrmRMAssertion;
}

/*
	
helper wspPolicyReference(uri:String):WSDL::UnknownExtensibilityElement{
	var wspPolicyReference:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'PolicyReference');
	wspPolicyReference.setElementAttribute('URI',uri);
	return wspPolicyReference;
}
helper wspPolicyReliableMessaging(inout element:WSDL::ExtensibleElement){
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	element.eExtensibilityElements+=wspPolicy;
	wspPolicy.setElementAttribute(wsuNamespace,'wsu:Id','ReliableMessaging');
	var wspExactlyOne:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'ExactlyOne');
	wspPolicy.children+=wspExactlyOne;
	var wspEAll:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'All');
	wspExactlyOne.children+=wspEAll;
	wspEAll.children+=wsawsUsingAddressing();
	wspEAll.children+=wsrmRMAssertion();
	return;
}
helper wspPolicyAuthentication(inout element:WSDL::ExtensibleElement){
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	element.eExtensibilityElements+=wspPolicy;
	wspPolicy.setElementAttribute(wsuNamespace,'wsu:Id','PasswordAuthenticationOverSSL');
	var wspExactlyOne:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'ExactlyOne');
	wspPolicy.children+=wspExactlyOne;
	var wspEAll:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'All');
	wspExactlyOne.children+=wspEAll;
	spSymmetricBinding(wspEAll);
	spWss11(wspEAll);
	spTrust10(wspEAll);
	return;
}
helper spWss11(inout element:WSDL::UnknownExtensibilityElement){
	var spWss11:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Wss11');
	element.children+=spWss11;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spWss11.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefKeyIdentifier');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefIssuerSerial');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefThumbprint');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefEncryptedKey');
	return;
}
helper spTrust10(inout element:WSDL::UnknownExtensibilityElement){
	var spTrust10:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Trust10');
	element.children+=spTrust10;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spTrust10.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireClientEntropy');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireServerEntropy');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportIssuedTokens');
	return;
}
helper spLayout(inout element:WSDL::UnknownExtensibilityElement,layoutPolicy:String){
	var spLayout:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Layout');
	element.children+=spLayout;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spLayout.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,layoutPolicy);
	return;
}
helper spAlgorithmSuite(inout element:WSDL::UnknownExtensibilityElement){
	var spAlgorithmSuite:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'AlgorithmSuite');
	element.children+=spAlgorithmSuite;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spAlgorithmSuite.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'Basic128');
	return;
}
helper spSymmetricBinding(inout element:WSDL::UnknownExtensibilityElement){
	var spSymmetricBinding:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SymmetricBinding');
	element.children+=spSymmetricBinding;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spSymmetricBinding.children+=wspPolicy;
	spProtectionToken(wspPolicy);
	spLayout(wspPolicy,'Strict');
	spAlgorithmSuite(wspPolicy);
	return;
}
helper spProtectionToken(inout element:WSDL::UnknownExtensibilityElement){
	var spProtectionToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'ProtectionToken');
	element.children+=spProtectionToken;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spProtectionToken.children+=wspPolicy;
	spSecureConversationToken(wspPolicy);
	return;
}
helper spSecureConversationToken(inout element:WSDL::UnknownExtensibilityElement){
	var spSecureConversationToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SecureConversationToken');
	element.children+=spSecureConversationToken;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spSecureConversationToken.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireDerivedKeys');
	spBootstrapPolicy(wspPolicy);
	return;
}
helper spBootstrapPolicy(inout element:WSDL::UnknownExtensibilityElement){
	var spBootstrapPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'BootstrapPolicy');
	element.children+=spBootstrapPolicy;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spBootstrapPolicy.children+=wspPolicy;
	spTransportBinding(wspPolicy);
	spSignedSupportingTokens(wspPolicy);
	spWss10(wspPolicy);
	var encryptedParts:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'EncryptedParts');
	wspPolicy.children+=encryptedParts;
	encryptedParts.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'Body');
	var signedParts:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SignedParts');
	wspPolicy.children+=signedParts;
	signedParts.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'Body');
	spHeader(signedParts,'To','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'From','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'FaultTo','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'ReplyTo','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'MessageID','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'RelatesTo','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'Action','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'AckRequested','http://schemas.xmlsoap.org/ws/2005/02/rm');
	spHeader(signedParts,'SequenceAcknowledgement','http://schemas.xmlsoap.org/ws/2005/02/rm');
	spHeader(signedParts,'Sequence','http://schemas.xmlsoap.org/ws/2005/02/rm');
	return;
}
helper spHeader(inout element:WSDL::UnknownExtensibilityElement,name:String,namespace:String){
	var spHeader:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Header');
	element.children+=spHeader;
	spHeader.setElementAttribute('Name',name);
	spHeader.setElementAttribute('Namespace',namespace);
	return;
}
helper spWss10(inout element:WSDL::UnknownExtensibilityElement){
	var spWss10:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Wss10');
	element.children+=spWss10;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spWss10.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefKeyIdentifier');
	return;
}
helper spSignedSupportingTokens(inout element:WSDL::UnknownExtensibilityElement){
	var spSignedSupportingTokens:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SignedSupportingTokens');
	element.children+=spSignedSupportingTokens;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spSignedSupportingTokens.children+=wspPolicy;
	spUsernameToken(wspPolicy);
	return;
}
helper spUsernameToken(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SignedSupportingTokens');
	element.children+=spUsernameToken;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spUsernameToken.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'WssUsernameToken10');
	return;
}
helper spTransportBinding(inout element:WSDL::UnknownExtensibilityElement){
	var spTransportBinding:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'TransportBinding');
	element.children+=spTransportBinding;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spTransportBinding.children+=wspPolicy;
	spTransportToken(wspPolicy);
	spLayout(wspPolicy,'Lax');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'IncludeTimestamp');
	spAlgorithmSuite(wspPolicy);
	return;
}
helper spTransportToken(inout element:WSDL::UnknownExtensibilityElement){
	var spTransportToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'TransportToken');
	element.children+=spTransportToken;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spTransportToken.children+=wspPolicy;
	spHttpsToken(wspPolicy);
	return;
}
helper spHttpsToken(inout element:WSDL::UnknownExtensibilityElement){
	var spHttpsToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'HttpsToken');
	element.children+=spHttpsToken;
	spHttpsToken.setElementAttribute('spHttpsToken','false');
	return;
}
*/	        
//////////////////////////////////////////////////////////////////////////////////////////wsdl leaf mapping
// possible mapping:
//		<<Participant>> is Definition
//		port.type (ServiceInterface) is Service
//		<<ServiceInterface>> is service  
//		realized interface is service port
//			service port-->1 binding
//			binding-->1 portType
//		Interface is portType 


//      architecture-->* participant-->*port-->1 serviceInterface -->(1?)interface
//		definition  -->* service    -->*port -->1 binding         -->1 portType
//
helper UML::InstanceSpecification::mapUnknown(inout element:WSDL::ExtensibleElement,modelElement:UML::NamedElement):WSDL::UnknownExtensibilityElement@wsdl{
	//log('mapUnknown '+self.qualifiedName);
	var classifier:UML::Classifier=self.classifier->asSequence()->first();
	var niemSchema:UML::Package=classifier.getNearestNIEMSchemaPackage();
    var pimStereotypeInstance:Stdlib::Element=niemSchema.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=niemSchema.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
    var targetNamespace:String=pimStereotypeInstance.getSchemaTargetNamespace();
    var defaultPrefix:String=pimStereotypeInstance.getSchemaDefaultPrefix();
    
    // test
//    targetNamespace:=templateNamespace;
//    defaultPrefix:=templatePrefix;
//	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(templateNamespace,classifier.name);
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(targetNamespace,classifier.name);
	element.eExtensibilityElements+=wspPolicy;
	var Id:String=self.name;
	if(not(Id.oclIsUndefined()) and (Id<>''))then{
		wspPolicy.setElementAttribute(wsuNamespace,'wsu:Id',Id);
	}endif;
//	wspPolicy.updateElement();	
	element.updateElement();	
	self.slot->select(s|s.definingFeature.type.oclIsKindOf(UML::Classifier))->forEach(slot){
		slot.value->forEach(value){
			// for each value, an element whose name is based on definingFeature.type, with an attribute for value 
//			var unknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(templateNamespace,slot.definingFeature.type.name);
//			var unknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(templateNamespace,slot.definingFeature.name);
//			wspPolicy.children+=unknownElement;
//			var elementName=defaultPrefix+':'+slot.definingFeature.name;
			var elementName:String=slot.definingFeature.name;
			var unknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(targetNamespace,elementName);
			wspPolicy.children+=unknownElement;
			switch{
				case(value.oclIsKindOf(UML::InstanceValue) and value.oclAsType(UML::InstanceValue).instance.oclIsKindOf(UML::EnumerationLiteral)){
					var stringValue:String=value.oclAsType(UML::InstanceValue).instance.oclAsType(UML::EnumerationLiteral).name;
					unknownElement.setElementValue(stringValue);
				};
				case(value.oclIsKindOf(UML::InstanceValue)){
					value.oclAsType(UML::InstanceValue).instance.mapUnknownExtinsibility(unknownElement);
				};
				case(value.oclIsKindOf(UML::LiteralString)){
					var stringValue:String=value.oclAsType(UML::LiteralString).value;
					unknownElement.setElementValue(stringValue);
				};
				case(value.oclIsKindOf(UML::LiteralBoolean)){
					var stringValue:String=value.oclAsType(UML::LiteralBoolean).value.toString();
					unknownElement.setElementValue(stringValue);
				};
				case(value.oclIsKindOf(UML::LiteralInteger)){
					var stringValue:String=value.oclAsType(UML::LiteralInteger).value.toString();
					unknownElement.setElementValue(stringValue);
				};
				case(value.oclIsKindOf(UML::LiteralReal)){
					var stringValue:String=value.oclAsType(UML::LiteralReal).value.toString();
					unknownElement.setElementValue(stringValue);
				};
				case(value.oclIsKindOf(UML::LiteralUnlimitedNatural)){
					var stringValue:String=value.oclAsType(UML::LiteralUnlimitedNatural).value.toString();
					unknownElement.setElementValue(stringValue);
				};
 				else{
					var stringValue:String=value.repr();
					unknownElement.setElementValue(stringValue);
				};
			};
		};
	};	
	self.mapUnknownImplicit(wspPolicy,classifier,targetNamespace);			
	return wspPolicy;
}
property annotationModelNamespace:String='http://ijis.org/GRA/Annotations';
helper UML::InstanceSpecification::mapUnknownModelReference(inout wspPolicy:WSDL::UnknownExtensibilityElement,
	targetNamespace:String,modelelementName:String,modelElement:UML::NamedElement){
		// implicit GRAServiceAnnotationBase properties
			var annotationNameUnknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,'Name');
			wspPolicy.children+=annotationNameUnknownElement;
			annotationNameUnknownElement.setElementValue(self.name);
//			modelchildunknownElement.setElementValue(modelElement.name);
			self.ownedComment.body->forEach(body){
				var annotationDocumentationUnknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,'Documentation');
				wspPolicy.children+=annotationDocumentationUnknownElement;
				annotationDocumentationUnknownElement.setElementValue(body);
			};
		
		// add modelReference
		//	var modelelementName:String='ModelReference';
			var modelunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(targetNamespace,modelelementName);
			wspPolicy.children+=modelunknownElement;
			var modelchildunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(targetNamespace,'Name');
			modelunknownElement.children+=modelchildunknownElement;
			modelchildunknownElement.setElementValue(modelElement.qualifiedName);
//			modelchildunknownElement.setElementValue(modelElement.name);
			modelElement.ownedComment.body->forEach(body){
				modelchildunknownElement:=new WSDL::UnknownExtensibilityElement(targetNamespace,'Documentation');
				modelunknownElement.children+=modelchildunknownElement;
				modelchildunknownElement.setElementValue(body);
			};
				modelchildunknownElement:=new WSDL::UnknownExtensibilityElement(targetNamespace,'ElementID');
				modelunknownElement.children+=modelchildunknownElement;
				modelchildunknownElement.setElementValue(modelElement.oclAsType(CMOF::EObject).getURIFragment());
			// no diagramLink	
			// Model
				modelchildunknownElement:=new WSDL::UnknownExtensibilityElement(targetNamespace,'Model');
				modelunknownElement.children+=modelchildunknownElement;
				
				var modelchildchildunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(targetNamespace,'ModelURI');
				modelchildunknownElement.children+=modelchildchildunknownElement;
				modelchildchildunknownElement.setElementValue(modelElement.oclAsType(CMOF::EObject).getURI());
				modelchildchildunknownElement:=new WSDL::UnknownExtensibilityElement(targetNamespace,'label');
				modelchildunknownElement.children+=modelchildchildunknownElement;
				modelchildchildunknownElement.setElementValue(modelElement.oclAsType(CMOF::EObject).contextURI());
}
helper UML::InstanceSpecification::mapUnknownImplicit(inout wspPolicy:WSDL::UnknownExtensibilityElement,
	classifier:UML::Classifier,targetNamespace:String){
	// model element references	
	self.clientRealization().supplier->forEach(modelElement){
		classifier.allParents()->select(p|p.name='GRAServiceAnnotationBase')->forEach(base){
		// add modelReference
				var modelelementName:String='ModelReference';
				self.mapUnknownModelReference(wspPolicy,annotationModelNamespace,modelelementName,modelElement);
		};
	};
	// for ServiceDescription, add IEPDReferences with IEPDName, IEPDURL
	if(classifier.name='ServiceDescription')then{
			self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).supplier
				->select(s|s.isStereotypeApplied(prompdStereotype)).oclAsType(UML::Component)->forEach(mpd){
					var pimmpd:Stdlib::Element=mpd.GetStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
					var baseURI:String=pimmpd.getMpdBaseURI();
					var iEPDURL:String=baseURI;
					var iEPDName:String=baseURI.getLastSegmentGRA();

				var iepdrelementName:String='IEPDReference';
				var iepdrunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,iepdrelementName);
				wspPolicy.children+=iepdrunknownElement;
				var iepdrnameunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,'IEPDName');
				var iepdrurlunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,'IEPDURL');
				iepdrunknownElement.children+=iepdrnameunknownElement;
				iepdrunknownElement.children+=iepdrurlunknownElement;
				iepdrnameunknownElement.setElementValue(iEPDName);
				iepdrurlunknownElement.setElementValue(iEPDURL);
			};
			// add ExchangePartner (Participant) and its Documentation
			var serviceCollaboration:UML::Collaboration=self.realizedCollaboration()->first();
			serviceCollaboration.role
				->select(r|r.oclIsKindOf(UML::Property) and r.oclAsType(UML::Property).isComposite).type
				->select(s|s.oclIsKindOf(UML::Component)).ownedComment.body->forEach(body){
				var iepdrunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,'ExchangePartner');
				wspPolicy.children+=iepdrunknownElement;
				var documentationunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,'Documentation');
				iepdrunknownElement.children+=documentationunknownElement;
				documentationunknownElement.setElementValue(body);
				};
			
		
	}endif;				
	// for Operation, implicit ActionName, ActionPurpose
	if((classifier.name='Operation') or (classifier.name='WSDLOperation'))then{
			self.clientDependency->select(d|d.oclIsKindOf(UML::Realization)).supplier
				->select(s|s.oclIsKindOf(UML::Operation)).oclAsType(UML::Operation)->forEach(operation){
				var nameelementName:String='ActionName';
				var purposeelementName:String='ActionPurpose';
				var nameunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(targetNamespace,nameelementName);
				var purposeunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(targetNamespace,purposeelementName);
				wspPolicy.children+=nameunknownElement;
				wspPolicy.children+=purposeunknownElement;
				nameunknownElement.setElementValue(operation.name);
				purposeunknownElement.setElementValue(operation.ownedComment.body->asSequence()->first());
			};
		
	}endif;
	// for Message, implicit type
	if((classifier.name='Message') or (classifier.name='WSDLMessage'))then{
			self.clientDependency->select(d|d.oclIsKindOf(UML::Realization)).supplier
				->select(s|s.oclIsKindOf(UML::Parameter)).oclAsType(UML::Parameter)->forEach(parameter){
				var modelelementName:String='type';
				self.mapUnknownModelReference(wspPolicy,targetNamespace,modelelementName,parameter.type);
			};
		
	}endif;
	// for UseCase, implicit RealWorldEffectDescriptionText
	if(classifier.name='UseCase')then{
			self.realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::UseCase)).name->forEach(useCaseName){
				var nameelementName:String='RealWorldEffectDescriptionText';
				var nameunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(targetNamespace,nameelementName);
				wspPolicy.children+=nameunknownElement;
				nameunknownElement.setElementValue(useCaseName);
			};
		
	}endif;
	// for SecurityClassification, SecurityClassificationText
	if(classifier.name='SecurityClassification')then{
			var nameunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,'SecurityClassificationText');
			wspPolicy.children+=nameunknownElement;
			nameunknownElement.setElementValue(self.name);
	}endif;
	// for ServiceCapability, CapabilityDescriptionText
	if(classifier.name='SecurityClassification')then{
			var nameunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,'CapabilityDescriptionText');
			wspPolicy.children+=nameunknownElement;
			nameunknownElement.setElementValue(self.ownedComment.body->asSequence()->first());
	}endif;
	// for Description, Description
	if(classifier.name='Description')then{
			var nameunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,'Description');
			wspPolicy.children+=nameunknownElement;
			nameunknownElement.setElementValue(self.ownedComment.body->asSequence()->first());
	}endif;
	// for Agreement, AgreementDescriptionText
	if(classifier.name='Description')then{
			var nameunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(annotationModelNamespace,'AgreementDescriptionText');
			wspPolicy.children+=nameunknownElement;
			nameunknownElement.setElementValue(self.ownedComment.body->asSequence()->first());
	}endif;
	return;				
 }
helper UML::InstanceSpecification::mapUnknownExtinsibility(inout wspPolicy:WSDL::UnknownExtensibilityElement){
	//log('mapUnknownExtensibility '+self.qualifiedName);
	var classifier:UML::Classifier=self.classifier->asSequence()->first();
	var niemSchema:UML::Package=classifier.getNearestNIEMSchemaPackage();
    var pimStereotypeInstance:Stdlib::Element=niemSchema.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=niemSchema.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
    var targetNamespace:String=pimStereotypeInstance.getSchemaTargetNamespace();
    var defaultPrefix:String=pimStereotypeInstance.getSchemaDefaultPrefix();
    // test
//    targetNamespace:=templateNamespace;
//    defaultPrefix:=templatePrefix;
	/*
	if(self.oclIsKindOf(UML::EnumerationLiteral))then{
				var stringValue:String=self.oclAsType(UML::EnumerationLiteral).name;
				unknownElement.setElementAttribute(templateNamespace,'template:value',stringValue);
		
	}else{
		*/
		self.slot->select(s|s.definingFeature.type.oclIsKindOf(UML::Classifier))->forEach(slot){
			slot.value->forEach(value){
			// for each value, an element whose name is based on definingFeature.type, with an attribute for value 
//			var unknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(templateNamespace,slot.definingFeature.type.name);
//			var unknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(templateNamespace,slot.definingFeature.name);
//			wspPolicy.children+=unknownElement;
//			var elementName=defaultPrefix+':'+slot.definingFeature.name;
			var elementName=slot.definingFeature.name;
//log('UnknownExtensibilityElement namespace='+targetNamespace+', '+elementName)	;		
			var unknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(targetNamespace,elementName);
			wspPolicy.children+=unknownElement;
			switch{
				case(value.oclIsKindOf(UML::InstanceValue) and value.oclAsType(UML::InstanceValue).instance.oclIsKindOf(UML::EnumerationLiteral)){
					var stringValue:String=value.oclAsType(UML::InstanceValue).instance.oclAsType(UML::EnumerationLiteral).name;
					unknownElement.setElementValue(stringValue);
				};
				case(value.oclIsKindOf(UML::InstanceValue)){
					value.oclAsType(UML::InstanceValue).instance.mapUnknownExtinsibility(unknownElement);
				};
				case(value.oclIsKindOf(UML::LiteralString)){
					var stringValue:String=value.oclAsType(UML::LiteralString).value;
					unknownElement.setElementValue(stringValue);
				};
				case(value.oclIsKindOf(UML::LiteralBoolean)){
					var stringValue:String=value.oclAsType(UML::LiteralBoolean).value.toString();
					unknownElement.setElementValue(stringValue);
				};
				case(value.oclIsKindOf(UML::LiteralInteger)){
					var stringValue:String=value.oclAsType(UML::LiteralInteger).value.toString();
					unknownElement.setElementValue(stringValue);
				};
				case(value.oclIsKindOf(UML::LiteralUnlimitedNatural)){
					var stringValue:String=value.oclAsType(UML::LiteralUnlimitedNatural).value.toString();
					unknownElement.setElementValue(stringValue);
				};
 				else{
					var stringValue:String=value.repr();
					unknownElement.setElementValue(stringValue);
				};
			};
				
				/*
				// for each value, an element whose name is based on definingFeature, with an attribute for value 
				var nestedunknownElement:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(templateNamespace,slot.definingFeature.name);
				unknownElement.children+=nestedunknownElement;
			switch{
				case(value.oclIsKindOf(UML::InstanceValue)){
					value.oclAsType(UML::InstanceValue).instance.mapUnknownExtinsibility(nestedunknownElement);
				};
				case(value.oclIsKindOf(UML::LiteralString)){
					var stringValue:String=value.oclAsType(UML::LiteralString).value;
					nestedunknownElement.setElementAttribute(templateNamespace,'template:value',stringValue);
				};
				case(value.oclIsKindOf(UML::LiteralBoolean)){
					var stringValue:String=value.oclAsType(UML::LiteralBoolean).value.toString();
					nestedunknownElement.setElementAttribute(templateNamespace,'template:value',stringValue);
				};
				case(value.oclIsKindOf(UML::LiteralInteger)){
					var stringValue:String=value.oclAsType(UML::LiteralInteger).value.toString();
					nestedunknownElement.setElementAttribute(templateNamespace,'template:value',stringValue);
				};
				case(value.oclIsKindOf(UML::LiteralUnlimitedNatural)){
					var stringValue:String=value.oclAsType(UML::LiteralUnlimitedNatural).value.toString();
					nestedunknownElement.setElementAttribute(templateNamespace,'template:value',stringValue);
				};
 				else{
					var stringValue:String=value.repr();
					nestedunknownElement.setElementAttribute(templateNamespace,'template:value',stringValue);
				};
			};// switch
				*/
		};// value
	};// slot	
//	}endif;
	self.mapUnknownImplicit(wspPolicy,classifier,targetNamespace);			

	return;
} 
	
helper UML::InstanceSpecification::mapPolicy(inout element:WSDL::ExtensibleElement):WSDL::UnknownExtensibilityElement@wsdl{
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	element.eExtensibilityElements+=wspPolicy;
	wspPolicy.updateElement();	
	self.slot->select(s|s.definingFeature.name='ExactlyOne').wspExactlyOne(wspPolicy);
	var Id:String=self.name;
	if(not(Id.oclIsUndefined()))then{
		wspPolicy.setElementAttribute(wsuNamespace,'wsu:Id',Id);
	}endif;
	
	return wspPolicy;
} 
helper UML::InstanceSpecification::mapNestedPolicy(inout element:WSDL::UnknownExtensibilityElement):WSDL::UnknownExtensibilityElement@wsdl{
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	element.children+=wspPolicy;
	wspPolicy.updateElement();	
	self.slot->select(s|s.definingFeature.name='ExactlyOne').wspExactlyOne(wspPolicy);
	var Id:String=self.name;
	if(not(Id.oclIsUndefined()))then{
		wspPolicy.setElementAttribute(wsuNamespace,'wsu:Id',Id);
	}endif;
	
	return wspPolicy;
} 
helper UML::InstanceSpecification::EndpointReference(inout element:WSDL::ExtensibleElement):WSDL::UnknownExtensibilityElement@wsdl{
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement('http://www.w3.org/2005/08/addressing','EndpointReference');
	element.eExtensibilityElements+=wspPolicy;
	
	wspPolicy.updateElement();	

//	self.slot.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(wspPolicy);
	self.slot.mapSlot(wspPolicy);
	
	return wspPolicy;
} 
	
helper UML::Slot::wspExactlyOne(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'ExactlyOne');
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspExactlyOneStereotype);
	element.children+=spUsernameToken;
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}

helper UML::InstanceSpecification::expressionOperand(inout expression:WSDL::UnknownExtensibilityElement){
	log('expressionOperand '+self.toString()+', '+expression.toString());
/*		
	switch{
		case(self.isSpX509Token()){
			self.spX509Token(expression);			
		};
		case(self.isSpWssX509V3Token10()){
			self.spWssX509V3Token10(expression);			
		};
		case(self.isSpRequireIssuerSerialReference()){
			self.spRequireIssuerSerialReference(expression);			
		};
		case(self.isSpStrict()){
			self.spStrict(expression);			
		};
		case(self.isSpBasic256Sha256()){
			self.spBasic256Sha256(expression);			
		};
		case(self.isSpEndorsingSupportingTokens()){
			self.spEndorsingSupportingTokens(expression);			
		};
		case(self.isSpIssuedToken()){
			self.spIssuedToken(expression);			
		};
		case(self.isSpRequestSecurityTokenTemplate()){
			self.spRequestSecurityTokenTemplate(expression);			
		};
		case(self.isSpRequireDerivedKeys()){
			self.spRequireDerivedKeys(expression);			
		};
		case(self.isSpRequireInternalReference()){
			self.spRequireInternalReference(expression);			
		};
		case(self.isTKeyType()){
			self.tKeyType(expression);			
		};
		case(self.isTKeySize()){
			self.tKeySize(expression);			
		};
		case(self.isTEncryptWith()){
			self.tEncryptWith(expression);			
		};
		case(self.isTSignWith()){
			self.tSignWith(expression);			
		};
		case(self.isTCanonicalizationAlgorithm()){
			self.tCanonicalizationAlgorithm(expression);			
		};
		case(self.isTEncryptionAlgorithm()){
			self.tEncryptionAlgorithm(expression);			
		};
		
		
		
		case(self.isSpBody()){
			self.spBody(expression);			
		};
		case(self.isSpHeader()){
			self.spHeader(expression);			
		};
		case(self.isSpMustSupportRefIssuerSerial()){
			self.SsMustSupportRefIssuerSerial(expression);			
		};
	
	case(self.isWspExactlyOne()){
			self.wspExactlyOne(expression);			
		};
		case(self.isWspAll()){
			self.wspAll(expression);			
		};
		case(self.isWsawUsingAddressing()){
			self.wsawUsingAddressing(expression);			
		};
		case(self.isWsrmRMAssertion()){
			self.wsrmRMAssertion(expression);			
		};
		case(self.isWsrmInactivityTimeout()){
			self.wsrmInactivityTimeout(expression);			
		};
		case(self.isWsrmAcknowledgementInterval()){
			self.wsrmAcknowledgementInterval(expression);			
		};
		case(self.isWspPolicy()){
			self.wspPolicy(expression);			
		};
		case(self.isSpAsymmetricBinding()){
			self.spAsymmetricBinding(expression);			
		};
		case(self.isWspPolicyReference()){
			self.wspPolicyReference(expression);			
		};
		////////////////////
		case(self.isSpInitiatorToken()){
			self.spInitiatorToken(expression);			
		};
		case(self.isSpRecipientToken()){
			self.spRecipientToken(expression);			
		};
		case(self.isSpLayout()){
			self.spLayout(expression);			
		};
		case(self.isSpIncludeTimestamp()){
			self.spIncludeTimestamp(expression);			
		};
		case(self.isSpOnlySignEntireHeadersAndBody()){
			self.spOnlySignEntireHeadersAndBody(expression);			
		};
		case(self.isSpAlgorithmSuite()){
			self.spAlgorithmSuite(expression);			
		};
		case(self.isSpWss10()){
			self.spWss10(expression);			
		};
		case(self.isWssX509V3Token10()){
			self.WssX509V3Token10(expression);			
		};
		
		case(self.isSpEncryptedParts()){
			self.spEncryptedParts(expression);			
		};
		case(self.isSpSignedParts()){
			self.spSignedParts(expression);			
		};
		else{
			log('ERROR: unsupported wsp::Expression choice '+self.repr());
		};
	};
*/		
	self.extensibleElementCommon(expression);
	return;
}
query UML::InstanceSpecification::isPolicy():Boolean=self.classifier->exists(c|c.name='Policy');
query UML::InstanceSpecification::isPolicyReference():Boolean=self.classifier->exists(c|c.name='PolicyReference');
query UML::InstanceSpecification::isEndpointReference():Boolean=self.classifier->exists(c|c.name='EndpointReference');
/*
query UML::InstanceSpecification::isSpX509Token():Boolean=self.classifier->exists(c|c.name='X509Token');	
query UML::InstanceSpecification::isSpWssX509V3Token10():Boolean=self.classifier->exists(c|c.name='X509V3Token10');	
query UML::InstanceSpecification::isSpRequireIssuerSerialReference():Boolean=self.classifier->exists(c|c.name='RequireIssuerSerialReference');	
query UML::InstanceSpecification::isSpStrict():Boolean=self.classifier->exists(c|c.name='Strict');	
query UML::InstanceSpecification::isSpBasic256Sha256():Boolean=self.classifier->exists(c|c.name='Basic256Sha256');	
query UML::InstanceSpecification::isSpEndorsingSupportingTokens():Boolean=self.classifier->exists(c|c.name='EndorsingSupportingTokens');	
query UML::InstanceSpecification::isSpIssuedToken():Boolean=self.classifier->exists(c|c.name='IssuedToken');	
query UML::InstanceSpecification::isSpRequestSecurityTokenTemplate():Boolean=self.classifier->exists(c|c.name='RequestSecurityTokenTemplate');	
query UML::InstanceSpecification::isSpRequireDerivedKeys():Boolean=self.classifier->exists(c|c.name='RequireDerivedKeys');	
	
		
query UML::InstanceSpecification::isSpRequireInternalReference():Boolean=self.classifier->exists(c|c.name='RequireInternalReference');	
query UML::InstanceSpecification::isTKeyType():Boolean=self.classifier->exists(c|c.name='KeyType');	
query UML::InstanceSpecification::isTKeySize():Boolean=self.classifier->exists(c|c.name='KeySize');	
query UML::InstanceSpecification::isTEncryptWith():Boolean=self.classifier->exists(c|c.name='EncryptWith');	
query UML::InstanceSpecification::isTSignWith():Boolean=self.classifier->exists(c|c.name='SignWith');	
query UML::InstanceSpecification::isTCanonicalizationAlgorithm():Boolean=self.classifier->exists(c|c.name='CanonicalizationAlgorithm');	
query UML::InstanceSpecification::isTEncryptionAlgorithm():Boolean=self.classifier->exists(c|c.name='EncryptionAlgorithm');	
	


query UML::InstanceSpecification::isSpBody():Boolean=self.classifier->exists(c|c.name='Body');	
query UML::InstanceSpecification::isSpHeader():Boolean=self.classifier->exists(c|c.name='Header');	
query UML::InstanceSpecification::isSpMustSupportRefIssuerSerial():Boolean=self.classifier->exists(c|c.name='MustSupportRefIssuerSerial');	
query UML::InstanceSpecification::isWspExactlyOne():Boolean=self.classifier->exists(c|c.name='ExactlyOne');	
query UML::InstanceSpecification::isWspAll():Boolean=self.classifier->exists(c|c.name='All');	
query UML::InstanceSpecification::isWsawUsingAddressing():Boolean=self.classifier->exists(c|c.name='UsingAddressing');	
	query UML::InstanceSpecification::isWsrmRMAssertion():Boolean=self.classifier->exists(c|c.name='RMAssertion');	
	query UML::InstanceSpecification::isWsrmInactivityTimeout():Boolean=self.classifier->exists(c|c.name='WsrmInactivityTimeout');	
	query UML::InstanceSpecification::isWsrmAcknowledgementInterval():Boolean=self.classifier->exists(c|c.name='AcknowledgementInterval');	
	query UML::InstanceSpecification::isWspPolicy():Boolean=self.classifier->exists(c|c.name='Policy');	
	query UML::InstanceSpecification::isSpAsymmetricBinding():Boolean=self.classifier->exists(c|c.name='AsymmetricBinding');	
	query UML::InstanceSpecification::isWspPolicyReference():Boolean=self.classifier->exists(c|c.name='PolicyReference');	
query UML::InstanceSpecification::isSpInitiatorToken():Boolean=self.classifier->exists(c|c.name='InitiatorToken');	
query UML::InstanceSpecification::isSpRecipientToken():Boolean=self.classifier->exists(c|c.name='RecipientToken');	
query UML::InstanceSpecification::isSpLayout():Boolean=self.classifier->exists(c|c.name='Layout');	
query UML::InstanceSpecification::isSpIncludeTimestamp():Boolean=self.classifier->exists(c|c.name='IncludeTimestamp');	
query UML::InstanceSpecification::isSpOnlySignEntireHeadersAndBody():Boolean=self.classifier->exists(c|c.name='OnlySignEntireHeadersAndBody');	
query UML::InstanceSpecification::isSpAlgorithmSuite():Boolean=self.classifier->exists(c|c.name='AlgorithmSuite');	
query UML::InstanceSpecification::isSpWss10():Boolean=self.classifier->exists(c|c.name='Wss10');	
query UML::InstanceSpecification::isWssX509V3Token10():Boolean=self.classifier->exists(c|c.name='WssX509V3Token10');	
	

query UML::InstanceSpecification::isSpEncryptedParts():Boolean=self.classifier->exists(c|c.name='EncryptedParts');	
query UML::InstanceSpecification::isSpSignedParts():Boolean=self.classifier->exists(c|c.name='SignedParts');	
*/
/*
property hasBeenMappedSet:Set(OclAny)=Set{};
query OclAny::hasBeenMapped():Boolean=hasBeenMappedSet->includes(self);
helper OclAny::setHasBeenMapped(){
	hasBeenMappedSet+=self;
	return;
}
*/
query UML::Slot::hasBeenMapped(hasBeenMappedSet:Set(UML::Slot)):Boolean=hasBeenMappedSet->includes(self);
/*
helper UML::Slot::setHasBeenMapped(inout hasBeenMappedSet:Set(UML::Slot)){
	hasBeenMappedSet+=self;
	return;
}
*/	
helper UML::Slot::mapSlot(inout spUsernameToken:WSDL::UnknownExtensibilityElement){
	var slot:UML::Slot=self;
		var feature:UML::StructuralFeature=slot.definingFeature;
		var featureURI:String=feature.getNearestPackage().URI;
		if((slot.value->notEmpty())and (feature.name<>'Policy'))then{
			var classifier:UML::Classifier=feature.type.oclAsType(UML::Classifier);
			switch{
				case(classifier.oclIsKindOf(UML::Artifact)or classifier.oclIsKindOf(UML::Enumeration)){
					slot.value
						->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue)
						.instance->forEach(instance){
							if((feature.name='IncludeToken'))then{
								var prefix:String='sp';
								spUsernameToken.setElementAttribute(featureURI,prefix+':'+feature.name,instance.name);
								
							}else{
								if((feature.name='URI'))then{
									// get the id of the referenced instance
									spUsernameToken.setElementAttribute('',feature.name,'#'+instance.name);
									log('URI '+instance.name);
								}else{
									instance.expressionOperand(spUsernameToken);
								}endif;
							}endif;
							
						};
						
						
						
				};
				case(classifier.oclIsKindOf(UML::PrimitiveType)and (classifier.name='Boolean')){
					// there may be some actual boolean attributes?
					slot.value
						->select(s|s.oclIsKindOf(UML::LiteralBoolean)).oclAsType(UML::LiteralBoolean).value
						->select(v|v)->forEach(qnameAssertion){
							var qname:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(featureURI,feature.name);
							spUsernameToken.children+=qname;
						}
				};
				case(classifier.oclIsKindOf(UML::PrimitiveType)and (classifier.name='String')){
					// this could be a mixed element or an attribute
					slot.value
						->select(s|s.oclIsKindOf(UML::LiteralString)).oclAsType(UML::LiteralString).value
						->forEach(stringValue){
							// 
							if((feature.name='XPath')
								or (feature.name='IssuerName')
								or (feature.name='Address')
								)then{
								var qname:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(featureURI,feature.name);
								spUsernameToken.children+=qname;
								qname.setElementValue(stringValue);
							}else{
							var prefix:String='sp';
							spUsernameToken.setElementAttribute(featureURI,prefix+':'+feature.name,stringValue);
							}endif;
						}
				};
				case(classifier.oclIsKindOf(UML::PrimitiveType)and (classifier.name='Integer')){
					// this could be a mixed element or an attribute
					slot.value
						->select(s|s.oclIsKindOf(UML::LiteralInteger)).oclAsType(UML::LiteralInteger).value.toString()
						->forEach(stringValue){
							var prefix:String='sp';
							spUsernameToken.setElementAttribute(featureURI,prefix+':'+feature.name,stringValue);
						}
				};
			};
		}endif;
	
}
helper UML::InstanceSpecification::extensibleElementCommon(inout element:WSDL::UnknownExtensibilityElement){
	// in general, iterate through instance containment hierarchy
	// primitive types are generally attributes;  booleans may be an indicator of a simple extensibility element
	// do policy first to avoid duplicates
	// note that classifier name and namespace should uniquely identify each instance;
	// special actions required for some elements which are flattened in UML
	var hasBeenMappedSet:Set(UML::Slot)=Set{};
	
	var extensionNamespace:String='';
	var extensionName:String='';
	self.classifier->select(c|not(c.getNearestPackage().URI.oclIsUndefined()))->forEach(extension){
		extensionName:=extension.name;
		extensionNamespace:=extension.getNearestPackage().URI;
		if(self.oclIsKindOf(UML::EnumerationLiteral))then{
			extensionName:=self.name;
		}endif;
		if(extensionName.startsWith('SymmetricBinding'))then{extensionName:='SymmetricBinding';}endif;
		if(extensionName.startsWith('AsymmetricBinding'))then{extensionName:='AsymmetricBinding';}endif;
	};
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(extensionNamespace,extensionName);
	element.children+=spUsernameToken;
	var policies:Sequence(UML::InstanceSpecification)=self.slot.value
		->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance
		->select(i|i.isPolicy())->asSequence();
	var policyElements:Sequence(WSDL::UnknownExtensibilityElement)=policies.mapNestedPolicy(spUsernameToken);
	var exactlyOneElements:Sequence(WSDL::UnknownExtensibilityElement)=policyElements.children;
	var allElements:Sequence(WSDL::UnknownExtensibilityElement)=exactlyOneElements.children;
	if((exactlyOneElements->notEmpty())and (allElements->isEmpty()))then{
		// create an all element and append to exactlyOneElement
		var wspEAll:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'All');
		exactlyOneElements->first().children+=wspEAll;
		allElements+=wspEAll;
		
	}endif;
	var allExtension:WSDL::UnknownExtensibilityElement=allElements->first();
	// handle flattened policies
	switch{
		case(extensionName='UserNameToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='Password')or(featureName='RequireDerivedKeys')
					or(featureName='WssUsernameToken'))then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='IssuedToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireExternalReference')or(featureName='RequireInternalReference')
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='X509Token'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireKeyIdentifierReference')or(featureName='RequireIssuerSerialReference')
					or(featureName='RequireEmbeddedTokenReference')or(featureName='RequireThumbprintReference')
					or(featureName='WssX509')
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='KerberosToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireKeyIdentifierReference')
					or(featureName='WssKerberos')
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='SpnegoContextToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='MustNotSendCancel')
					or(featureName='MustNotSendAmend')
					or(featureName='MustNotSendRenew')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='SecurityContextToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireExternalUriReference')
					or(featureName='SC13SecurityContextToken')
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='SecureConversationToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireExternalUriReference')
					or(featureName='SC13SecurityContextToken')
					or(featureName='MustNotSendCancel')
						or(featureName='MustNotSendAmend')
						or(featureName='MustNotSendRenew')
						or(featureName='BootstrapPolicy')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='SamlToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireKeyIdentifierReference')
					or(featureName='WssSaml')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='RelToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireKeyIdentifierReference')
					or(featureName='WssRel')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='HttpsToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='Https')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='KeyValueToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RsaKeyValue')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='AlgorithmSuite'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='AlgorithmSuiteCode')
					or(featureName='InclusiveC14N')
					or(featureName='InclusiveC14N11')
					or(featureName='SOAPNormalization10')
					or(featureName='STRTransform10')
					or(featureName='XPath')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='Layout'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='SecurityHeaderLayout')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='TransportBinding'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='TransportToken')
					or(featureName='AlgorithmSuite')
					or(featureName='Layout')
						or(featureName='IncludeTimestamp')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='SymmetricBinding'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='EncryptionToken')
					or(featureName='SignatureToken')
					or(featureName='ProtectionToken')
						or(featureName='AlgorithmSuite')
						or(featureName='Layout')
						or(featureName='IncludeTimestamp')
						or(featureName='EncryptBeforeSigning')
						or(featureName='EncryptSignature')
						or(featureName='ProtectTokens')
						or(featureName='OnlySignEntireHeadersAndBody')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='AsymmetricBinding'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='InitiatorToken')
					or(featureName='InitiatorSignatureToken')
					or(featureName='InitiatorEncryptionToken')
					or(featureName='RecipientToken')
					or(featureName='RecipientSignatureToken')
					or(featureName='RecipientEncryptionToken')
						or(featureName='AlgorithmSuite')
						or(featureName='Layout')
						or(featureName='IncludeTimestamp')
						or(featureName='EncryptBeforeSigning')
						or(featureName='EncryptSignature')
						or(featureName='ProtectTokens')
						or(featureName='OnlySignEntireHeadersAndBody')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case((extensionName='SupportingTokens')
			or(extensionName='SignedSupportingTokens')
			or(extensionName='EndorsingSupportingTokens')
			or(extensionName='SignedEndorsingSupportingTokens')
			or(extensionName='SignedEncryptedSupportingTokens')
			or(extensionName='EncryptedSupportingTokens')
			or(extensionName='EndorsingEncryptedSupportingTokens')
			or(extensionName='SignedEndorsingEncryptedSupportingTokens')
				
			){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='TokenAssertion')
						or(featureName='AlgorithmSuite')
						or(featureName='SignedParts')
						or(featureName='SignedElements')
						or(featureName='EncryptedParts')
						or(featureName='EncryptedElements')
						or(featureName='ContentEncryptedElements')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='Wss10'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='MustSupportRefKeyIdentifier')
					or(featureName='MustSupportRefIssuerSerial')
					or(featureName='MustSupportRefExternalURI')
					or(featureName='MustSupportRefEmbeddedToken')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='Wss11'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='MustSupportRefKeyIdentifier')
					or(featureName='MustSupportRefIssuerSerial')
					or(featureName='MustSupportRefExternalURI')
					or(featureName='MustSupportRefEmbeddedToken')
					or(featureName='MustSupportRefThumbprint')
					or(featureName='MustSupportRefEncryptedKey')
					or(featureName='RequireSignatureConfirmation')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='Trust13'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='MustSupportClientChallenge')
					or(featureName='MustSupportServerChallenge')
					or(featureName='RequireClientEntropy')
					or(featureName='RequireServerEntropy')
					or(featureName='MustSupportIssuedTokens')
					or(featureName='RequireRequestSecurityTokenCollection')
					or(featureName='RequireAppliesTo')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};


		else{
			
		};
	};
	self.slot->select(s|not(s.hasBeenMapped(hasBeenMappedSet)))->forEach(slot){
		slot.mapSlot(spUsernameToken);
	};
}
/*
helper UML::InstanceSpecification::spX509Token(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'X509Token');
	element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(wsdlSpTokenAssertionStereotype).oclAsType(Stdlib::Element);
	var IncludeToken:String=appliedStereotype.getTagValue('IncludeToken').toString();
	if(not(IncludeToken.oclIsUndefined()))then{
		spUsernameToken.setElementAttribute(SP_NAMESPACE,'sp:IncludeToken',IncludeToken);
	}endif;
	
	return;
}
	helper UML::InstanceSpecification::spWssX509V3Token10(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'WssX509V3Token10');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spRequireIssuerSerialReference(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireIssuerSerialReference');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spStrict(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Strict');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spBasic256Sha256(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Basic256Sha256');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spEndorsingSupportingTokens(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'EndorsingSupportingTokens');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spIssuedToken(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'IssuedToken');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spRequestSecurityTokenTemplate(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RequestSecurityTokenTemplate');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spRequireDerivedKeys(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireDerivedKeys');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spRequireInternalReference(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireInternalReference');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tKeyType(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'KeyType');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tKeySize(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'KeySize');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tEncryptWith(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'EncryptWith');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tSignWith(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SignWith');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tCanonicalizationAlgorithm(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'CanonicalizationAlgorithm');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tEncryptionAlgorithm(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'EncryptionAlgorithm');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	


helper UML::InstanceSpecification::spBody(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Body');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spHeader(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Header');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpHeaderStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::SsMustSupportRefIssuerSerial(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefIssuerSerial');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSsMustSupportRefIssuerSerialStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}

helper UML::InstanceSpecification::wspAll(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'All');
	element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspAllStereotype);
	self.slot.value->select(v|v.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::wsawUsingAddressing(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'UsingAddressing');
	element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWsaUsingAddressingStereotype);
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(wsdlWsaUsingAddressingStereotype).oclAsType(Stdlib::Element);
	var wsdlRequired:String=appliedStereotype.getTagValue('wsdlRequired').toString();
	if(not(wsdlRequired.oclIsUndefined()))then{
		spUsernameToken.setElementAttribute(WSDL_NAMESPACE,'wsdl:required',wsdlRequired);
	}endif;
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::wsrmRMAssertion(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RMAssertion');element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsrmRMAssertionStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::wsrmInactivityTimeout(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'InactivityTimeout');element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsrmInactivityTimeoutStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::wsrmAcknowledgementInterval(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'AcknowledgementInterval');element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsrmAcknowledgementIntervalStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::wspPolicy(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spAsymmetricBinding(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'AsymmetricBinding');element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(spAsymmetricBindingStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
*/
//helper UML::InstanceSpecification::wspPolicyReference(inout element:WSDL::UnknownExtensibilityElement){
	
helper UML::InstanceSpecification::wspPolicyReference(inout extensibleElement:WSDL::ExtensibleElement):WSDL::UnknownExtensibilityElement{
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'PolicyReference');
	extensibleElement.eExtensibilityElements+=spUsernameToken;
	
//	element.children+=spUsernameToken;
	// need to allow this stereotype on Expression
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
//	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
//	self.slot.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	self.slot.mapSlot(spUsernameToken);
	
	return spUsernameToken;
}
/*
//////////////////////////////////////////////
helper UML::InstanceSpecification::spInitiatorToken(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'InitiatorToken');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spRecipientToken(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RecipientToken');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spLayout(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Layout');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spIncludeTimestamp(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'IncludeTimestamp');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spOnlySignEntireHeadersAndBody(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'OnlySignEntireHeadersAndBody');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spAlgorithmSuite(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'AlgorithmSuite');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spWss10(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Wss10');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::WssX509V3Token10(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'WssX509V3Token10');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	


helper UML::InstanceSpecification::spEncryptedParts(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'EncryptedParts');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spSignedParts(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SignedParts');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(wsdlSpSignedPartsStereotype).oclAsType(Stdlib::Element);
	var body:Boolean=appliedStereotype.getTagValue('body').oclAsType(Boolean);
	if(body)then{
		var spBody:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Body');
		spUsernameToken.children+=spBody;
	}endif;
	appliedStereotype.getTagValues('header').oclAsType(Stdlib::Element)->forEach(header){
		var name:String=header.getTagValue('name').toString();
		var namespace:String=header.getTagValue('namespace').toString();
		var spHeader:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Header');
		spUsernameToken.children+=spHeader;
		if(not(name.oclIsUndefined()))then{
			spHeader.setElementAttribute(null,'Name',name);
		}endif;
		if(not(namespace.oclIsUndefined()))then{
			spHeader.setElementAttribute(null,'Namespace',namespace);
		}endif;
	};
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	
	return;
}

*/	
//mapping 	UML::Collaboration::ServiceDefinition():WSDL::Definition@wsdl 
mapping 	UML::Component::ServiceDefinition():WSDL::Definition@wsdl 
{
	log('ServiceDefinition from '+self.qualifiedName);
//	targetNamespace:=self.getTargetNamespace()+'Service';
	var serviceInterface:UML::InstanceSpecification=	self.findRealizingExtensions()->first();

//	targetNamespace:=self.getTargetNamespace();
	targetNamespace:=serviceInterface.slot
		->select(s|s.definingFeature.name='ServiceURI').value.oclAsType(UML::InstanceValue).instance.slot
		->select(s|s.definingFeature.name='URIAddress').value.oclAsType(UML::LiteralString).value->asSequence()->first();
//	location:=self.getWsdlPartLocation('Service');
	location:=self.getWsdlPartLocation('');
	//eNamespaces+=new WSDL::Namespace(self.getBindingNamespace(),'serviceBinding');
	self.setCommonDefinitionFeatures(result);
	// find extensions as artifact instances
		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				else{
					//log('ERROR: Unsupported WSDL::Definition extension '+ee.repr());
					ee.mapUnknown(result,self);
				};
			};
	};		
	
//	eServices+=self.map Service(result);
//	eServices+=self.ownedPort.map Service(result);
//	eServices+=self.service().map Service(result);
	self.service().map Service(result);
	// import the bindings
//	eImports+=self.getRealizedInterfaces().map ServiceImport(self,result);
//	eImports+=self.map ServiceImport(self,result);
/* lets not break this apart for GRA
	self.service().port()
	->select(port|not(port.binding().portType(port).oclIsUndefined()))
	->forEach(port){
		eImports+=port.binding().map ServiceImport(self,port);
	};
	*/
	//self.ServiceDefinitionWsdlAnnotation(result);
	
	
}	
query UML::NamedElement::findRealizingExtensions():Sequence(UML::InstanceSpecification)=
	self.getTargetDirectedRelationships()
		->select(r|r.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization).client
		->select(r|r.oclIsKindOf(UML::InstanceSpecification)).oclAsType(UML::InstanceSpecification)->asSequence();

//query UML::Collaboration::service():Set(UML::Component)=self.collaborationRole.type->select(r|r.oclIsKindOf(UML::Component)).oclAsType(UML::Component)->asSet();
//query UML::Artifact::service():Set(UML::Component)=self.manifestation.utilizedElement->select(r|r.oclIsKindOf(UML::Component)).oclAsType(UML::Component)->asSet();
query UML::Component::service():UML::Component=self;
query UML::Component::port():Set(UML::Port)=self.ownedPort;
//query UML::Component::binding():Set(UML::Class)=self.port().type->select(t|t.oclIsKindOf(UML::Class)).oclAsType(UML::Class)->asSet();
query UML::Port::binding():UML::Classifier=self.type->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier)->asSequence()->first();
query UML::Classifier::portType(port:UML::Port):UML::Interface{
	if(self.oclIsKindOf(UML::Interface)and not(port.isConjugated))then {return self.oclAsType(UML::Interface);} endif;
	if(self.oclIsKindOf(UML::Class))then {
		if(port.isConjugated)
			then {return self.oclAsType(UML::Class).getAllUsedInterfaces()->asSequence()->first();} 
			else {return self.oclAsType(UML::Class).getRealizedInterfaces()->asSequence()->first();}
			endif;
		}endif;	
	return null;	
	}	
//query UML::Collaboration::getBindingNamespace():String=self.getTargetNamespace()+'Binding';		
helper UML::Classifier::setCommonDefinitionFeatures(inout definition:WSDL::Definition):Void{
	definition.setQName(self.getName());
	// is it just getting first namespace?  YES
// TODO: this should be unique since we may be importing another wsdl namespace
	definition.addNamespace('wsdltns',definition.targetNamespace);
	definition.addNamespace(wsawsPrefix,wsawsNamespace);
	definition.addNamespace(soapPrefix,soapNamespace);
	definition.addNamespace(wspPrefix,wspNamespace);
	definition.addNamespace(wsuPrefix,wsuNamespace);
	//definition.addNamespace(mpoNamespace,mpoPrefix);
	definition.addNamespace(wsrmPrefix,wsrmNamespace);
	definition.addNamespace(spPrefix,spNamespace);
	definition.addNamespace(templatePrefix,templateNamespace);
	definition.addNamespace('SAN','http://ijis.org/GRA/Annotations');
	definition.addNamespace('SANWSDL','http:/ijis.org/GRA/WSDLAnnotations');
	
	definition.addNamespace('soap12','http://schemas.xmlsoap.org/wsdl/soap12/');
	definition.addNamespace('wsdl','http://schemas.xmlsoap.org/wsdl/');
	definition.addNamespace('http','http://schemas.xmlsoap.org/wsdl/http/');
	definition.addNamespace('xsd','http://www.w3.org/2001/XMLSchema');
	definition.addNamespace('xmi','http://www.omg.org/spec/XMI/20110701');
	definition.addNamespace('xsi','http://www.w3.org/2001/XMLSchema-instance');
	definition.addNamespace('uml','http://www.omg.org/spec/UML/20110701');
	//definition.addNamespace('wsaw','http://www.w3.org/2006/05/addressing/wsdl');
	definition.addNamespace('wsam','http://www.w3.org/2007/05/addressing/metadata');
	
	/*
	definition.eNamespaces+=new WSDL::Namespace(definition.targetNamespace,'tns');
	
	definition.eNamespaces+=new WSDL::Namespace(wsawsNamespace,wsawsPrefix);
	definition.eNamespaces+=new WSDL::Namespace(soapNamespace,soapPrefix);
	definition.eNamespaces+=new WSDL::Namespace(wspNamespace,wspPrefix);
	definition.eNamespaces+=new WSDL::Namespace(wsuNamespace,wsuPrefix);
	definition.eNamespaces+=new WSDL::Namespace(mpoNamespace,mpoPrefix);
	definition.eNamespaces+=new WSDL::Namespace(wsrmNamespace,wsrmPrefix);
	definition.eNamespaces+=new WSDL::Namespace(spNamespace,spPrefix);
	
	// we are not getting any of the namespace through
	definition.updateDocument();
	*/
}	
/* not for GRA	
mapping 	UML::Class::BindingDefinition(port:UML::Port):WSDL::Definition@wsdl 
{
//	targetNamespace:=self.getBindingNamespace();
	targetNamespace:=self.getTargetNamespace();
//	location:=self.getWsdlPartLocation('Binding');
	location:=self.getWsdlPartLocation('');
	self.setCommonDefinitionFeatures(result);
//	eBindings+=self.map Binding(service,port);
	eBindings+=self.map Binding(port,result);		
	
	// import the portTypes
	eImports+=self.map BindingImport(self,port);
	self.BindingDefinitionWsdlAnnotation(result,port);
}
	
mapping 	UML::Collaboration::BindingDefinition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getBindingNamespace();
	result.setQName(self.getName());
	location:=self.getWsdlPartLocation('Binding');
	eNamespaces+=new WSDL::Namespace(wsawsNamespace,wsawsPrefix);
	eNamespaces+=new WSDL::Namespace(soapNamespace,soapPrefix);
	eNamespaces+=new WSDL::Namespace(wspNamespace,wspPrefix);
	eNamespaces+=new WSDL::Namespace(wsuNamespace,wsuPrefix);
	eNamespaces+=new WSDL::Namespace(mpoNamespace,mpoPrefix);
	eNamespaces+=new WSDL::Namespace(wsrmNamespace,wsrmPrefix);
	eNamespaces+=new WSDL::Namespace(spNamespace,spPrefix);
	result.updateDocument();
//	eBindings+=self.getRealizedInterfaces().map Binding(self);
//	eBindings+=self.ownedPort.type.map Binding(self);
	self.service()->forEach(service){
		
	 	service.port()->forEach(port){
			eBindings+=port.binding().map Binding(service,port);
		};
	};
	//eBindings+=self.service().binding().map Binding(self);

	// import the portTypes
//	eImports+=self.getRealizedInterfaces().map BindingImport(self,result);
	eImports+=self.map BindingImport(self,result);
	self.BindingDefinitionWsdlAnnotation(result);
}
*/	
/*
mapping 	UML::Interface::Definition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getTargetNamespace();
	location:=self.getWsdlLocation();
	self.allInterfaceSchemaPackages().toPsmPackage()->forEach(schema){
		var targetNamespace:String=schema.targetNamespace;
		var prefix:String=schema.getSchemaPrefix();
		eNamespaces+=new WSDL::Namespace(targetNamespace,prefix);
	};
	self.setCommonDefinitionFeatures(result);
	ePortTypes+=self.map PortType(result);
	eMessages+=ePortTypes.eOperations->select(o|not(o.eInput.oclIsUndefined())).eInput.eMessage
		->union(ePortTypes.eOperations->select(o|not(o.eOutput.oclIsUndefined())).eOutput.eMessage)
		->union(ePortTypes.eOperations.eFaults.eMessage)->asSet();
	// import the schemas
	eImports+=self.allInterfaceSchemaPackages().map Import(self,result);
	self.DefinitionWsdlAnnotation(result);
	
}
*/	
/*
mapping 	UML::Collaboration::Definition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getTargetNamespace();
	result.setQName(self.getName());
	location:=self.getWsdlLocation();
	self.service().port()->forEach(port){
		port.binding().allSchemaPackages().toPsmPackage()->forEach(schema){
			var targetNamespace:String=schema.targetNamespace;
			var prefix:String=schema.getSchemaPrefix();
			eNamespaces+=new WSDL::Namespace(targetNamespace,prefix);
		};
	};
	result.updateDocument();
//	ePortTypes+=self.getRealizedInterfaces().map PortType();
//	ePortTypes+=self.ownedPort.type.getRealizedInterfaces().map PortType();
	self.service().port()->forEach(port){
		ePortTypes+=port.binding().portType(port).map PortType();
	};
	//ePortTypes+=self.service().binding().portType().map PortType();
	eMessages+=ePortTypes.eOperations->select(o|not(o.eInput.oclIsUndefined())).eInput.eMessage
		->union(ePortTypes.eOperations->select(o|not(o.eOutput.oclIsUndefined())).eOutput.eMessage)
		->union(ePortTypes.eOperations.eFaults.eMessage)->asSet();
	// import the schemas
	self.service().port()->forEach(port){
		eImports+=port.binding().allSchemaPackages().map Import(self,result);
	};
//	eImports+=self.service().binding().allSchemaPackages().map Import(self,result);
	self.DefinitionWsdlAnnotation(result);
	
}	
*/
//mapping UML::Classifier::Service(in definition:WSDL::Definition):WSDL::Service@wsdl
mapping UML::Component::Service(inout definition:WSDL::Definition):WSDL::Service@wsdl
	when{self.port()->exists(port|not(port.binding().portType(port).oclIsUndefined()))}
{
	
	result.setQName(definition,self.getName()+'Service');// if not set before added to container, it does not get added
//	ePorts+=self.getRealizedInterfaces().map Port(definition,result,self);
	definition.eServices+=result;
//	ePorts+=self.port().map Port(definition,result,self);
	self.port().map Port(definition,result,self);

	//result.setQName(self.getName()+'Service');// now attached to definition so we can get namespace
}
	
/*
mapping 	UML::Classifier::ServiceDefinition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getTargetNamespace()+'Service';
	result.setQName(self.getName());
	location:=self.getWsdlPartLocation('Service');
	result.updateDocument();
	eServices+=self.map Service(result);
	// import the bindings
//	eImports+=self.getRealizedInterfaces().map ServiceImport(self,result);
	eImports+=self.map ServiceImport(self,result);
	self.ServiceDefinitionWsdlAnnotation(result);
	
}	
mapping 	UML::Classifier::BindingDefinition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getTargetNamespace()+'Binding';
	result.setQName(self.getName());
	location:=self.getWsdlPartLocation('Binding');
	eNamespaces+=new WSDL::Namespace(wsawsNamespace,wsawsPrefix);
	eNamespaces+=new WSDL::Namespace(soapNamespace,soapPrefix);
	eNamespaces+=new WSDL::Namespace(wspNamespace,wspPrefix);
	eNamespaces+=new WSDL::Namespace(wsuNamespace,wsuPrefix);
	eNamespaces+=new WSDL::Namespace(mpoNamespace,mpoPrefix);
	eNamespaces+=new WSDL::Namespace(wsrmNamespace,wsrmPrefix);
	eNamespaces+=new WSDL::Namespace(spNamespace,spPrefix);
	result.updateDocument();
	eBindings+=self.getRealizedInterfaces().map Binding(self);

	// import the portTypes
//	eImports+=self.getRealizedInterfaces().map BindingImport(self,result);
	eImports+=self.map BindingImport(self,result);
	self.BindingDefinitionWsdlAnnotation(result);
}	
mapping 	UML::Classifier::Definition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getTargetNamespace();
	result.setQName(self.getName());
	location:=self.getWsdlLocation();
	result.updateDocument();
	self.allSchemaPackages().toPsmPackage()->forEach(schema){
		var targetNamespace:String=schema.targetNamespace;
		var prefix:String=schema.getSchemaPrefix();
		eNamespaces+=new WSDL::Namespace(targetNamespace,prefix);
	};
	ePortTypes+=self.getRealizedInterfaces().map PortType();
	eMessages+=ePortTypes.eOperations->select(o|not(o.eInput.oclIsUndefined())).eInput.eMessage
		->union(ePortTypes.eOperations->select(o|not(o.eOutput.oclIsUndefined())).eOutput.eMessage)
		->union(ePortTypes.eOperations.eFaults.eMessage)->asSet();
	// import the schemas
	eImports+=self.allSchemaPackages().map Import(self,result);
	self.DefinitionWsdlAnnotation(result);
	
}	

mapping UML::Classifier::Service(in definition:WSDL::Definition):WSDL::Service@wsdl
{
	
	result.setQName(self.getName()+'Service');
	ePorts+=self.getRealizedInterfaces().map Port(definition,result,self);
	
}
*/
//mapping UML::Interface::Port(in definition:WSDL::Definition,in service:WSDL::Service,serviceInterface:UML::Classifier):WSDL::Port@wsdl
mapping UML::Port::Port(inout definition:WSDL::Definition,inout service:WSDL::Service,participant:UML::Component):WSDL::Port@wsdl
	when{not(self.binding().portType(self).oclIsUndefined())}
{
	
	name:=self.getName()+'Port';
	service.ePorts+=result;
	//result.updateElement();// update does not help here
	
//	eBinding:=self.map Binding(serviceInterface);
//	eBinding:=self.binding().map Binding(participant,self);
	eBinding:=self.binding().map Binding(self,definition);
//	service.ePorts+=result;// does not help qname problem
	// must define address
//	eExtensibilityElements+=new SOAPAddress(self.locationURI());
/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(wsdlSoapAddressStereotype).oclAsType(Stdlib::Element);
	
	var required:Boolean=appliedStereotype.getTagValue('wsdlRequired').oclAsType(Boolean);
	var location:String=appliedStereotype.getTagValue('location').oclAsType(String);
	var soapAddress:SOAP::SOAPAddress=new SOAP::SOAPAddress(location);
	if(required)then{
		soapAddress.required:=required;
	}endif;	
	eExtensibilityElements+=soapAddress;
*/
		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
//					eExtensibilityElements+=ee.wspPolicyReference();
					ee.wspPolicyReference(result);
				};
				case(ee.isEndpointReference()){
//					eExtensibilityElements+=ee.EndpointReference();
					ee.EndpointReference(result);
				};
					
				
				else{
					ee.mapUnknown(result,self);
//					log('ERROR: Unsupported WSDL::Port extension '+ee.repr());
				};
			};
	};		
}
//mapping UML::Interface::Binding(serviceInterface:UML::Classifier):WSDL::Binding@wsdl
//mapping UML::Class::Binding(participant:UML::Component,port:UML::Port):WSDL::Binding@wsdl
mapping UML::Classifier::Binding(port:UML::Port,inout definition:WSDL::Definition):WSDL::Binding@wsdl
	when{not(self.portType(port).oclIsUndefined())}
{
	result.setQName(definition,self.getName()+port.getName()+'Binding');
	definition.eBindings+=result;
	
//	ePortType:=self.map PortType();
	ePortType:=self.portType(port).map PortType(definition);
//	ePortType:=self.portType().map PortType();
//	eBindingOperations+=ePortType.eOperations.map BindingOperation(self);
	ePortType.eOperations.map BindingOperation(self,result);
	// must define binding
	//eExtensibilityElements+=new SOAPBinding(self.transportURI(),self.style());
	//     	<wsaws:UsingAddressing/>
//	eExtensibilityElements+=wsawsUsingAddressing();
//	wsawsUsingAddressing(result);
	/*
	if(serviceInterface.stereotypedBy(policyProfileAuthentication))then{
		eExtensibilityElements+=wspPolicyReference('#PasswordAuthenticationOverSSL');
	}else{}endif;
	if(serviceInterface.stereotypedBy(policyProfileReliability))then{
		eExtensibilityElements+=wspPolicyReference('#ReliableMessaging');
	}else{}endif;
	
	*/
	/*
	self.clientDependency
			->select(d|d.IsStereotypeApplied(wsdlWspPolicyReferenceStereotype)).oclAsType(UML::Usage).supplier
			->select(d|d.IsStereotypeApplied(wsdlWspPolicyStereotype))
			->forEach(ref){
					var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(wsdlWspPolicyStereotype).oclAsType(Stdlib::Element);
					var Id:String=appliedStereotype.getTagValue('Id').toString();
					eExtensibilityElements+=wspPolicyReference('#'+Id);
		};
	*/
		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
//					eExtensibilityElements+=ee.wspPolicyReference();
					ee.wspPolicyReference(result);
					
				};
				else{
					ee.mapUnknown(result,self);
//					log('ERROR: Unsupported WSDL::Definition extension '+ee.repr());
				};
			};
	};		

	// null ptr exception: is it this? TODO temporary suppress
//	definition.eBindings+=result;
	
}
mapping UML::Interface::PortType(inout definition:WSDL::Definition):WSDL::PortType@wsdl
{
	
	result.setQName(definition,self.getName());
	definition.ePortTypes+=result;
//	eOperations+=self.allBehavioralFeatures().map Operation(result,self,definition);
	self.allBehavioralFeatures().map Operation(result,self,definition);
	/* no extensions here
		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
					ee.wspPolicyReference(result);
					
				};
				else{
					ee.mapUnknown(result,self);
				};
			};
		};
	*/
	// TODO: test if this causes null ptr exception
//	definition.ePortTypes+=result;
	//result.setQName(self.getName());// failure occurs if done here
}
//mapping WSDL::Operation::BindingOperation(context:UML::Interface):WSDL::BindingOperation@wsdl
mapping WSDL::Operation::BindingOperation(context:UML::Classifier,inout binding:WSDL::Binding):WSDL::BindingOperation@wsdl
{
	
	name:=self.name;
	eOperation:=self;
	var umlOperation:UML::BehavioralFeature=self.findUmlOperation(context);
	binding.eBindingOperations+=result;
//	var umlOperation:UML::BehavioralFeature=context.ownedOperation->select(o|o.name=self.name)->asSequence()->first();
	
//	eExtensibilityElements+=new SOAPOperation(umlOperation.soapActionURI(),umlOperation.style());
	//result.setElementAttribute(mpoNamespace,'mpo:modifieable','');
//	eBindingInput:=self.eInput.map BindingInput(umlOperation);
//	eBindingOutput:=self.eOutput.map BindingOutput(umlOperation);
//	eBindingFaults:=self.eFaults.map BindingFault(umlOperation);
	self.eInput.map BindingInput(umlOperation,result,context);
	self.eOutput.map BindingOutput(umlOperation,result,context);
	self.eFaults.map BindingFault(umlOperation,result);
		umlOperation.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
					ee.wspPolicyReference(result);
					
				};
				else{
					ee.mapUnknown(result,umlOperation);
				};
			};
		};
	
}

mapping WSDL::Input::BindingInput(umlOperation:UML::BehavioralFeature,
	inout bindingOperation:WSDL::BindingOperation,context:UML::Classifier):WSDL::BindingInput@wsdl
{
//	name:=umlOperation.name+'_'+self.name;
//	name:=self.getName()+self.uniqueInputNameSuffix(context);
	name:=self.name;
	eInput:=self;
	bindingOperation.eBindingInput:=result;
//	var umlOperation:UML::BehavioralFeature=self.getContainer().oclAsType(WSDL::Operation).findUmlOperation();
//	eExtensibilityElements+=new SOAPBody(umlOperation.use(),self.parts());
//	new SOAPBody(umlOperation.use(),self.parts(),result);
//	result.setElementAttribute(wsawsNamespace,'wsaws:Action',umlOperation.soapActionURI());
//					log('WSDL::BindingInput umlOperation ');
//					log('WSDL::BindingInput umlOperation '+umlOperation.repr());
	umlOperation.ownedParameter->select(p|(p.getName()=self.name)or(p.name.oclIsUndefined() and self.name.oclIsUndefined()))->forEach(parameter){
//					log('WSDL::BindingInput parameter '+parameter.repr());
		parameter.findRealizingExtensions()->forEach(ee){
//					log('WSDL::BindingInput extension '+ee.repr());
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
//					eExtensibilityElements+=ee.wspPolicyReference();
					ee.wspPolicyReference(result);
					
				};
				else{
					ee.mapUnknown(result,parameter);
//					log('ERROR: Unsupported WSDL::BindingInput extension '+ee.repr());
				};
			};
		};
		// SOAPHeader is represented as a Usage to a property, which is a Message/Part
		parameter.clientDependency->select(d|d.oclIsKindOf(UML::Usage))->forEach(soapHeader){
			
			var soapHeaderInstance:Stdlib::Element=soapHeader.GetStereotypeApplication(wsdlSoapHeaderStereotype).oclAsType(Stdlib::Element);
			
			var namespace:String=soapHeaderInstance.getTagValue('namespace').oclAsType(String);
			var encodingStyle:String=soapHeaderInstance.getTagValue('encodingStyle').oclAsType(String);
			var use:UML::EnumerationLiteral=soapHeaderInstance.getTagValue('use').oclAsType(UML::EnumerationLiteral);
			var header:SOAP::SOAPHeader=new SOAP::SOAPHeader();
			eExtensibilityElements+=header;
			header.namespaceURI:=namespace;
			header.eEncodingStyles:=encodingStyle;
			header.use:=use.name;
			soapHeader.supplier->forEach(messagePart){
				var part:WSDL::Part=messagePart.resolveone(WSDL::Part);
				header.ePart:=part;
			};
		};		
	};

}
mapping WSDL::Output::BindingOutput(umlOperation:UML::BehavioralFeature,
	inout bindingOperation:WSDL::BindingOperation,context:UML::Classifier):WSDL::BindingOutput@wsdl
{
//	name:=umlOperation.name+'_'+self.name;
//	name:=self.getName()+self.uniqueInputNameSuffix(context);
	name:=self.name;
	
	eOutput:=self;
	bindingOperation.eBindingOutput:=result;
//	var umlOperation:UML::BehavioralFeature=self.getContainer().oclAsType(WSDL::Operation).findUmlOperation();
//	eExtensibilityElements+=new SOAPBody(umlOperation.use(),self.parts());
//	new SOAPBody(umlOperation.use(),self.parts(),result);
//	result.setElementAttribute(wsawsNamespace,'wsaws:Action',umlOperation.soapActionURI()+'Response');
	umlOperation.ownedParameter->select(p|p.getName()=self.name)->forEach(parameter){
		parameter.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
//					eExtensibilityElements+=ee.wspPolicyReference();
					ee.wspPolicyReference(result);
					
				};
				else{
					ee.mapUnknown(result,parameter);
//					log('ERROR: Unsupported WSDL::BindingInput extension '+ee.repr());
				};
			};
		};		
		// SOAPHeader is represented as a Usage to a property, which is a Message/Part
		parameter.clientDependency->select(d|d.oclIsKindOf(UML::Usage))->forEach(soapHeader){
			
			var soapHeaderInstance:Stdlib::Element=soapHeader.GetStereotypeApplication(wsdlSoapHeaderStereotype).oclAsType(Stdlib::Element);
			
			var namespace:String=soapHeaderInstance.getTagValue('namespace').oclAsType(String);
			var encodingStyle:String=soapHeaderInstance.getTagValue('encodingStyle').oclAsType(String);
			var use:UML::EnumerationLiteral=soapHeaderInstance.getTagValue('use').oclAsType(UML::EnumerationLiteral);
			var header:SOAP::SOAPHeader=new SOAP::SOAPHeader();
			eExtensibilityElements+=header;
			
			header.namespaceURI:=namespace;
			header.eEncodingStyles:=encodingStyle;
			header.use:=use.name;
			soapHeader.supplier->forEach(messagePart){
				var part:WSDL::Part=messagePart.resolveone(WSDL::Part);
				header.ePart:=part;
			};
		};		
	};
}
mapping WSDL::Fault::BindingFault(umlOperation:UML::BehavioralFeature,inout bindingOperation:WSDL::BindingOperation):WSDL::BindingFault@wsdl
{
	name:=self.name;
	bindingOperation.eBindingFaults+=result;
	eFault:=self;
//	var umlOperation:UML::BehavioralFeature=self.getContainer().oclAsType(WSDL::Operation).findUmlOperation();
//	eExtensibilityElements+=new SOAPFault(self.name,umlOperation.use());
}
	
mapping UML::BehavioralFeature::Operation(inout portType:WSDL::PortType,owningInterface:UML::Interface,inout definition:WSDL::Definition):WSDL::Operation@wsdl
{
	if(self.oclIsKindOf(UML::Reception))then{
		name:=self.oclAsType(UML::Reception).signal.name;
	}else{
		name:=self.getName();
	}endif;
	portType.eOperations+=result;
	
//	eInput:=self.getInputParameter().map Input(portType,owningInterface,definition);
//	eOutput:=self.getOutputParameter().map Output(portType,definition);
//	eFaults:=self.raisedException.map Fault(portType,definition);

	self.getInputParameter().map Input(portType,owningInterface,definition,result);
	self.getOutputParameter().map Output(portType,owningInterface,definition,result);
	self.raisedException.map Fault(portType,definition,result);
		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
					ee.wspPolicyReference(result);
					
				};
				else{
					ee.mapUnknown(result,self);
				};
			};
		};
		
}
mapping UML::Type::Fault(portType:WSDL::PortType,inout definition:WSDL::Definition,inout operation:WSDL::Operation):WSDL::Fault@wsdl
{
	name:=self.getName();
	operation.eFaults+=result;
	eMessage:=self.oclAsType(UML::Classifier).map Message(/*portType,*/definition);
}
mapping UML::NamedElement::Input(portType:WSDL::PortType,owningInterface:UML::Interface,inout definition:WSDL::Definition,inout operation:WSDL::Operation):WSDL::Input@wsdl
{
	// name must be unique amongst all input/output names in portType 
	name:=self.getName()+self.uniqueInputNameSuffix(owningInterface);
	operation.eInput:=result;
	var type:UML::Classifier=self.getUmlType();
	eMessage:=type.map Message(/*portType,*/definition);
		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
					ee.wspPolicyReference(result);
					
				};
				else{
					ee.mapUnknown(result,self);
					ee.mapUnknown(eMessage,self);
				};
			};
		};
}
mapping UML::NamedElement::Output(portType:WSDL::PortType,owningInterface:UML::Interface,inout definition:WSDL::Definition,inout operation:WSDL::Operation):WSDL::Output@wsdl
{
//	name:=self.getName();
	name:=self.getName()+self.uniqueInputNameSuffix(owningInterface);
	operation.eOutput:=result;
	var type:UML::Classifier=self.getUmlType();
	eMessage:=type.map Message(/*portType,*/definition);
		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
					ee.wspPolicyReference(result);
					
				};
				else{
					ee.mapUnknown(result,self);
					ee.mapUnknown(eMessage,self);
				};
			};
		};
}
mapping UML::Classifier::Message(/*inout portType:WSDL::PortType,*/inout definition:WSDL::Definition):WSDL::Message@wsdl
{
//	portType.getEnclosingDefinition().eMessages+=result;
	result.setQName(definition,self.getName());
	definition.eMessages+=result;
//	eParts+=self.attribute.map Part(portType,definition);
	// if this is a NIEM type, then make Part for that type; otherwise expand all attributes as parts

	if(self.getNearestNIEMSchemaPackage().oclIsUndefined())then{
		self.attribute.map Part(definition,result);
	}else{
		self.map Part(definition,result);
	}endif;

			self.findRealizingExtensions()->forEach(ee){
				switch{
					case(ee.isPolicy()){
						// wsp
						ee.mapPolicy(result);
					};
					case(ee.isPolicyReference()){
						ee.wspPolicyReference(result);
						
					};
					else{
						ee.mapUnknown(result,self);
					};
				};
			};
}
mapping UML::Classifier::Part(/*in portType:WSDL::PortType,*/inout definition:WSDL::Definition,inout message:WSDL::Message):WSDL::Part@wsdl
{
		
	// may need to do this based on psm model
	name:=self.getName();
	message.eParts+=result;
		// try to make a type instead of an element
		
		var xsdTypeDefinition:XSD::XSDTypeDefinition=self.toPsmClassifier();
		if(xsdTypeDefinition.oclIsUndefined())then{
			log('ERROR: failed to resolve type definition for '+self.qualifiedName);
		}else{
				typeDefinition:=xsdTypeDefinition;
				result.setTypeName(xsdTypeDefinition,definition);
				log('Part schema '+xsdTypeDefinition.schema.repr());
				xsdTypeDefinition.schema.map TypeSchema(definition);
		}endif;

}

mapping UML::Property::Part(/*in portType:WSDL::PortType,*/inout definition:WSDL::Definition,inout message:WSDL::Message):WSDL::Part@wsdl
{
		
	// may need to do this based on psm model
	name:=self.getName();
	message.eParts+=result;
//	typeDefinition:=self.map AbstractTypeDefinition();
	// we should actually do an element here
	//typeDefinition:=self.toPsmClassifier();
	// TODO: this is reliable only at PSM level
	var topLevelProperty:UML::Property=self.usesTopLevelProperty();
	/*
	if(topLevelProperty.oclIsUndefined())then{
		// TODO: temporary workaround
		topLevelProperty:=self;
	}endif;
	*/
	
	if(topLevelProperty.oclIsUndefined())then{
		// try to make a type instead of an element
			
		var xsdTypeDefinition:XSD::XSDTypeDefinition=self.type.oclAsType(UML::Classifier).toPsmClassifier();
			
				
		if(xsdTypeDefinition.oclIsUndefined())then{
			// TODO: temporary workaround
			var schema:XSD::XSDSchema=self.type.getNearestNIEMSchemaPackage().toPsmPackage();
			if(schema.oclIsUndefined())then{
				schema:=self.type.getNearestPackage().map NamespaceGRA();
			}endif;
			if(not(schema.oclIsUndefined()))then{
				log('Part property schema '+schema.repr());
				schema.map TypeSchema(definition);
        		xsdTypeDefinition:= self.type.map AbstractXSDSchemaContent(schema).oclAsType(XSD::XSDTypeDefinition);
				if(xsdTypeDefinition.oclIsUndefined())then{
					log('ERROR: failed to resolve type definition for '+self.qualifiedName);
				}endif;
			}else{
					log('ERROR: failed to resolve schema for '+self.qualifiedName);
			}endif;
		}endif;
		
		if(not(xsdTypeDefinition.oclIsUndefined()))then{
			if(xsdTypeDefinition.schema.oclIsUndefined())then{
				log("type definition does not have schema at "+xsdTypeDefinition.repr());
			}else{
				typeDefinition:=xsdTypeDefinition;
				result.setTypeName(xsdTypeDefinition,definition);
				log('Part property schema '+xsdTypeDefinition.schema.repr());
				xsdTypeDefinition.schema.map TypeSchema(definition);
			}endif;
		}endif;
				
			
	
	}else{
	
		//var xsdElementDeclaration:XSD::XSDElementDeclaration=self.usesTopLevelProperty().toPsmTopLevelElement()->asSequence()->first();
		// this needs psm level stereotype, so this too needs a work-around
		var xsdElementDeclaration:XSD::XSDElementDeclaration=topLevelProperty.toPsmTopLevelElement();
		if(xsdElementDeclaration.oclIsUndefined())then{
			// TODO: temporary workaround
			var schema:XSD::XSDSchema=topLevelProperty.getNearestNIEMSchemaPackage().toPsmPackage();
			if(schema.oclIsUndefined())then{
				schema:=topLevelProperty.getNearestPackage().map NamespaceGRA();
			}endif;
			if(not(schema.oclIsUndefined()))then{
				log('Part property schema '+schema.repr());
				schema.map TypeSchema(definition);
				xsdElementDeclaration:=topLevelProperty.map TopLevelElement_declarationGRA(schema);
			}endif;
		}endif;
		
		if(not(xsdElementDeclaration.oclIsUndefined()))then{
			elementDeclaration:=xsdElementDeclaration;
			result.setElementName(xsdElementDeclaration,definition);
				log('Part property schema '+xsdElementDeclaration.schema.repr());
				xsdElementDeclaration.schema.map TypeSchema(definition);
		}endif;
	}endif;
		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
					ee.wspPolicyReference(result);
					
				};
				else{
					ee.mapUnknown(result,self);
				};
			};
		};
	
}


mapping XSD::XSDSchema::TypeSchema(inout definition:WSDL::Definition):XSD::XSDSchema
{
		// set xmlns mapping now, or else the Q* prefixes may be in table
		result.setSchemaForSchema('xsd',schemaForSchemaNamespace);
		/*
		this.schemaForSchema:=result.schemaForSchema;
		// get instance of Stereotype
		var pimStereotypeInstance:Stdlib::Element=self.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
		// set schema targetNamespace from <<Namespace>>
		result.targetNamespace:=pimStereotypeInstance.getSchemaTargetNamespace();
		// set prefix to be used for Schema namespace
			var defaultPrefix:String=pimStereotypeInstance.getSchemaDefaultPrefix();
		
		result.setPrefixForSchemaNamespace(defaultPrefix);
	*/
	if(definition.eTypes.oclIsUndefined())then{
		definition.eTypes:=new WSDL::Types();
	}endif;
	elementFormDefault:=self.elementFormDefault;
	attributeFormDefault:=self.attributeFormDefault;
	schemaLocation:=definition.location;
	//targetNamespace:=self.targetNamespace;
	var xsdImport:XSD::XSDImport=new XSD::XSDImport();
	xsdImport.namespace:=self.targetNamespace;
	xsdImport.resolvedSchema:=self;
	
	var referencedSchema:String=self.schemaLocation.startsWithXmlSchemasFolder();
	var thisSchema:String=definition.location;
	var relativePath:String=thisSchema.relativePathTo(referencedSchema);
	if(relativePath.oclIsUndefined())then{
		relativePath:='/unknownPathTo/'+self.schemaLocation;
		if(relativePath.oclIsUndefined())then{
			relativePath:='/unresolvedPathTo/'+self.repr();
		}endif;
	}endif;
//	log('Wsdl internal schema referencedSchema '+referencedSchema);
//	log('Wsdl internal schema thisSchema '+thisSchema);
//	log('Wsdl internal schema relativePath '+relativePath);
	contents+=xsdImport;
	xsdImport.schemaLocation:=relativePath;
	/*
			<xsd:schema xmlns:notice="http://www.iir.com/sorna/NIEM/2.1/notification/1.0"
			elementFormDefault="qualified" attributeFormDefault="unqualified">
			<xsd:import namespace="http://www.iir.com/sorna/NIEM/2.1/notification/1.0"
				schemaLocation="../information/XMLschemas/exchange/RelNotice.xsd" />
		</xsd:schema>
	*/
	definition.eTypes.eExtensibilityElements+=result.map XSDSchemaExtensibilityElement();
}

mapping XSD::XSDSchema::XSDSchemaExtensibilityElement():WSDL::XSDSchemaExtensibilityElement@wsdl{
	schema:=self;
}
mapping UML::Package::NamespaceGRA():XSD::XSDSchema
	inherits UML::Package::XSDSchema
{
	
	var catalog:UML::Package:=sppCatalogUml.getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=self.qualifiedName;
	}else{
		relativePath:=self.qualifiedName.substringAfter(catalog.qualifiedName);
		if(relativePath.oclIsUndefined())then{
			var targetPath:String=self.qualifiedName.substringAfter(catalog.nestingPackage.qualifiedName);// TODO: should be relative to package above MPD
			relativePath:='artifacts::service model::information model::'+targetPath;
		}endif;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}else{relativePath:='.'+relativePath;}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	schemaLocation:=relativePath;
	log("added schema for uml package "+self.qualifiedName);
}
// overrides
query UML::Classifier::isObjectType():Boolean=
	self.oclIsKindOf(UML::Class);

mapping UML::Property::TopLevelElement_declarationGRA(inout psmClass:XSD::XSDSchema):XSD::XSDElementDeclaration
		inherits UML::Property::XSDElementDeclaration_topLevel
{
	typeDefinition:=self.type.oclAsType(UML::Classifier).toPsmClassifier();
}


mapping UML::Package::Import(referencingPackage:UML::Namespace,definition:WSDL::Definition):WSDL::Import@wsdl
{
	
	//eSchema:=self.map Schema();
	var xsdSchema:XSD::XSDSchema=self.toPsmPackage();
	eSchema:=xsdSchema;
	namespaceURI:=xsdSchema.targetNamespace;
	locationURI:=self.getRelativeWsdlLocation(referencingPackage);
}
/////////////////////////////////////////Annotations
query UML::InstanceSpecification::getStringValue(featureName:String):String=
	self.getStringValues(featureName)->first();
query UML::InstanceSpecification::getStringValues(featureName:String):Sequence(String)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralString).value->asSequence();
query UML::InstanceSpecification::getIntegerValue(featureName:String):Integer=
	self.getIntegerValues(featureName)->first();
query UML::InstanceSpecification::getIntegerValues(featureName:String):Sequence(Integer)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralInteger).value->asSequence();
query UML::InstanceSpecification::getBooleanValue(featureName:String):Boolean=
	self.getBooleanValues(featureName)->first();
query UML::InstanceSpecification::getBooleanValues(featureName:String):Sequence(Boolean)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralBoolean).value->asSequence();
query UML::InstanceSpecification::getInstanceValue(featureName:String):UML::InstanceSpecification=
	self.getInstanceValues(featureName)->first();
query UML::InstanceSpecification::getInstanceValues(featureName:String):Sequence(UML::InstanceSpecification)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::InstanceValue).instance->asSequence();
query UML::InstanceSpecification::getRealValue(featureName:String):Real=
	self.getRealValues(featureName)->first();
query UML::InstanceSpecification::getRealValues(featureName:String):Sequence(Real)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralReal).value->asSequence();
mapping 	UML::InstanceSpecification::GRAServiceAnnotationBase():GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	template:=self.getStringValue('Template');
	flag+=self.getStringValues('Flag');
	//  derived
	//name:=self.getStringValue('Name');
	//documentation:=self.getStringValue('Documentation');
	//if(result.name.oclIsUndefined())then{
		name:=self.name;
	//}endif;
	//if(result.documentation.oclIsUndefined())then{
		documentation:=self.ownedComment.body->asSequence()->first();
	//}endif;
	var realizedElement:UML::NamedElement=self.realizedNamedElement()->asSequence()->first();
	if(result.name.oclIsUndefined()or(result.name=''))then{
		name:=realizedElement.name;
	}endif;
	if(result.documentation.oclIsUndefined())then{
		documentation:=realizedElement.ownedComment.body->asSequence()->first();
	}endif;
	
	modelReference:=realizedElement.map ModelReference(self)->asSequence()->first();
	requirement:=self.getInstanceValue('Requirement').map InteractionRequirements();
}
mapping 	UML::InstanceSpecification::GRAServiceAnnotationBaseDefault(modeledElement:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	template:=self.getStringValue('Template');
	flag+=self.getStringValues('Flag');
	//  derived
	//name:=self.getStringValue('Name');
	//documentation:=self.getStringValue('Documentation');
	//if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=self.name;
	//}endif;
	//if(result.documentation.oclIsUndefined())then{
		documentation:=self.ownedComment.body->asSequence()->first();
	//}endif;
	var realizedElement:UML::NamedElement=self.realizedNamedElement()->asSequence()->first();
	if(result.name.oclIsUndefined() or(result.name=''))then{
		name:=realizedElement.name;
	}endif;
	if(result.documentation.oclIsUndefined())then{
		documentation:=realizedElement.ownedComment.body->asSequence()->first();
	}endif;
	
	modelReference:=realizedElement.map ModelReference(self)->asSequence()->first();
	requirement:=self.getInstanceValue('Requirement').map InteractionRequirements();
}
	
mapping 	UML::NamedElement::ModelReference(context:UML::NamedElement):GRAA::ModelReference@graa 
{
//	name:=self.qualifiedName;
	name:=self.name;
	documentation:=self.ownedComment.body->asSequence()->first();
	elementId:=self.oclAsType(CMOF::EObject).getURIFragment();
	// TODO: diagramLink
	//diagramLink+=self.getStringValues('DiagramLink');
	model:=self.map Model(context);
}
	mapping 	UML::NamedElement::Model(context:UML::NamedElement):GRAA::Model@graa 
{
	modelUri:=self.oclAsType(CMOF::EObject).getURI();
	label:=self.oclAsType(CMOF::EObject).contextURI();
}	
	
mapping 	UML::InstanceSpecification::InteractionRequirements():GRAA::InteractionRequirements@graa 
{

	serviceConsumerAuthentication:=self.getBooleanValue('ServiceConsumerAuthentication');
	serviceConsumerAuthorization:=self.getBooleanValue('ServiceConsumerAutorization');
	identityAndAttributeAssertionTransmission:=self.getBooleanValue('IdentityAndAttributeAssertionTransmission');
	serviceAuthentication:=self.getBooleanValue('ServiceAuthentication');
	messageNonrepudiation:=self.getBooleanValue('MessageNonrepudiation');
	messageIntegrity:=self.getBooleanValue('MessageIntegrity');
	messageConfidentiality:=self.getBooleanValue('MessageConfidentiality');
	messageAddressing:=self.getBooleanValue('MessageAddressing');
	reliability:=self.getBooleanValue('Reliability');
	transactionSupport:=self.getBooleanValue('TransactionSupport');
	serviceMetadataAvailability:=self.getBooleanValue('ServiceMetadataAvailability');
	interfaceDescriptionRequirements:=self.getBooleanValue('InterfaceDescriptionRequirements');
	logging:=self.getBooleanValue('Logging');
	otherRequirement+=self.getStringValues('OtherRequirement');
	serviceResponsiveness:=self.getBooleanValue('ServiceResponsiveness');
	/*
	serviceAssumption+=self.getStringValues('ServiceAssumption');
	executionContext+=self.getStringValues('ExecutionContext');
	security+=self.getStringValues('Security');
	privacy+=self.getStringValues('Privacy');
	*/
	// ServiceResponsiveness	, ServiceAssumption ExecutionContext, Security, Privacy
}	
mapping 	UML::InstanceSpecification::ServiceIdentification():GRAA::ServiceIdentification@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{

	serviceId:=self.getStringValue('ServiceID');
	serviceUri:=self.getStringValue('ServiceURI');
	serviceNameAbbreviationText:=self.getStringValue('ServiceNameAbbreviationText');
}	
	
mapping 	UML::InstanceSpecification::GRA_WSDL():GRAA::ServiceDescription@graa
	inherits UML::InstanceSpecification::ServiceIdentification 
{
		var serviceMetadata:METADATA::ServiceMetadataType=metadataDocument.serviceMetadata->asSequence()->first();
	//log('GRA_WSDL from '+self.qualifiedName);
	serviceDescription:=self.getInstanceValue('ServiceDescription').map Description(self);
	classification+=self.getStringValues('Classification');
	sponsor+=self.getStringValues('Sponsor');
	servicePurpose:=self.getInstanceValue('ServicePurpose').map Description(self);
	serviceDescriptionSummaryText:=self.getStringValue('ServiceDescriptionSummaryText');
	serviceDescriptionKeywordText+=self.getStringValues('ServiceDescriptionKeywordText');
	domainDescription:=self.getStringValue('DomainDescription');
	endorsements+=self.getStringValues('Endorsements');
	transformationUri:=self.getStringValue('TransformationURI');
	majorVersion:=self.getIntegerValue('MajorVersion');
	minorVersion:=self.getIntegerValue('MinorVersion');
	revisionVersion:=self.getIntegerValue('RevisionVersion');
	creationDate:=self.getStringValue('CreationDate');
	activationDate:=self.getStringValue('ActivationDate');
	lastRevisionDate:=self.getStringValue('LastRevisionDate');
	nextRevisionDate:=self.getStringValue('NextRevisionDate');
	expirationDate:=self.getStringValue('ExpirationDate');
	lifecycleStatus:=self.getStringValue('LifecycleStatus');
//	alertsAndNotifications+=self.getStringValues('AlertsAndNotifications');
	alertAndNotificationUri:=self.getStringValue('AlertAndNotificationURI');
	serviceDescriptionUri:=serviceMetadata.SDDhref();
	
	serviceScopeDescription:=self.getInstanceValue('ServiceScopeDescription').map Description(self);

	serviceDependency+=self.getInstanceValues('ServiceDependency').map ServiceIdentification();
	serviceSecurityClassification:=self.getInstanceValue('ServiceSecurityClassification').map SecurityClassification();
	serviceCapability+=self.getInstanceValues('ServiceCapability').map ServiceCapability();
	
	serviceAssumption:=self.getInstanceValue('ServiceAssumption').map Description(self);
	executionContext:=self.getInstanceValue('ExecutionContext').map Description(self);
	security:=self.getInstanceValue('Security').map Description(self);
	privacy:=self.getInstanceValue('Privacy').map Description(self);
	
	
	serviceLevelAgreement+=self.getInstanceValues('ServiceLevelAgreement').map ServiceLevelAgreement();
	serviceInterface+=self.getInstanceValues('ServiceInterface').map AbstractServiceInterfaceSpecification();
	relatedOrganization+=self.getInstanceValues('RelatedOrganization').map Organization();
//	realWorldEffect:=self.getInstanceValue('RealWorldEffect').map UseCase();
	realWorldEffect+=self.getInstanceValues('RealWorldEffect').map UseCase();

	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).supplier->select(s|s.isStereotypeApplied(prompdStereotype)).oclAsType(UML::Component)->forEach(mpd){
		iepdReference+=mpd.map IEPDReference();
	};

	var exchangePartnerInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('ExchangePartner')->asSet();
	exchangePartner+=exchangePartnerInstances.map Participant();
	var collaboration:UML::Collaboration=self.realizedCollaboration()->first();
	var modeledExchangePartners:Set(UML::Actor)=collaboration.role.type->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSet();
	var exchangePartnerRealized:Set(UML::Actor)=self.realizedActor()->asSet();
	modeledExchangePartners
//		->select(p|not(exchangePartnerRealized->includes(p)))
		->forEach(modeledProvider){
		exchangePartner+=modeledProvider.map Participant(modeledProvider);
	};
	var serviceInteractionInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('ServiceInteraction')->asSet();
//	serviceInteraction:=serviceInteractionInstances.map ServiceInteraction(collaboration)->asSequence()->first();
	serviceInteraction+=serviceInteractionInstances.map ServiceInteraction(collaboration)->asSequence()->first();
	var modeledServiceInteractions:Set(UML::Interaction)=collaboration.ownedBehavior->select(t|t.oclIsKindOf(UML::Interaction)).oclAsType(UML::Interaction)->asSet();
	var serviceInteractionRealized:Set(UML::Interaction)=self.realizedInteraction()->asSet();
	if(result.serviceInteraction->isEmpty())then{
		modeledServiceInteractions->select(p|not(serviceInteractionRealized->includes(p)))->forEach(modeledProvider){
			serviceInteraction+=modeledProvider.map ServiceInteraction(modeledProvider);
		};
	}endif;
	
	additionalInformation:=self.getInstanceValues('AdditionalInformation').map Description(self);
	
}	
mapping 	UML::Component::IEPDReference():GRAA::IepdReference@graa 
{
	// derived
	var pimmpd:Stdlib::Element=self.GetStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
	var baseURI:String=pimmpd.getMpdBaseURI();
	var iEPDURL:String=baseURI;
	var iEPDName:String=baseURI.getLastSegmentGRA();
	name:=iEPDName;
	iepdurl:=iEPDURL;
	
}	
mapping 	UML::InstanceSpecification::SecurityClassification():GRAA::SecurityClassification@graa 
{
	// derived
	//securityClassificationText:=self.getStringValue('SecurityClassificationText');
	//if(securityClassificationText.oclIsUndefined())then{
//		securityClassificationText:=self.name;
	//}endif;
		name:=self.name;
}	
mapping 	UML::InstanceSpecification::ServiceCapability():GRAA::ServiceCapability@graa 
{
	// derived
	/*
	capabilityDescriptionText:=self.getStringValue('CapabilityDescriptionText');
	if(capabilityDescriptionText.oclIsUndefined())then{
		capabilityDescriptionText:=self.ownedComment.body->asSequence()->first();
	}endif;
	*/
	documentation:=self.ownedComment.body->asSequence()->first();
}	
mapping 	UML::InstanceSpecification::Description(context:UML::NamedElement):GRAA::Description@graa 
{
	externalDocumentation:=self.getStringValue('ExternalDocumentation');

	// derived
	/*
	description:=self.getStringValue('Description');
	if(description.oclIsUndefined())then{
		description:=self.ownedComment.body->asSequence()->first();
	}endif;
	*/
	documentation:=self.ownedComment.body->asSequence()->first();
}	
mapping 	UML::InstanceSpecification::ServiceLevelAgreement():GRAA::ServiceLevelAgreement@graa 
{
	applicablePoliciesIndicator:=self.getBooleanValue('ApplicablePoliciesIndicator');
	applicableContractsIndicator:=self.getBooleanValue('ApplicableContractsIndicator');
	applicableAgreementsIndicator:=self.getBooleanValue('ApplicableAgreementsIndicator');
	applicableUmbrellaAgreementsIndicator:=self.getBooleanValue('ApplicableUmbrellaAgreementsIndicator');
//	applicablePolicies:=self.getStringValue('ApplicablePolicies');

	ApplicablePolicy+=self.getInstanceValues('ApplicablePolicy').map Description(self);
	approvalRequiredIndicator:=self.getBooleanValue('ApprovalRequiredIndicator');
	licensingRequiredIndicator:=self.getBooleanValue('LicensingRequiredIndicator');
	serviceResponseTime:=self.getStringValue('ServiceResponseTime');
	serviceAverageThroughput:=self.getStringValue('ServiceAverageThroughput');
	serviceMaximumThroughput:=self.getStringValue('ServiceMaximumThroughput');
	serviceAvailability:=self.getStringValue('ServiceAvailability');
	
	umbrellaAgreement+=self.getInstanceValues('UmbrellaAgreement').map Agreement();
	agreement+=self.getInstanceValues('Agreement').map Agreement();
	applicableContract+=self.getInstanceValues('ApplicableContract').map Agreement();
	licensingAgreement:=self.getInstanceValue('LicensingAgreement').map Agreement();
//	usageUnitCostAmount:=self.getInstanceValue('UsageUnitCostAmount').map AmountType();
//	creationCostAmount:=self.getInstanceValue('CreationCostAmount').map AmountType();
//	usageCostAmount:=self.getInstanceValue('UsageCostAmount').map AmountType();
	
	usageUnitCostAmount:=self.getStringValue('UsageUnitCostAmount');
	creationCostAmount:=self.getStringValue('CreationCostAmount');
	usageCostAmount:=self.getStringValue('UsageCostAmount');
}	
/*
	mapping 	UML::InstanceSpecification::AmountType():GRAA::AmountType@graa 
{
	currencyText:=self.getStringValue('CurrencyText');
	value:=self.getRealValue('value');
}	
*/
mapping 	UML::InstanceSpecification::AbstractServiceInterfaceSpecification():GRAA::ServiceInterfaceSpecification@graa 
	disjuncts UML::InstanceSpecification::WSDLServiceInterface,
		 UML::InstanceSpecification::ServiceInterfaceSpecification
		 {}
mapping 	UML::InstanceSpecification::ServiceInterfaceSpecification():GRAA::ServiceInterfaceSpecification@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	init{}
	securityImplementedIndicator:=self.getBooleanValue('SecurityImplementedIndicator');
	securityDescriptionText:=self.getStringValue('SecurityDescriptionText');
//	messageDefinitionMechanism+=self.getStringValues('MessageDefinitionMechanism');
	messageDefinitionMechanism+=self.getInstanceValues('MessageDefinitionMechanism').map Description(self);
	serviceTesting:=self.getInstanceValue('ServiceTesting').map Description(self);
	serviceInteractionProfile:=self.getInstanceValue('ServiceInteractionProfile').map ServiceInteractionProfile();
	var portDefaults:Sequence(UML::InstanceSpecification)=self.getInstanceValues('PortDefault');
	var interfaceDefaults:Sequence(UML::InstanceSpecification)=self.getInstanceValues('InterfaceDefault');
	var operationDefaults:Sequence(UML::InstanceSpecification)=self.getInstanceValues('OperationDefault');
	var parameterDefaults:Sequence(UML::InstanceSpecification)=self.getInstanceValues('ParameterDefault');
	var messageDefaults:Sequence(UML::InstanceSpecification)=self.getInstanceValues('MessageDefault');
	//portDefault+=portDefaults.map AbstractPort(null,Sequence{},Sequence{},Sequence{},Sequence{});
	//interfaceDefault+=interfaceDefaults.map AbstractInterface(null,Sequence{},Sequence{},Sequence{},Sequence{});
	//operationDefault+=operationDefaults.map AbstractOperation(null,Sequence{},Sequence{},Sequence{},Sequence{});
	//messageDefault+=messageDefaults.map AbstractMessage(null,Sequence{},Sequence{},Sequence{},Sequence{});
	// causes illegal operation
	provider+=self.getInstanceValues('Provider').map AbstractService(null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);

	targetNamespace:=self.getStringValue('TargetNamespace');
	prefix:=self.getStringValue('Prefix');
	// derived
	// property: TargetNamespace, Prefix, ServiceInterfaceDescriptionURI
	//uriAddress:='artifacts/Relocation Service Interface/SIRS_SIDD_RSI_v_1.0.0.doc';//self.getStringValue('URIAddress');
	// the wsdlProperty is the property in the collaboration whose type is a component realized by provider instance
	var theServiceComponent:UML::Component=self.getInstanceValues('Provider').realizedComponent()->asSequence()->first();
	var wsdlProperty:UML::Property=	theServiceCollaboration.ownedAttribute
		->select(a|a.type.isServiceIdentification()and(a.type=theServiceComponent))->asSequence()->first();
	
	//var wsdlProperty:UML::Property=null;
	var serviceMetadata:METADATA::ServiceMetadataType=metadataDocument.serviceMetadata->asSequence()->first();
	
	uriAddress:=wsdlProperty.wsdlLocation();
	
//	uriDescription:=wsdlProperty.wsdlDescription();
//	serviceInterfaceDescriptionUri:=self.getStringValue('ServiceInterfaceDescriptionURI');
	serviceInterfaceDescriptionUri:=wsdlProperty.SIDDhref(serviceMetadata);
	// get all referenced schemas
	var schemas:Set(UML::Package)=Set{};
	theServiceComponent.ownedPort.provided.allBehavioralFeatures()->forEach(feature){
		if(feature.oclIsKindOf(UML::Reception))then{
			schemas+=feature.oclAsType(UML::Reception).signal.ownedAttribute.type.getNearestPackage()->select(p|p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype));
		}else{
			schemas+=feature.ownedParameter.type.getNearestPackage()->select(p|p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype));
		}endif;
	};		
			
	
	schemas->forEach(schema){
		schemaReference+=schema.map SchemaReference();
	};
}	
mapping 	UML::Package::SchemaReference():GRAA::SchemaReference@graa 
{
	
	var pimStereotypeInstance:Stdlib::Element=self.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=self.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
	namespace:=pimStereotypeInstance.getSchemaTargetNamespace();
	if(namespace.oclIsUndefined())then{
		namespace:='unknownx';
	}endif;
	// set prefix to be used for Schema namespace
	prefix:=pimStereotypeInstance.getSchemaDefaultPrefix();

	// schemaLocation
	var catalog:UML::Package:=sppCatalogUml.clientDependency.supplier->select(c|c.oclIsKindOf(UML::Component))->asSequence()->first().getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=self.qualifiedName;
	}else{
		var targetPath:String=self.qualifiedName.substringAfter(catalog.qualifiedName);
		if(relativePath.oclIsUndefined())then{
			targetPath:=self.qualifiedName.substringAfter(catalog.nestingPackage.qualifiedName);// TODO: should be relative to package above MPD
		}endif;
		relativePath:='artifacts::service model::information model::'+targetPath;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	schemaLocation:=relativePath;
	
}

mapping 	UML::InstanceSpecification::WSDLServiceInterface():GRAW::WsdlServiceInterface@graa 
	inherits UML::InstanceSpecification::ServiceInterfaceSpecification
	when{self.classifier.name->asSet()->includes('WSDLServiceInterface')}
{
}

	mapping 	UML::InstanceSpecification::Organization():GRAA::Organization@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	organizationAcronym:=self.getStringValue('OrganizationAcronym');
	organizationFullAddressText:=self.getStringValue('OrganizationFullAddressText');
	organizationWebSiteUrl:=self.getStringValue('OrganizationWebSiteURL');
	organizationRoleDescriptionText:=self.getStringValue('OrganizationRoleDescriptionText');
	organizationRoleDetailedDescriptionText:=self.getStringValue('OrganizationRoleDetailedDescriptionText');
	organizationPointOfContact:=self.getInstanceValue('OrganizationPointOfContact').map Person();
}	
	mapping 	UML::InstanceSpecification::OrganizationDefault(modeledElement:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Organization@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
	
{
	organizationAcronym:=self.getStringValue('OrganizationAcronym');
	organizationFullAddressText:=self.getStringValue('OrganizationFullAddressText');
	organizationWebSiteUrl:=self.getStringValue('OrganizationWebSiteURL');
	organizationRoleDescriptionText:=self.getStringValue('OrganizationRoleDescriptionText');
	organizationRoleDetailedDescriptionText:=self.getStringValue('OrganizationRoleDetailedDescriptionText');
	organizationPointOfContact:=self.getInstanceValue('OrganizationPointOfContact').map Person();
}	
	mapping 	UML::InstanceSpecification::Person():GRAA::Person@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	contactPersonEmailId:=self.getStringValue('ContactPersonEmailID');
	contactPersonPhoneNumberId:=self.getStringValue('ContactPersonPhoneNumberID');
	contactPersonAddress:=self.getStringValue('ContactPersonAddress');
}	
	mapping 	UML::InstanceSpecification::Participant():GRAA::Participant@graa 
//	inherits UML::InstanceSpecification::Organization 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	participatingOrganization:=self.getInstanceValue('ParticipatingOrganization').map Organization();
}
	mapping 	UML::Actor::Participant(context:UML::NamedElement):GRAA::Participant@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple
{
	// empty
}
	mapping 	UML::Type::Participant(context:UML::NamedElement):GRAA::Participant@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple
{
	// empty
}

	mapping 	UML::InstanceSpecification::ParticipantDefault(modeledElement:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Participant@graa 
//	inherits UML::InstanceSpecification::OrganizationDefault 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
	
{
	// empty
}
		
	mapping 	UML::InstanceSpecification::UseCase():GRAA::UseCase@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	var providerInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('Provider')->asSet();
	var consumerInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('Consumer')->asSet();
	//  derived
	var useCases:Set(UML::UseCase)=self.realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::UseCase)).oclAsType(UML::UseCase)->asSet();
	//realWorldEffectDescriptionText+=useCases.name;
	
	provider+=providerInstances.map Participant();
	consumer+=consumerInstances.map Participant();

	var realizedProviders:Set(UML::Actor)= providerInstances.realizedActor()->asSet();
	var realizedConsumers:Set(UML::Actor)= consumerInstances.realizedActor()->asSet();
	var modeledProviders:Set(UML::Actor)= useCases.getProviderActors()->asSet();
	var modeledConsumers:Set(UML::Actor)= useCases.getConsumerActors()->asSet();
	
	modeledProviders->select(p|not(realizedProviders->includes(p)))->forEach(modeledProvider){
		provider+=modeledProvider.map Participant(modeledProvider);
	};
	modeledConsumers->select(p|not(realizedConsumers->includes(p)))->forEach(modeledProvider){
		consumer+=modeledProvider.map Participant(modeledProvider);
	};
	
}	

query UML::Element::getProviderAssociation():Set(UML::Association){
	self.getRelationships()
		->select(t|t.oclIsKindOf(UML::Association) and t.getAppliedStereotypes().name->exists(n|n='Provider')).oclAsType(UML::Association)->asSet();
}
query UML::Element::getConsumerAssociation():Set(UML::Association){
	self.getRelationships()
		->select(t|t.oclIsKindOf(UML::Association) and t.getAppliedStereotypes().name->exists(n|n='Consumer')).oclAsType(UML::Association)->asSet();
}
	
query UML::UseCase::getProviderActors():Set(UML::Actor){
	self.getProviderAssociation().ownedEnd.type->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSet();
}
query UML::UseCase::getConsumerActors():Set(UML::Actor){
	self.getConsumerAssociation().ownedEnd.type->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSet();
}

	mapping 	UML::InstanceSpecification::ServiceInteraction():GRAA::ServiceInteraction@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
{
	participant+=self.getInstanceValues('Participant').map Participant();
}	
mapping 	UML::InstanceSpecification::ServiceInteraction(context:UML::Collaboration):GRAA::ServiceInteraction@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple 
{
	var modeledParticipants:Set(UML::Type)=context.ownedBehavior
		->select(t|t.oclIsKindOf(UML::Interaction)).oclAsType(UML::Interaction).lifeline.represents.type->asSet();
	var participants:Sequence(UML::InstanceSpecification)=self.getInstanceValues('Participant');
	participant+=participants.map Participant();
	var participantsRealized:Set(UML::Type)=participants.realizedType()->asSet();
	modeledParticipants->select(p|not(participantsRealized->includes(p)))->forEach(modeledParticipant){
		participant+=modeledParticipant.map Participant(modeledParticipant);
	};
	
}	
mapping 	UML::Interaction::ServiceInteraction(context:UML::NamedElement):GRAA::ServiceInteraction@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple 
{
//	participant+=self.getInstanceValues('participant').map Participant();
	var types:Set(UML::Type)=self.lifeline.represents.type->asSet();
	types->forEach(type){
		participant+=type.map Participant(type);
	};
}	


mapping 	UML::InstanceSpecification::AbstractService(modeledComponent:UML::Component,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Service@graa 
	disjuncts UML::InstanceSpecification::WSDLService,
		 UML::InstanceSpecification::Service
		 {}
mapping 	UML::InstanceSpecification::WSDLService(modeledComponent:UML::Component,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlService@graa 
	inherits UML::InstanceSpecification::Service
	when{self.classifier.name->asSet()->includes('WSDLService')}
{
}

	mapping 	UML::InstanceSpecification::Service(modeledComponent:UML::Component,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Service@graa 
	//inherits UML::InstanceSpecification::ParticipantDefault 
{

	var interfaceDefaultsx:Sequence(UML::InstanceSpecification)=self.getInstanceValues('InterfaceDefault');
	var operationDefaultsx:Sequence(UML::InstanceSpecification)=self.getInstanceValues('OperationDefault');
	var parameterDefaultsx:Sequence(UML::InstanceSpecification)=self.getInstanceValues('ParameterDefault');
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getInstanceValues('MessageDefault');

	var interfaceDefaultsy:Sequence(UML::InstanceSpecification)=interfaceDefaults;
	var operationDefaultsy:Sequence(UML::InstanceSpecification)=operationDefaults;
	var parameterDefaultsy:Sequence(UML::InstanceSpecification)=parameterDefaults;
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(interfaceDefaultsx->notEmpty())then{interfaceDefaultsy:=interfaceDefaultsx;}endif;
	if(operationDefaultsx->notEmpty())then{operationDefaultsy:=operationDefaultsx;}endif;
	if(parameterDefaultsx->notEmpty())then{parameterDefaultsy:=parameterDefaultsx;}endif;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;

	//interfaceDefault+=interfaceDefaultsx.map AbstractInterface(null,Sequence{},Sequence{},Sequence{},Sequence{});

	/* causes illegal operation ?
	operationDefault+=operationDefaultsx.map AbstractOperation(null,Sequence{},Sequence{},Sequence{},Sequence{});
	*/
	//messageDefault+=messageDefaultsx.map AbstractMessage(null,Sequence{},Sequence{},Sequence{},Sequence{});
	
	// add explicitly modeled ports; if not modeled, add implicit ports
	var portInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Port')->asSet();
	var portsRealized:Set(UML::Port)= portInstances.realizedPort()->asSet();
	var serviceComponent:UML::Component=self.realizedComponent()->first();
	if(not(modeledComponent.oclIsUndefined()))then{
		serviceComponent:=modeledComponent;
	}endif;
	
	var modeledPorts:Set(UML::Port)= serviceComponent.ownedPort;
	port+=portInstances.map AbstractPort(null,portDefaults,interfaceDefaultsy,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
	//port+=portInstances.map AbstractPort(null,portDefaults,interfaceDefaults,operationDefaults,messageDefaults);
	modeledPorts->select(p|not(portsRealized->includes(p)))->forEach(modeledPort){
		if(portDefaults->notEmpty())then{
			port+=portDefaults.map AbstractPort(modeledPort,portDefaults,interfaceDefaultsy,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
			//port+=portDefaults.map AbstractPort(modeledPort,portDefaults,interfaceDefaults,operationDefaults,messageDefaults);
		}else{
			port+=modeledPort.mapImplicitPort(modeledPort,portDefaults,interfaceDefaultsy,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
		}endif;
	};
		//Plus SampleData, each with an optional Input and ExpectedOutput
	sampleData+=self.getInstanceValues('SampleData').map SampleData();
	
	
}	
mapping 	UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple(context:UML::NamedElement):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	//  derived
	name:=self.name;
	documentation:=self.ownedComment.body->asSequence()->first();
	//modelReference+=self.map ModelReference(self);
	modelReference:=self.map ModelReference(self);
}	
mapping 	UML::NamedElement::ImplicitGRAServiceAnnotationBase(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	//  derived
	name:=self.name;
	documentation:=self.ownedComment.body->asSequence()->first();
	//modelReference+=self.map ModelReference(self);
	modelReference:=self.map ModelReference(self);
}	
helper 	UML::Port::mapImplicitPort(context:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port{
	// find instance which is WSDLPort or Port
	// if none, check defaults
	// if none, do implicitPorte
	var resultOperation:GRAA::Port=null;
	// check for WSDLPort
	self.realizingInstance('WSDLPort')->forEach(wsdlPort){
		return wsdlPort.map AbstractPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check for Port
	self.realizingInstance('Port')->forEach(wsdlPort){
		return wsdlPort.map AbstractPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check operationDefaults
	portDefaults->forEach(wsdlPort){
		return wsdlPort.map AbstractPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	return self.map ImplicitPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
} 

	mapping 	UML::Port::ImplicitPort(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
	interface+=self.provided.mapImplicitInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=self.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=self.type.name;
		}endif;
	}endif;
}	
mapping 	UML::InstanceSpecification::AbstractPort(modeledPort:UML::Port,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port@graa 
	disjuncts UML::InstanceSpecification::WSDLPort,
		 UML::InstanceSpecification::Port
		 {}
mapping 	UML::InstanceSpecification::WSDLPort(modeledPort:UML::Port,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlPort@graa 
	inherits UML::InstanceSpecification::Port
	when{self.classifier.name->asSet()->includes('WSDLPort')}
{
		certificate:=self.getStringValue('Certificate');

}
	mapping 	UML::InstanceSpecification::Port(modeledPort:UML::Port,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{
	
	var operationDefaultsx:Sequence(UML::InstanceSpecification)=self.getInstanceValues('OperationDefault');
	var parameterDefaultsx:Sequence(UML::InstanceSpecification)=self.getInstanceValues('ParameterDefault');
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getInstanceValues('MessageDefault');
	//operationDefault+=operationDefaultsx.map AbstractOperation(null,Sequence{},Sequence{},Sequence{},Sequence{});
	//messageDefault+=messageDefaultsx.map AbstractMessage(null,Sequence{},Sequence{},Sequence{},Sequence{});
	
	var operationDefaultsy:Sequence(UML::InstanceSpecification)=operationDefaults;
	var parameterDefaultsy:Sequence(UML::InstanceSpecification)=parameterDefaults;
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(operationDefaultsx->notEmpty())then{operationDefaultsy:=operationDefaultsx;}endif;
	if(parameterDefaultsx->notEmpty())then{parameterDefaultsy:=parameterDefaultsx;}endif;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;
	
	
	addressUri:=self.getStringValue('AddressURI');
	// add explicitly modeled interfaces; if not modeled, add implicit interfaces
	var interfaceInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Interface')->asSet();
	var interfacesRealized:Set(UML::Interface)= interfaceInstances.realizedInterface()->asSet();
	var servicePorts:Set(UML::Port)=self.realizedPort()->asSet();
	if(not(modeledPort.oclIsUndefined()))then{
		servicePorts:=Set{modeledPort};
	}endif;
	
	var modeledInterfaces:Set(UML::Interface)= servicePorts.provided->asSet();
	interface+=interfaceInstances.map AbstractInterface(null,portDefaults,interfaceDefaults,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
	modeledInterfaces->select(p|not(interfacesRealized->includes(p)))->forEach(modeledInterface){
		if(interfaceDefaults->notEmpty())then{
			interface+=interfaceDefaults.map AbstractInterface(modeledInterface,portDefaults,interfaceDefaults,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
		}else{
			interface+=modeledInterface.mapImplicitInterface(modeledPort,portDefaults,interfaceDefaults,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
		}endif;
		
	};
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=servicePorts.name->asSequence()->first();
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=servicePorts.type.name->asSequence()->first();
		}endif;
	}endif;
}	
helper 	UML::Interface::mapImplicitInterface(context:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface{
	// find instance which is WSDLInterface or Interface
	// if none, check defaults
	// if none, do implicitInterface
	var resultOperation:GRAA::Interface=null;
	// check for WSDLOperation
	self.realizingInstance('WSDLInterface')->forEach(wsdlInterface){
		return wsdlInterface.map AbstractInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check for Operation
	self.realizingInstance('Interface')->forEach(wsdlInterface){
		return wsdlInterface.map AbstractInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check InterfaceDefaults
	interfaceDefaults->forEach(operationDefault){
		return operationDefault.map AbstractInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	return self.map ImplicitInterface(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
} 

	mapping 	UML::Interface::ImplicitInterface(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
	self.allBehavioralFeatures()->forEach(behavioralFeature){
		operation+=behavioralFeature.mapImplicitOperation(behavioralFeature,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
}	
mapping 	UML::InstanceSpecification::AbstractInterface(modeledInterface:UML::Interface,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface@graa 
	disjuncts UML::InstanceSpecification::WSDLInterface,
		 UML::InstanceSpecification::Interface
		 {}
mapping 	UML::InstanceSpecification::WSDLInterface(modeledInterface:UML::Interface,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlInterface@graa 
	inherits UML::InstanceSpecification::Interface
	when{self.classifier.name->asSet()->includes('WSDLInterface')}
{
		var bindingName:String=self.getInstanceValue('BindingCode').name;
		switch{
			case(bindingName='soap'){
				bindingCode:=GRAW::BindingType::soap;
			};	
			case(bindingName='soap12'){
				bindingCode:=GRAW::BindingType::soap12;
			};	
			case(bindingName='http_get'){
				bindingCode:=GRAW::BindingType::httpGet;
			};	
			case(bindingName='http_put'){
				bindingCode:=GRAW::BindingType::httpPut;
			};	
		};
	
}
	mapping 	UML::InstanceSpecification::Interface(modeledInterface:UML::Interface,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{

	var parameterDefaultsx:Sequence(UML::InstanceSpecification)=self.getInstanceValues('ParameterDefault');
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getInstanceValues('MessageDefault');
	//messageDefault+=messageDefaultsx.map AbstractMessage(null,Sequence{},Sequence{},Sequence{},Sequence{});
	var parameterDefaultsy:Sequence(UML::InstanceSpecification)=parameterDefaults;
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(parameterDefaultsx->notEmpty())then{parameterDefaultsy:=parameterDefaultsx;}endif;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;
	
	
	
	// add explicitly modeled operations; if not modeled, add implicit operations
	var operationInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Operation')->asSet();
	var operationsRealized:Set(UML::BehavioralFeature)= operationInstances.realizedBehavioralFeature()->asSet();
	var serviceInterfaces:Set(UML::Interface)=self.realizedInterface()->asSet();
	if(not(modeledInterface.oclIsUndefined()))then{
		serviceInterfaces:=Set{modeledInterface};
	}endif;
	var modeledOperations:Set(UML::BehavioralFeature)= serviceInterfaces.allBehavioralFeatures()->asSet();
	operation+=operationInstances.map AbstractOperation(null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaultsy,messageDefaultsy);
	modeledOperations->select(p|not(operationsRealized->includes(p)))->forEach(modeledOperation){
		if(operationDefaults->notEmpty())then{
			operation+=operationDefaults.map AbstractOperation(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaultsy,messageDefaultsy);
		}else{
			operation+=modeledOperation.mapImplicitOperation(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
		}endif;
		
		
	};
}	
// TODO: make abstract, pass in defaults, disjunct to wsdl if necessary
// could be via realization or default,
// if nothing than as ImplicitOperation now
helper 	UML::BehavioralFeature::mapImplicitOperation(context:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation{
	// find instance which is WSDLOperation or Operation
	// if none, check defaults
	// if none, do implicitOperation
	var resultOperation:GRAA::Operation=null;
	// check for WSDLOperation
	self.realizingInstance('WSDLOperation')->forEach(wsdlOperation){
		return wsdlOperation.map AbstractOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check for Operation
	self.realizingInstance('Operation')->forEach(wsdlOperation){
		return wsdlOperation.map AbstractOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check operationDefaults
	operationDefaults->forEach(operationDefault){
		return operationDefault.map AbstractOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	return self.map ImplicitOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
} 

	mapping 	UML::BehavioralFeature::ImplicitOperation(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
	actionName:=self.name;
	if(self.oclIsKindOf(UML::Reception))then{
//		message+=self.oclAsType(UML::Reception).signal.ownedAttribute.map ImplicitMessage(self);
		parameter+=self.oclAsType(UML::Reception).signal.ownedAttribute.mapImplicitParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
		if(result.name.oclIsUndefined()or (result.name=''))then{
			name:=self.oclAsType(UML::Reception).signal.name;
		}endif;
		if(result.actionName.oclIsUndefined()or (result.actionName=''))then{
			actionName:=self.oclAsType(UML::Reception).signal.name;
		}endif;
	}else{
//		message+=self.ownedParameter.map ImplicitMessage(self);
		parameter+=self.ownedParameter.mapImplicitParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	}endif;
//	isAsyncronous:=self.oclIsKindOf(UML::Reception);
	isAsynchronous:=self.oclIsKindOf(UML::Reception);
	actionPurpose:=self.ownedComment.body->asSequence()->first();
}

mapping 	UML::InstanceSpecification::AbstractOperation(modeledOperation:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation@graa 
	disjuncts UML::InstanceSpecification::WSDLOperation,
		 UML::InstanceSpecification::Operation
		 {}
mapping 	UML::InstanceSpecification::WSDLOperation(modeledOperation:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlOperation@graa 
	inherits UML::InstanceSpecification::Operation
	when{self.classifier.name->asSet()->includes('WSDLOperation')}
{
		var kindName:String=self.getInstanceValue('OperationKindCode').name;
		switch{
			case(kindName='doc'){
				operationKindCode:=GRAW::OperationKind::doc;
			};	
			case(kindName='rpc'){
				operationKindCode:=GRAW::OperationKind::rpc;
			};	
		};
}

	
	mapping 	UML::InstanceSpecification::Operation(modeledOperation:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getInstanceValues('MessageDefault');
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;
	// add explicitly modeled messages; if not modeled, add implicit messages
//	var messageInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('message')->asSet();
	var messageInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Parameter')->asSet();
	var messagesRealized:Set(UML::TypedElement)= messageInstances.realizedTypedElement()->asSet();
	var serviceOperations:Set(UML::BehavioralFeature)=self.realizedBehavioralFeature()->asSet();
	if(not(modeledOperation.oclIsUndefined()))then{
		serviceOperations:=Set{modeledOperation};
	}endif;
		actionName:=serviceOperations.name->asSequence()->first();
//	var modeledMessages:Set(UML::Parameter)= serviceOperations.ownedParameter->asSet();
	var modeledMessages:Set(UML::TypedElement)= Set{};
	
	if(modeledOperation.oclIsKindOf(UML::Reception))then{
		modeledMessages+=modeledOperation.oclAsType(UML::Reception).signal.ownedAttribute;
		if(result.name.oclIsUndefined()or (result.name=''))then{
			name:=modeledOperation.oclAsType(UML::Reception).signal.name;
		}endif;
		if(result.actionName.oclIsUndefined()or (result.actionName=''))then{
			actionName:=modeledOperation.oclAsType(UML::Reception).signal.name;
		}endif;
	}else{
		modeledMessages+=modeledOperation.ownedParameter;
	}endif;
	
//	message+=messageInstances.map AbstractMessage(null,portDefaults,interfaceDefaults,operationDefaults,messageDefaults);
//	parameter+=messageInstances.map AbstractMessage(null,portDefaults,interfaceDefaults,operationDefaults,messageDefaults);
	parameter+=messageInstances.map AbstractParameter(null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
	modeledMessages->select(p|not(messagesRealized->includes(p)))->forEach(modeledMessage){
		if(messageDefaults->notEmpty())then{
//			message+=messageDefaults.map AbstractMessage(modeledMessage,portDefaults,interfaceDefaults,operationDefaults,messageDefaults);
//			parameter+=messageDefaults.map AbstractMessage(modeledMessage,portDefaults,interfaceDefaults,operationDefaults,messageDefaults);
			parameter+=messageDefaults.map AbstractParameter(modeledMessage,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
		}else{
//			message+=modeledMessage.map ImplicitMessage(self);
			parameter+=modeledMessage.mapImplicitParameter(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
		}endif;
	};
//	messageExchangePattern:=self.getInstanceValue('MessageExchangePattern').oclAsType(graAnnotationModel::ExchangePattern);
		var messageExchangePatternName:String=self.getInstanceValue('MessageExchangePattern').name;
		switch{
			case(messageExchangePatternName='enquiry'){
				messageExchangePattern:=GRAA::ExchangePattern::enquiry;
			};	
			case(messageExchangePatternName='subscription'){
				messageExchangePattern:=GRAA::ExchangePattern::subscription;
			};	
			case(messageExchangePatternName='notification'){
				messageExchangePattern:=GRAA::ExchangePattern::notification;
			};	
			case(messageExchangePatternName='update'){
				messageExchangePattern:=GRAA::ExchangePattern::update;
			};	
			case(messageExchangePatternName='message'){
				messageExchangePattern:=GRAA::ExchangePattern::message;
			};	
		};
		//log('messageExchangePattern '+result.messageExchangePattern.name);

	/*
	testingOption:=self.getStringValue('TestingOption');
	testingPrerequisite:=self.getStringValue('TestingPrerequisite');
	testEndpoint:=self.getStringValue('TestEndpoint');
	environmentalRequirement:=self.getStringValue('EnvironmentalRequirement');
	testSchedule:=self.getStringValue('TestSchedule');
	controlProcedure:=self.getStringValue('ControlProcedure');
	*/
	actionProvenance:=self.getStringValue('ActionProvenance');

	//Plus SampleData, each with an optional Input and ExpectedOutput
	//sampleData+=self.getInstanceValues('sampleData').map SampleData();
	
	// derived
//	isAsyncronous:=self.getBooleanValue('isAsyncronous');
//	isAsyncronous:=self.getBooleanValue('isAsyncronous');
	//actionName:=self.getStringValue('ActionName');
	//actionPurpose:=self.getStringValue('ActionPurpose');
		
//	if(isAsyncronous.oclIsUndefined())then{
//		isAsyncronous:=serviceOperations->exists(p|p.oclIsKindOf(UML::Reception));
		isAsynchronous:=serviceOperations->exists(p|p.oclIsKindOf(UML::Reception));
//	}endif;
	
	//if(result.actionPurpose.oclIsUndefined())then{
		actionPurpose:=serviceOperations.ownedComment.body->asSequence()->first();
	//}endif;
}
	mapping 	UML::InstanceSpecification::SampleData():GRAA::SampleData@graa 
{
	// Input, ExpectedOutput
//	input:=self.getStringValue('Input');
	input+=self.getStringValues('Input');
	expectedOutput:=self.getStringValue('ExpectedOutput');
}	
helper 	UML::TypedElement::mapImplicitParameter(context:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter{
	// find instance which is WSDLOperation or Operation
	// if none, check defaults
	// if none, do implicitOperation
	var resultOperation:GRAA::Parameter=null;
	// check for WSDLOperation
	self.realizingInstance('WSDLParameter')->forEach(wsdlParameter){
		return wsdlParameter.map AbstractParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check for Operation
	self.realizingInstance('Parameter')->forEach(wsdlParameter){
		return wsdlParameter.map AbstractParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check operationDefaults
	parameterDefaults->forEach(operationDefault){
		return operationDefault.map AbstractParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	return self.map ImplicitParameter(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
} 

//	mapping 	UML::Parameter::ImplicitMessage(context:UML::NamedElement):GRAA::Message@graa 
	mapping 	UML::TypedElement::ImplicitParameter(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
		//namespace:='unknown';
	//type:=self.type.map ModelReference(self);
	
	if(self.oclIsKindOf(UML::Parameter))then{	
	//  derived
	switch{
		case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_out){
//			use:=graAnnotationModel::MessageUse::_out;
			use:=graAnnotationModel::ParameterUse::_out;
		};
		case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_inout){
//			use:=graAnnotationModel::MessageUse::_out;
			use:=graAnnotationModel::ParameterUse::_out;
		};
		else{
//			use:=graAnnotationModel::MessageUse::_in;
			use:=graAnnotationModel::ParameterUse::_in;
		};
	};
	}else{
//		use:=graAnnotationModel::MessageUse::_in;
		use:=graAnnotationModel::ParameterUse::_in;
	}endif;

	var messagetype:UML::Type=self.type;
	/*
	var typePackage:UML::Package=messagetype.getNearestPackage();
	var pimStereotypeInstance:Stdlib::Element=typePackage.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=typePackage.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
	namespace:=pimStereotypeInstance.getSchemaTargetNamespace();
	if(namespace.oclIsUndefined())then{
		namespace:='unknown';
	}endif;
	// set prefix to be used for Schema namespace
	
	prefix:=pimStereotypeInstance.getSchemaDefaultPrefix();
	typeName:=messagetype.name;
	*/
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=self.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=messagetype.name;
		}endif;
	}endif;
	message:=messagetype.mapImplicitMessage(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	
	/*
	// schemaLocation
	var catalog:UML::Package:=sppCatalogUml.clientDependency.supplier->select(c|c.oclIsKindOf(UML::Component))->asSequence()->first().getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=typePackage.qualifiedName;
	}else{
		var targetPath:String=typePackage.qualifiedName.substringAfter(catalog.qualifiedName);
		if(relativePath.oclIsUndefined())then{
			targetPath:=typePackage.qualifiedName.substringAfter(catalog.nestingPackage.qualifiedName);// TODO: should be relative to package above MPD
		}endif;
		relativePath:='artifacts::service model::information model::'+targetPath;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}else{relativePath:='.'+relativePath;}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	schemaLocation:=relativePath;
	*/
}	
mapping 	UML::InstanceSpecification::AbstractParameter(modeledMessage:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter@graa 
	disjuncts UML::InstanceSpecification::WSDLParameter,
		 UML::InstanceSpecification::Parameter
		 {}
mapping 	UML::InstanceSpecification::WSDLParameter(modeledMessage:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlParameter@graa 
	inherits UML::InstanceSpecification::Parameter
	when{self.classifier.name->asSet()->includes('WSDLParameter')}
{
	/*
		var locationCodeName:String=self.getInstanceValue('MessageLocationCode').name;
		switch{
			case(locationCodeName='body'){
				messageLocationCode:=GRAW::MessageLocation::body;
			};	
			case(locationCodeName='header'){
				messageLocationCode:=GRAW::MessageLocation::header;
			};	
			case(locationCodeName='url'){
				messageLocationCode:=GRAW::MessageLocation::url;
			};	
		};
	encoding:=self.getStringValue('encoding');
	*/
	mimeType:=self.getStringValue('mimeType');
	//soapAction:=self.getStringValue('soapAction');

}
	mapping 	UML::InstanceSpecification::Parameter(modeledMessage:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{
	//	namespace:='unknownx';
	// add type; derived
	var messageRealized:UML::TypedElement= self.realizedTypedElement()->asSequence()->first();
	if(modeledMessage.oclIsUndefined())then{
		
	}else{
		messageRealized:=modeledMessage;
	}endif;
	messageRealized->forEach(parameter){
//		type:=parameter.type.map ModelReference(self);
		//  derived
		if(parameter.oclIsKindOf(UML::Parameter))then{	
			switch{
				case(parameter.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_out){
					//use:=graAnnotationModel::MessageUse::_out;
					use:=graAnnotationModel::ParameterUse::_out;
				};
				case(parameter.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_inout){
					//use:=graAnnotationModel::MessageUse::_out;
					use:=graAnnotationModel::ParameterUse::_out;
				};
				else{
					//use:=graAnnotationModel::MessageUse::_in;
					use:=graAnnotationModel::ParameterUse::_in;
				};
			};
		}else{
					//use:=graAnnotationModel::MessageUse::_in;
					use:=graAnnotationModel::ParameterUse::_in;
		}	endif;
	};
	var messagetype:UML::Type=messageRealized.type;
	/*
	var typePackage:UML::Package=messagetype.getNearestPackage();
	var pimStereotypeInstance:Stdlib::Element=typePackage.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=typePackage.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
	namespace:=pimStereotypeInstance.getSchemaTargetNamespace();
	if(namespace.oclIsUndefined())then{
		namespace:='unknownx';
	}endif;
	// set prefix to be used for Schema namespace
	prefix:=pimStereotypeInstance.getSchemaDefaultPrefix();
*/
//	dataProvenance:=self.getInstanceValue('DataProvenance').map Organization();
	dataProvenance:=self.getStringValue('DataProvenance');
//	typeName:=messagetype.name;
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=messageRealized.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=messagetype.name;
		}endif;
	}endif;
	var messageInstances:UML::InstanceSpecification= self.getInstanceValue('Message');
	if(messageInstances.oclIsUndefined())then{
		message:=messagetype.mapImplicitMessage(messageRealized,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	}else{
		message:=messageInstances.map AbstractMessage(messagetype,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	}endif;
	/*
	
	// schemaLocation
	var catalog:UML::Package:=sppCatalogUml.clientDependency.supplier->select(c|c.oclIsKindOf(UML::Component))->asSequence()->first().getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=typePackage.qualifiedName;
	}else{
		var targetPath:String=typePackage.qualifiedName.substringAfter(catalog.qualifiedName);
		if(relativePath.oclIsUndefined())then{
			targetPath:=typePackage.qualifiedName.substringAfter(catalog.nestingPackage.qualifiedName);// TODO: should be relative to package above MPD
		}endif;
		relativePath:='artifacts::service model::information model::'+targetPath;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	schemaLocation:=relativePath;
	*/
//	elementName:=self.getStringValue('ElementName');
	 
	
}	

///////////////////////////////////////////////////////////////////////////////////////////////////	
helper 	UML::Type::mapImplicitMessage(context:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message{
	// find instance which is WSDLOperation or Operation
	// if none, check defaults
	// if none, do implicitOperation
	var resultOperation:GRAA::Message=null;
	// check for WSDLOperation
	self.realizingInstance('WSDLMessage')->forEach(wsdlMessage){
		return wsdlMessage.map AbstractMessage(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check for Operation
	self.realizingInstance('Message')->forEach(wsdlMessage){
		return wsdlMessage.map AbstractMessage(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check operationDefaults
	messageDefaults->forEach(wsdlMessage){
		return wsdlMessage.map AbstractMessage(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	return self.map ImplicitMessage(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
} 

//	mapping 	UML::Parameter::ImplicitMessage(context:UML::NamedElement):GRAA::Message@graa 
//	mapping 	UML::TypedElement::ImplicitMessage(context:UML::NamedElement):GRAA::Message@graa 
	mapping 	UML::Type::ImplicitMessage(context:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
		//namespace:='unknown';
	//type:=self.type.map ModelReference(self);
	/*
	if(self.oclIsKindOf(UML::Parameter))then{	
	//  derived
	switch{
		case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_out){
			use:=graAnnotationModel::MessageUse::_out;
		};
		case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_inout){
			use:=graAnnotationModel::MessageUse::_out;
		};
		else{
			use:=graAnnotationModel::MessageUse::_in;
		};
	};
	}else{
		use:=graAnnotationModel::MessageUse::_in;
	}endif;
	*/
	var messagetype:UML::Type=self;
	var typePackage:UML::Package=messagetype.getNearestPackage();
	var pimStereotypeInstance:Stdlib::Element=typePackage.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=typePackage.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
	/*
	namespace:=pimStereotypeInstance.getSchemaTargetNamespace();
	if(namespace.oclIsUndefined())then{
		namespace:='unknown';
	}endif;
	*/
	// set prefix to be used for Schema namespace
	prefix:=pimStereotypeInstance.getSchemaDefaultPrefix();
	name:=messagetype.name;
	/*
	typeName:=messagetype.name;
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=self.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=result.typeName;
		}endif;
	}endif;
	
	// schemaLocation
	var catalog:UML::Package:=sppCatalogUml.clientDependency.supplier->select(c|c.oclIsKindOf(UML::Component))->asSequence()->first().getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=typePackage.qualifiedName;
	}else{
		var targetPath:String=typePackage.qualifiedName.substringAfter(catalog.qualifiedName);
		if(relativePath.oclIsUndefined())then{
			targetPath:=typePackage.qualifiedName.substringAfter(catalog.nestingPackage.qualifiedName);// TODO: should be relative to package above MPD
		}endif;
		relativePath:='artifacts::service model::information model::'+targetPath;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}else{relativePath:='.'+relativePath;}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	schemaLocation:=relativePath;
	*/
}	
mapping 	UML::InstanceSpecification::AbstractMessage(modeledMessage:UML::Type,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message@graa 
	disjuncts UML::InstanceSpecification::WSDLMessage,
		 UML::InstanceSpecification::Message
		 {}
mapping 	UML::InstanceSpecification::WSDLMessage(modeledMessage:UML::Type,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlMessage@graa 
	inherits UML::InstanceSpecification::Message
	when{self.classifier.name->asSet()->includes('WSDLMessage')}
{
		var locationCodeName:String=self.getInstanceValue('MessageLocationCode').name;
		switch{
			case(locationCodeName='body'){
				messageLocationCode:=GRAW::MessageLocation::body;
			};	
			case(locationCodeName='header'){
				messageLocationCode:=GRAW::MessageLocation::header;
			};	
			case(locationCodeName='url'){
				messageLocationCode:=GRAW::MessageLocation::url;
			};	
		};
	encoding:=self.getStringValue('Encoding');
//	mimeType:=self.getStringValue('mimeType');
	soapAction:=self.getStringValue('SoapAction');

}
//	mapping 	UML::InstanceSpecification::Message(modeledMessage:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	mapping 	UML::InstanceSpecification::Message(modeledMessage:UML::Type,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{
	//	namespace:='unknownx';
	// add type; derived
//	var messageRealized:UML::TypedElement= self.realizedTypedElement()->asSequence()->first();
	var messageRealized:UML::Type= self.realizedType()->asSequence()->first();
	if(modeledMessage.oclIsUndefined())then{
		
	}else{
		messageRealized:=modeledMessage;
	}endif;
	/*
	messageRealized->forEach(parameter){
		type:=parameter.type.map ModelReference(self);
		//  derived
		if(parameter.oclIsKindOf(UML::Parameter))then{	
			switch{
				case(parameter.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_out){
					use:=graAnnotationModel::MessageUse::_out;
				};
				case(parameter.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_inout){
					use:=graAnnotationModel::MessageUse::_out;
				};
				else{
					use:=graAnnotationModel::MessageUse::_in;
				};
			};
		}else{
					use:=graAnnotationModel::MessageUse::_in;
		}	endif;
	};
	*/
	var messagetype:UML::Type=messageRealized;
	var typePackage:UML::Package=messagetype.getNearestPackage();
	var pimStereotypeInstance:Stdlib::Element=typePackage.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=typePackage.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
	/*
	namespace:=pimStereotypeInstance.getSchemaTargetNamespace();
	if(namespace.oclIsUndefined())then{
		namespace:='unknownx';
	}endif;
	*/
	// set prefix to be used for Schema namespace
	prefix:=pimStereotypeInstance.getSchemaDefaultPrefix();
		name:=messageRealized.name;
/*
	dataProvenance+=self.getInstanceValues('DataProvenance').map Organization();
	typeName:=messagetype.name;
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=messageRealized.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=result.typeName;
		}endif;
	}endif;
	
	// schemaLocation
	var catalog:UML::Package:=sppCatalogUml.clientDependency.supplier->select(c|c.oclIsKindOf(UML::Component))->asSequence()->first().getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=typePackage.qualifiedName;
	}else{
		var targetPath:String=typePackage.qualifiedName.substringAfter(catalog.qualifiedName);
		if(relativePath.oclIsUndefined())then{
			targetPath:=typePackage.qualifiedName.substringAfter(catalog.nestingPackage.qualifiedName);// TODO: should be relative to package above MPD
		}endif;
		relativePath:='artifacts::service model::information model::'+targetPath;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	schemaLocation:=relativePath;
	*/
//	elementName:=self.getStringValue('ElementName');
	 
	
}	
	mapping 	UML::InstanceSpecification::ServiceInteractionProfile():GRAA::ServiceInteractionProfile@graa 
{
	sipName:=self.getStringValue('SIPName');
	sipVersion:=self.getStringValue('SIPVersion');
}	
	mapping 	UML::InstanceSpecification::Agreement():GRAA::Agreement@graa 
{
	agreementUri:=self.getStringValue('AgreementURI');
	automatedAgreementIndicator:=self.getBooleanValue('AutomatedAgreementIndicator');
/*	
	condition+=self.getStringValues('Condition');
	obligation+=self.getStringValue('Obligation');
	constraint+=self.getStringValue('Constraint');
	// derived
	agreementDescriptionText:=self.getStringValue('AgreementDescriptionText');
	if(agreementDescriptionText.oclIsUndefined())then{
		agreementDescriptionText:=self.ownedComment.body->asSequence()->first();
	}endif;
	*/
	documentation:=self.ownedComment.body->asSequence()->first();
}	
	