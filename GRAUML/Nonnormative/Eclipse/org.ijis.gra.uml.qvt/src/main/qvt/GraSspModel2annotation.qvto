// TODO: import from org.search.niem.uml.qvt.NIEMplatformBinding; remove local copy
//  but it was not exported, may need an OSGi fragment to recover it
//	but it also was changed from omg version and does not work so well
//import org.search.niem.uml.qvt.NIEMplatformBinding;
// due to excessive QVT compilation time, combine several modules into this
import GRAcommon;
//import GRAsoaml2wsdl;
import NIEMmpdmodel2artifact;
import NIEMpsm2xsd;

//import GRAsoaml2wsdlannotations;
//modeltype UML uses 'http://www.omg.org/spec/UML/20110701';
modeltype UML uses 'http://www.eclipse.org/uml2/4.0.0/UML';
modeltype XSD  uses 'http://www.eclipse.org/xsd/2002/XSD';
modeltype SPPCAT  uses 'http://gra.ijis.org/catalog/1.0.0';
modeltype METADATA  uses 'http://it.ojp.gov/gsp/services/1.0.0';

modeltype EBXML uses 'http://www.ebxml.org/BusinessProcess';// no current models use this
modeltype XMLDSIG uses 'http://www.w3.org/2000/09/xmldsig#';// this is used
modeltype WSDL uses 'http://www.eclipse.org/wsdl/2003/WSDL';// TODO: change to http://schemas.xmlsoap.org/wsdl/
modeltype BPMN2 uses 'http://www.omg.org/spec/BPMN/20100524/MODEL-XMI';// no current models use this

modeltype CMOF  uses 'http://www.eclipse.org/emf/2002/Ecore';

modeltype CAT  uses 'http://reference.niem.gov/niem/resource/mpd/catalog/1.0/';
modeltype SOAP uses 'http://www.eclipse.org/wsdl/2003/SOAP';

// TODO:
//modeltype CHANGELOG  uses '???????????????';
/*
modeltype WSDL_HTTP uses 'http://schemas.xmlsoap.org/wsdl/http/';// used in wsdl
modeltype WSDL_MIME uses 'http://schemas.xmlsoap.org/wsdl/mime/';// used in policy wsdl
modeltype WSDL_SOAP uses 'http://schemas.xmlsoap.org/wsdl/soap/';// used in wsdl
modeltype SOAP12 uses 'http://schemas.xmlsoap.org/wsdl/soap12/';// used in wsdl

modeltype SOAP_ENV uses 'http://schemas.xmlsoap.org/soap/envelope/';// this is used in SOAP instance documents and xsd
modeltype SOAP_ENC uses 'http://schemas.xmlsoap.org/soap/encoding/';// this is used in SOAP instance documents and wsdl
modeltype WSRM uses 'http://docs.oasis-open.org/ws-rx/wsrm/200608';// this is used in SOAP instance documents
modeltype WSRM2 uses 'http://schemas.xmlsoap.org/ws/2005/02/rm/policy';// this is used in SOAP instance documents
modeltype WSA uses 'http://www.w3.org/2005/08/addressing';// used in SOAP instance docs, wsdl
modeltype WSAW uses 'http://www.w3.org/2006/05/addressing/wsdl';// used in SOAP instance docs, wsdl
modeltype WSAM uses 'http://www.w3.org/2007/05/addressing/metadata';// used in SOAP instance docs, wsdl
modeltype WSU uses 'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd';// used in SOAP instance docs, wsdl
modeltype WSP uses 'http://schemas.xmlsoap.org/ws/2004/09/policy';// used in SOAP instance docs, wsdl
modeltype SP uses 'http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702';// used in SOAP instance docs, wsdl
modeltype WSX uses 'http://schemas.xmlsoap.org/ws/2004/09/mex';// used in wsdl


//modeltype EBXML uses 'http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/'; // used in xsd, instance docs
//modeltype EBXML uses 'http://www.oasis-open.org/committees/ebxml-msg/schema/msg-header-2_0.xsd';// used in xsd
//modeltype EBXML uses 'http://www.ebxml.org/namespaces/tradePartner';// not used

modeltype BPMN uses 'http://stp.eclipse.org/bpmn';// some ssp references this?
*/
//vii.	WSDL (Added per questions)
//viii.	BPM XMI (Added per questions)
//ix.	Service Change Log (Added per questions) ????????
//x.	ebXML XSD (Added per questions)

// start with gra catalog, a possibly empty uml model with a root model element 
// the gra catalog may need to be externally fabricated;  some ssp do not have any catalog
// some ssp do not have Metadata.xml
// the iepds often do not have a catalog, that may need to be fabricated
// are the schemas under schema an exact duplicate of those under artifacts?
// it may be better to drive collection of schemas from the wsdls

// we may need to split this between a pim and psm layer
// also: niem is split, so do we initially act more like psm to artifact?
// or we do the composite niem independently for each mpd and let this do the remaining qvt spp artifacts?
// lets start with the spp catalog and metadata
//	later pick up the wsdl and schemas
transformation GraSspModel2annotation (in uml:UML,out cat:SPPCAT,out metadata:METADATA,out wsdl:WSDL)
	;
main() {
	GraSspModel2artifact_run();
}	
property graRoot:UML::Model=null;
property sppCatalogUml:UML::Collaboration=null;
	
helper GraSspModel2artifact_run() {
	
	graRoot:=
			uml.rootObjects()
			->select(r|r.oclIsKindOf(UML::Model)).oclAsType(UML::Model)
			->asSequence()->first();
    log('GRA uml model root '+graRoot.repr());    

	graRoot.initializeProfileGlobals();	
	graRoot.initializeSppProfileGlobals();
	// locate the uml spp catalog and map it to target catalog
    log('GRA soamlServicesArchitectureStereotype '+soamlServicesArchitectureStereotype.repr());    
	graRoot.allSubobjectsOfKind(UML::Model).oclAsType(UML::Model).packagedElement
		->select(e|e.isGraCatalog()).oclAsType(UML::Collaboration)
		.map SppCatalog_DocumentRoot();	 
	return;
	}
query UML::Element::isGraCatalog():Boolean=
	self.isStereotypeApplied(graSppStereotype);
//	self.oclIsKindOf(UML::Collaboration);
/////////////////////////////////////////////////catalog mappings
// represents the ssp model as a whole, all elements will be contained in the model
// within the model, it is also a servicesArchitecture
mapping 	UML::Collaboration::SppCatalog_DocumentRoot():SPPCAT::DocumentRoot@cat{
	catalog:=self.map SppCatalog_ProvisioningComponent();
}

mapping 	UML::Collaboration::SppCatalog_ProvisioningComponent():SPPCAT::CatalogType1@cat{
	sppCatalogUml:=self;
	
	//  get metadata and other artifacts during Catalog processing
	//  fully expand wsdl target content
	//  in the process, expand the spp schemas
	// process all content
	// create the items, establish containment, set stereotypes and apply tags discretely
	// catalog implicit
	// metadata : combine-in
	// service-description implicit
	// 	service-interface-description implicit from wsdl-schema
	//  wsdl-schema : similar to NIEM FileType
	//  soap-sample : similar to NIEM FileType
	// iepd-catalog : similar to NIEM FileType
	self.map Catalog(result);
	self.map Metadata(result);
	self.map ServiceDescriptionType(result);
	self.wsdlInterfaceSchema().map ServiceInterfaceDescriptionType(self,result);
	self.soapSample().map SoapSampleType(result);
	self.wsdlSchema().map WsdlSchemaType(result);
	self.iepdCatalog().map IepdCatalogType(result);
}
/*
    - <!--   Service Description Files Section    -->
	<service-description href="artifacts/SIRS_SDD_v_1.0.0.doc">Service Description Document</service-description>
    - <!--   Service Interface Files Section    -->
	<service-interface-description href="artifacts/Notification Service Interface/SIRS_SIDD_NSI_v_1.0.0.doc">Service Interface Description Document</service-interface-description>
	<service-interface-description href="artifacts/Relocation Service Interface/SIRS_SIDD_RSI_v_1.0.0.doc">Service Interface Description Document</service-interface-description>

*/
mapping 	UML::Usage::ServiceInterfaceDescriptionType(spp:UML::Collaboration,inout catalog:SPPCAT::CatalogType1):SPPCAT::ServiceInterfaceDescriptionType@cat{
	catalog.serviceInterfaceDescription:=result;
	var serviceMetadata:METADATA::ServiceMetadataType=spp.map MetadataDocument(catalog.metadata).serviceMetadata->asSequence()->first();
		
	var serviceIdentification:METADATA::ServiceIdentificationType=serviceMetadata.serviceIdentification;
	var abbrev:String=serviceIdentification.serviceNameAbbreviationText->first();	
	
	var versionInformation:METADATA::VersionInformationType=serviceMetadata.versionInformation;
	var majorVersion:Integer=versionInformation.majorVersion;
	var minorVersion:Integer=versionInformation.minorVersion;
	var revisionVersion:Integer=versionInformation.revisionVersion;
	var ifcAbbrev:String=self.name;
	var ifcName:String=self.supplier->asSequence()->first().name;
	href:='artifacts/'+ifcName+'/'+abbrev+'_SIDD_'+ifcAbbrev+'_v_'+majorVersion.toString()+'.'+minorVersion.toString()+'.'+revisionVersion.toString()+'.docx';
	value:='Service Interface Description Document';
}
	
mapping 	UML::Collaboration::ServiceDescriptionType(inout catalog:SPPCAT::CatalogType1):SPPCAT::ServiceDescriptionType@cat{
	catalog.serviceDescription:=result;
	var serviceMetadata:METADATA::ServiceMetadataType=self.map MetadataDocument(catalog.metadata).serviceMetadata->asSequence()->first();
		
	var serviceIdentification:METADATA::ServiceIdentificationType=serviceMetadata.serviceIdentification;
	var abbrev:String=serviceIdentification.serviceNameAbbreviationText->first();	
	var versionInformation:METADATA::VersionInformationType=serviceMetadata.versionInformation;
	
	var majorVersion:Integer=versionInformation.majorVersion;
	var minorVersion:Integer=versionInformation.minorVersion;
	var revisionVersion:Integer=versionInformation.revisionVersion;
	href:='artifacts/'+abbrev+'_SDD_v_'+majorVersion.toString()+'.'+minorVersion.toString()+'.'+revisionVersion.toString()+'.docx';
	value:='Service Description Document';
}
	
query UML::Collaboration::wsdlInterfaceSchema():Sequence(UML::Usage)=
	self.wsdlSchema()
//		->select(d|d.supplier.oclAsType(UML::Artifact).manifestation->notEmpty());
		;
query UML::Collaboration::wsdlSchema():Sequence(UML::Usage)=
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).oclAsType(UML::Usage)
		->select(d|d.supplier->forAll(s|s.isStereotypeApplied(wsdlWsdlDefinitionsStereotype)))->asSequence();
query UML::Collaboration::iepdCatalog():Sequence(UML::Usage)=
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).oclAsType(UML::Usage)
		->select(d|d.supplier->forAll(s|s.isStereotypeApplied(prompdStereotype)))->asSequence();
query UML::Collaboration::soapSample():Sequence(UML::Usage)=
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).oclAsType(UML::Usage)
		->select(d|d.supplier->forAll(s|s.oclIsKindOf(UML::InstanceSpecification)))->asSequence();
// adjust href, if necessary, to be relative to spp package
query UML::Usage::toRelativeSppLocation():String{
	// client is spp catalog, we want relative path to supplier from catalog's package
	// 	<service-interface-description href="artifacts/Notification Service Interface/SIRS_SIDD_NSI_v_1.0.0.doc">Service Interface Description Document</service-interface-description>
	var sppRootPackage:UML::Package=self.client->asSequence()->first().getNearestPackage();
	var target:UML::NamedElement=self.supplier->asSequence()->first();
	// if not in containment of spp package, then assume it is an iepd
	var relativePackagePath:String=target.qualifiedName.substringAfter(sppRootPackage.qualifiedName+'::');
	if(relativePackagePath.oclIsUndefined())then{
		relativePackagePath:='artifacts::service model::information model::'+target.name;
	}endif;
	return relativePackagePath.replace('::','/');
};
mapping 	UML::Collaboration::Metadata(inout catalog:SPPCAT::CatalogType1):SPPCAT::MetadataType@cat{
	catalog.metadata:=result;
	href:='metadata.xml';
	value:='Metadata';
	//	<metadata href="metadata.xml">Metadata</metadata>
	self.map MetadataDocument(result);
}
mapping 	UML::Usage::WsdlSchemaType(inout catalog:SPPCAT::CatalogType1):SPPCAT::WsdlSchemaType@cat
{
	catalog.wsdlSchema+=result;
	var wsdlLocation:String:=self.toRelativeSppLocation();
	if(not(wsdlLocation.endsWith('.wsdl')))then{wsdlLocation:=wsdlLocation+'.wsdl';}endif;
	href:=wsdlLocation;
	value:=self.name;
	//self.supplier.oclAsType(UML::Component).map (result);
//	self.supplier.oclAsType(UML::Component).map Definition(result);
	log('Catalog WsdlSchemaType reference '+result.href);
//	self.supplier.oclAsType(UML::Collaboration).map ServiceDefinition();
	self.supplier.oclAsType(UML::Artifact).map ServiceDefinition();
	
}
mapping 	UML::Usage::IepdCatalogType(inout catalog:SPPCAT::CatalogType1):SPPCAT::IepdCatalogType@cat
{
	catalog.iepdCatalog:=result;
	href:=self.toRelativeSppLocation();
	value:=self.name;
	// TODO: assume this is handled as a separate process
	//self.supplier.oclAsType(UML::Component).map IepdCatalogType(result);
}

mapping 	UML::Usage::SoapSampleType(inout catalog:SPPCAT::CatalogType1):SPPCAT::SoapSampleType@cat
{
	catalog.soapSample+=result;
	href:=self.toRelativeSppLocation();
	value:=self.name;
	// defer creation of xml
	//self.supplier.oclAsType(UML::InstanceSpecification).map SoapSampleType(result);
}
mapping 	UML::Collaboration::Catalog(inout catalog:SPPCAT::CatalogType1):SPPCAT::CatalogType@cat{
	catalog.catalog:=result;
	href:='catalog.html';
	value:='Catalog';
}
////////////////////////////////////////////metadata
mapping 	UML::Collaboration::MetadataDocument(inout metadataType:SPPCAT::MetadataType):METADATA::DocumentRoot@metadata{
	self.map ServiceMetadataType(result);
	var metadataLocation:CMOF::EStringToStringMapEntry=new CMOF::EStringToStringMapEntry();
	metadataLocation.key:='http://it.ojp.gov/gsp/services/1.0.0';
	metadataLocation.value:='Metadata.xsd';
	 
	result.xSISchemaLocation+=metadataLocation;
}
query UML::Element::isServiceInterfaceSpecification():Boolean=
	self.isStereotypeApplied(graServiceInterfaceSpecificationStereotype)
	or self.oclIsKindOf(UML::Interface);
query UML::Element::isServiceIdentification():Boolean=self.isStereotypeApplied(graServiceIdentificationStereotype);
query UML::Element::isBusinessContext():Boolean=self.isStereotypeApplied(graBusinessContextStereotype);
query UML::Collaboration::serviceIdentifications():Sequence(UML::Component)=
	self.role.type->select(s|s.isServiceIdentification()).oclAsType(UML::Component)->asSequence();
query UML::Collaboration::serviceIdentification():METADATA::ServiceIdentificationType=
	self.serviceIdentifications()->first().map ServiceIdentificationType();
mapping 	UML::Collaboration::ServiceMetadataType(inout document:METADATA::DocumentRoot):METADATA::ServiceMetadataType@metadata
{
	document.serviceMetadata:=result;
	// serviceIdentification is a participant component and a role of the services architecture 
	serviceIdentification:=self.serviceIdentification();
	self.useCase.map RelatedOrganizationInformationType(result);
	
//	self.getNearestPackage().packagedElement
//		->select(s|s.isServiceInterfaceSpecification()).oclAsType(UML::Class).map ServiceInterfaceSpecification(result);
	self.ownedAttribute
		->select(a|a.aggregation=UML::AggregationKind::composite).type
		->select(t|t.isServiceIdentification()).oclAsType(UML::Component).ownedPort.type
		->select(s|s.isServiceInterfaceSpecification()).oclAsType(UML::Classifier).map ServiceInterfaceSpecification(result);
		
	self.map ServiceDescription(result);
	self.map VersionInformation(result);
	//self.map BusinessContext(result);
	self.ownedAttribute
		->select(a|a.aggregation<>UML::AggregationKind::composite).type
		->select(t|t.isBusinessContext()).oclAsType(UML::Component).map BusinessContext(result);
	
	self.collaborationUse.type
		->select(t|t.isStereotypeApplied(graServiceLevelAgreementsStereotype))
		->asSequence()->first().oclAsType(UML::Collaboration).map ServiceLevelAgreements(result);
}
mapping UML::Collaboration::ServiceLevelAgreements(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceLevelAgreementsType
{
	serviceMetadata.serviceLevelAgreements:=result;
	//var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
	self.map ServicePolicyAndContracts(result);
	self.map PerformanceMetrics(result);
	self.map ServiceUsageDetails(result);
}
mapping UML::Collaboration::ServiceUsageDetails(inout serviceLevelAgreementsType:METADATA::ServiceLevelAgreementsType):METADATA::ServiceUsageType
{
	serviceLevelAgreementsType.serviceUsageDetails:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	
	approvalRequiredIndicator:=appliedStereotype.getTagValue('approvalRequired').oclAsType(Boolean);
	licensingRequiredIndicator:=appliedStereotype.getTagValue('licensingRequired').oclAsType(Boolean);
	self.map LicensingAgreement(result);
	self.map ServiceCost(result);
}
mapping UML::Collaboration::ServiceCost(inout serviceUsageDetailsType:METADATA::ServiceUsageType):METADATA::CostType
{
	serviceUsageDetailsType.serviceCost:=result;
	self.map UsageCostAmount(result);
	self.map UsageUnitCostAmount(result);
	self.map CreationCostAmount(result);
}
mapping UML::Collaboration::CreationCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.creationCostAmount:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	value:=appliedStereotype.getTagValue('creationCostAmountValue').oclAsType(Real);
	currencyText:=appliedStereotype.getTagValue('creationCostAmountCurrencyText').oclAsType(String);
}
mapping UML::Collaboration::UsageUnitCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.usageUnitCostAmount:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	value:=appliedStereotype.getTagValue('usageUnitCostAmountValue').oclAsType(Real);
	currencyText:=appliedStereotype.getTagValue('usageUnitCostAmountCurrencyText').oclAsType(String);
}
mapping UML::Collaboration::UsageCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.usageCostAmount:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	value:=appliedStereotype.getTagValue('usageCostAmountValue').oclAsType(Real);
	currencyText:=appliedStereotype.getTagValue('usageCostAmountCurrencyText').oclAsType(String);
}

mapping UML::Collaboration::LicensingAgreement(inout serviceUsageDetailsType:METADATA::ServiceUsageType):METADATA::AgreementType
{
	serviceUsageDetailsType.licensingAgreement:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	agreementDescriptionText:=appliedStereotype.getTagValue('licensingAgreementDescriptionText').oclAsType(String);
	agreementURI:=appliedStereotype.getTagValue('licensingAgreementURI').oclAsType(String);
}
mapping UML::Collaboration::PerformanceMetrics(inout serviceLevelAgreementsType:METADATA::ServiceLevelAgreementsType):METADATA::PerformanceMetricsType
{
	serviceLevelAgreementsType.performanceMetrics:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	
	serviceResponseTime:=appliedStereotype.getTagValue('performanceResponseDuration').oclAsType(String).toDuration();
	serviceAverageThroughput:=appliedStereotype.getTagValue('serviceAverageThroughput').oclAsType(String);
	serviceMaximumThroughput:=appliedStereotype.getTagValue('serviceMaximumThroughput').oclAsType(String);
	serviceAvailability:=appliedStereotype.getTagValue('serviceAvailability').oclAsType(String);
}
mapping UML::Collaboration::ServicePolicyAndContracts(inout serviceLevelAgreementsType:METADATA::ServiceLevelAgreementsType):METADATA::ServicePolicyAndContractsType
{
	serviceLevelAgreementsType.servicePolicyAndContracts:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	applicablePoliciesIndicator:=appliedStereotype.getTagValue('applicablePoliciesIndicator').oclAsType(Boolean);
	self.map ApplicablePolicies(result);	
	applicableContractsIndicator:=appliedStereotype.getTagValue('applicableContractsIndicator').oclAsType(Boolean);
	
	applicableAgreementsIndicator:=appliedStereotype.getTagValue('applicableAgreementsIndicator').oclAsType(Boolean);
	applicableUmbrellaAgreementsIndicator:=appliedStereotype.getTagValue('applicableUmbrellaAgreementsIndicator').oclAsType(Boolean);
	//domainNameText:=appliedStereotype.getTagValue('domainNameText');
	self.map ApplicableContracts(result);	
	self.map ApplicableAgreements(result);	
	self.map ApplicableUmbrellaAgreements(result);	
}
mapping UML::Collaboration::ApplicablePolicies(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicablePoliciesType
{
	servicePolicyAndContractsType.applicablePolicies:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	policyText:=appliedStereotype.getTagValue('policyText').oclAsType(String);
}

mapping UML::Collaboration::ApplicableUmbrellaAgreements(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicableUmbrellaAgreementsType
{
	servicePolicyAndContractsType.applicableUmbrellaAgreements:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	var umbrellaAgreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.getTagValues('umbrellaAgreementAgreementDescriptionText').oclAsType(String)	;
	var umbrellaAgreementAgreementURIs:Sequence(String)=appliedStereotype.getTagValues('umbrellaAgreementAgreementURI').oclAsType(String)	;
	umbrellaAgreementAgreementDescriptionTexts->forEach(umbrellaAgreementAgreementDescriptionText){
		umbrellaAgreementAgreementDescriptionText.map UmbrellaAgreement(result,umbrellaAgreementAgreementURIs->at(umbrellaAgreementAgreementDescriptionTexts->indexOf(umbrellaAgreementAgreementDescriptionText))); 
	};
}
mapping String::UmbrellaAgreement(inout applicableUmbrellaAgreementsType:METADATA::ApplicableUmbrellaAgreementsType,umbrellaAgreementAgreementURIIn:String):METADATA::AgreementType
{
	applicableUmbrellaAgreementsType.umbrellaAgreement+=result;
	agreementDescriptionText:=self;
	agreementURI:=umbrellaAgreementAgreementURIIn;
}

mapping UML::Collaboration::ApplicableAgreements(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicableAgreementsType
{
	servicePolicyAndContractsType.applicableAgreements:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	var agreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.getTagValues('agreementAgreementDescriptionText').oclAsType(String)	;
	var agreementAgreementURIs:Sequence(String)=appliedStereotype.getTagValues('agreementAgreementURI').oclAsType(String)	;
	agreementAgreementDescriptionTexts->forEach(agreementAgreementDescriptionText){
		agreementAgreementDescriptionText.map Agreement(result,agreementAgreementURIs->at(agreementAgreementDescriptionTexts->indexOf(agreementAgreementDescriptionText))); 
	};
}
mapping String::Agreement(inout applicableAgreementsType:METADATA::ApplicableAgreementsType,agreementAgreementURIIn:String):METADATA::AgreementType
{
	applicableAgreementsType.agreement+=result;
	agreementDescriptionText:=self;
	agreementURI:=agreementAgreementURIIn;
}
mapping UML::Collaboration::ApplicableContracts(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicableContractsType
{
	servicePolicyAndContractsType.applicableContracts:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceLevelAgreementsStereotype).oclAsType(Stdlib::Element);
	var contractAgreementDescriptionTexts:Sequence(String)=appliedStereotype.getTagValues('contractAgreementDescriptionText').oclAsType(String)	;
	var contractAgreementURIs:Sequence(String)=appliedStereotype.getTagValues('contractAgreementURI').oclAsType(String)	;
	contractAgreementDescriptionTexts->forEach(contractAgreementDescriptionText){
		contractAgreementDescriptionText.map Contract(result,contractAgreementURIs->at(contractAgreementDescriptionTexts->indexOf(contractAgreementDescriptionText))); 
	};
}
mapping String::Contract(inout applicableContractsType:METADATA::ApplicableContractsType,contractAgreementURIIn:String):METADATA::AgreementType
{
	applicableContractsType.contract+=result;
	agreementDescriptionText:=self;
	agreementURI:=contractAgreementURIIn;
}
mapping UML::Component::BusinessContext(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::BusinessContextType
{
	serviceMetadata.businessContext:=result;
	//var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
			
	self.map DomainDescription(result);
	self.map Classifications(result);
	self.map ExchangePartnerTypes(result);
	self.map Endorsements(result);
	self.map Sponsors(result);
}
mapping UML::Component::Classifications(inout businessContext:METADATA::BusinessContextType):METADATA::ClassificationsType
{
	businessContext.classifications:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graBusinessContextStereotype).oclAsType(Stdlib::Element);
	classification:=appliedStereotype.getTagValue('classification').oclAsType(String);
}
mapping UML::Component::DomainDescription(inout businessContext:METADATA::BusinessContextType):METADATA::DomainDescriptionType
{
	businessContext.domainDescription:=result;
	//var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
//	domainNameText:=appliedStereotype.getTagValue('domainNameText').oclAsType(String);
	domainNameText:=self.name;
}

mapping UML::Component::Sponsors(inout businessContext:METADATA::BusinessContextType):METADATA::SponsorsType
{
	businessContext.sponsors:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graBusinessContextStereotype).oclAsType(Stdlib::Element);
	sponsor+=appliedStereotype.getTagValues('sponsor').oclAsType(String);
}
mapping UML::Component::Endorsements(inout businessContext:METADATA::BusinessContextType):METADATA::EndorsementsType
{
	businessContext.endorsements:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graBusinessContextStereotype).oclAsType(Stdlib::Element);
	endorser+=appliedStereotype.getTagValues('endorser').oclAsType(String);
}
mapping UML::Component::ExchangePartnerTypes(inout businessContext:METADATA::BusinessContextType):METADATA::ExchangePartnerTypesType
{
	businessContext.exchangePartnerTypes:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graBusinessContextStereotype).oclAsType(Stdlib::Element);
	exchangePartnerTypeDescriptionText:=appliedStereotype.getTagValue('exchangePartnerTypeDescriptionText').oclAsType(String);
}
mapping UML::Collaboration::VersionInformation(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::VersionInformationType
{
	serviceMetadata.versionInformation:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
			
	majorVersion:=appliedStereotype.getTagValue('majorVersion').oclAsType(Integer);
	minorVersion:=appliedStereotype.getTagValue('minorVersion').oclAsType(Integer);
	revisionVersion:=appliedStereotype.getTagValue('revisionVersion').oclAsType(Integer);
	creationDate:=appliedStereotype.getTagValue('creationDate').oclAsType(String).toDate();
	activationDate:=appliedStereotype.getTagValue('activationDate').oclAsType(String).toDate();
	lastRevisionDate:=appliedStereotype.getTagValue('lastRevisionDate').oclAsType(String).toDate();
	nextRevisionDate:=appliedStereotype.getTagValue('nextRevisionDate').oclAsType(String).toDate();
	expirationDate:=appliedStereotype.getTagValue('expirationDate').oclAsType(String).toDate();
	lifecycleStatus:=appliedStereotype.getTagValue('lifecycleStatus').oclAsType(String);
	alertsAndNotifications:=appliedStereotype.getTagValue('alertsAndNotification').oclAsType(String);
}
mapping UML::Collaboration::ServiceDescription(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceDescriptionType
{
	serviceMetadata.serviceDescription:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
	
	servicePurposeText:=appliedStereotype.getTagValue('servicePurposeText').oclAsType(String);
	serviceScopeDescriptionText:=appliedStereotype.getTagValue('serviceScopeDescriptionText').oclAsType(String);
	serviceDescriptionSummaryText:=appliedStereotype.getTagValue('serviceDescriptionSummaryText').oclAsType(String);
	serviceDescriptionText:=appliedStereotype.getTagValue('serviceDescriptionText').oclAsType(String);
	serviceDescriptionKeywordText:=appliedStereotype.getTagValue('serviceDescriptionKeywordText').oclAsType(String);
	self.map ServiceCapabilities(result);
	self.map ServiceRealWorldEffects(result);
	securityClassificationText:=appliedStereotype.getTagValue('securityClassificationText').oclAsType(String);
	
	self.map ServiceDependencies(result);
	self.map IEPDReferences(result);
}
mapping UML::Collaboration::ServiceRealWorldEffects(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::ServiceRealWorldEffectsType
{
	serviceDescription.serviceRealWorldEffects:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
	realWorldEffectDescriptionText+=appliedStereotype.getTagValues('realWorldEffectDescriptionText').oclAsType(String);
}
mapping UML::Collaboration::ServiceCapabilities(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::ServiceCapabilitiesType
{
	serviceDescription.serviceCapabilities:=result;
	/*
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceInterfaceSpecificationStereotype).oclAsType(Stdlib::Element);
	capabilityDescriptionText:=appliedStereotype.getTagValue('capabilityDescriptionText').oclAsType(String);
	*/
	var primaryServiceParticipant:UML::Component=self.ownedAttribute
		->select(a|a.aggregation=UML::AggregationKind::composite).type
		->select(t|t.isServiceIdentification()).oclAsType(UML::Component)->asSequence()->first();
	primaryServiceParticipant.realization.realizingClassifier->select(c|c.isStereotypeApplied(graServiceCapabilityStereotype))->forEach(capability){
		var appliedStereotype:Stdlib::Element=capability.GetStereotypeApplication(graServiceCapabilityStereotype).oclAsType(Stdlib::Element);
			capabilityDescriptionText+=appliedStereotype.getTagValue('capabilityDescriptionText').toString();
		
	};	
}

mapping UML::Collaboration::IEPDReferences(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::IEPDReferencesType
{
	serviceDescription.iEPDReferences:=result;
	// assume indexes align and no significance to grouping
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graSppStereotype).oclAsType(Stdlib::Element);
	var iEPDNames:Sequence(String)=appliedStereotype.getTagValues('iEPDName').oclAsType(String)	;
	var iEPDURLs:Sequence(String)=appliedStereotype.getTagValues('iEPDURL').oclAsType(String)	;
	iEPDNames->forEach(iEPDName){
		iEPDName.map IEPDReference(result,iEPDURLs->at(iEPDNames->indexOf(iEPDName))); 
	};
}
mapping 	String::IEPDReference(inout iEPDReferencesType:METADATA::IEPDReferencesType,sIPVersionIn:String):METADATA::IEPDReferenceType
{
	iEPDReferencesType.iEPDReference+=result;
	iEPDName:=self;
}
mapping UML::Collaboration::ServiceDependencies(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::ServiceDependenciesType
{
	serviceDescription.serviceDependencies:=result;

	var serviceIdentifications:Sequence(UML::Component)=
		self.role.type->select(s|s.isServiceIdentification()).oclAsType(UML::Component)->asSequence();
	serviceDependency+=serviceIdentifications->select(s|s<>serviceIdentifications->first()).map ServiceIdentificationType();
}

// seems like this should also be in ServiceInterface via wsdl, possibly bpmn
// for now, map to ServiceInterface class
// TODO: we should be doing port on spp participant whose type is serviceInterface
mapping UML::Classifier::ServiceInterfaceSpecification(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceInterfaceSpecificationType
{
	serviceMetadata.serviceInterface+=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceInterfaceSpecificationStereotype).oclAsType(Stdlib::Element);
	if(not(appliedStereotype.oclIsUndefined()))then{
		securityImplementedIndicator:=appliedStereotype.getTagValue('securityImplementedIndicator').oclAsType(Boolean);
		securityDescriptionText:=appliedStereotype.getTagValue('securityDescriptionText').oclAsType(String);
	}endif;
	// assume these align by index
	self.map URIDetails(result);
	self.map ServiceActions(result);
	self.map ServiceInteractionProfiles(result);
}
mapping 	UML::Classifier::ServiceInteractionProfiles(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType):METADATA::ServiceInteractionProfilesType
{
	serviceInterfaceSpecification.serviceInteractionProfiles:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceInterfaceSpecificationStereotype).oclAsType(Stdlib::Element);
	if(not(appliedStereotype.oclIsUndefined()))then{
		var sIPNames:Sequence(String)=appliedStereotype.getTagValues('sIPName').oclAsType(String)	;
		var sIPVersions:Sequence(String)=appliedStereotype.getTagValues('sIPVersion').oclAsType(String)	;
		
		sIPNames->forEach(sIPName){
			sIPName.map ServiceInteractionProfile(result,sIPVersions->at(sIPNames->indexOf(sIPName))); 
		};
	}endif;
}
mapping 	String::ServiceInteractionProfile(inout serviceInteractionProfiles:METADATA::ServiceInteractionProfilesType,sIPVersionIn:String):METADATA::ServiceInteractionProfileType
{
	serviceInteractionProfiles.serviceInteractionProfile+=result;
	sIPName:=self;
	sIPVersion:=sIPVersionIn;
}
mapping 	UML::Classifier::ServiceActions(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType):METADATA::ServiceActionsType
{
	serviceInterfaceSpecification.serviceActions:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceInterfaceSpecificationStereotype).oclAsType(Stdlib::Element);
	if(not(appliedStereotype.oclIsUndefined()))then{
		var actionNames:Sequence(String)=appliedStereotype.getTagValues('actionName').oclAsType(String)	;
		var actionPurposes:Sequence(String)=appliedStereotype.getTagValues('actionPurpose').oclAsType(String)	;
		var messageExchangePatterns:Sequence(String)=appliedStereotype.getTagValues('messageExchangePattern').oclAsType(String)	;
		
		actionNames->forEach(actionName){
			actionName.map ServiceAction(result,actionPurposes->at(actionNames->indexOf(actionName)),
					messageExchangePatterns->at(actionNames->indexOf(actionName))); 
		};
	}endif;
}
mapping 	String::ServiceAction(inout serviceActions:METADATA::ServiceActionsType,actionPurposeIn:String,messageExchangePatternIn:String):METADATA::ServiceActionType
{
	serviceActions.serviceAction+=result;
	actionName:=self;
	actionPurpose:=actionPurposeIn;
	messageExchangePattern:=messageExchangePatternIn;
}

mapping 	UML::Classifier::URIDetails(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType):METADATA::URIDetailsType
{
	serviceInterfaceSpecification.uRIDetails:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceInterfaceSpecificationStereotype).oclAsType(Stdlib::Element);
	if(not(appliedStereotype.oclIsUndefined()))then{
		var uRIAddresss:Sequence(String)=appliedStereotype.getTagValues('uRIAddress').oclAsType(String)	;
		var uRIDescriptions:Sequence(String)=appliedStereotype.getTagValues('uRIDescription').oclAsType(String)	;
		
		uRIAddresss->forEach(uRIAddress){
			uRIAddress.map URIDetail(result,uRIDescriptions->at(uRIAddresss->indexOf(uRIAddress))); 
		};
	}endif;	
}
mapping 	String::URIDetail(inout uriDetails:METADATA::URIDetailsType,uRIDescriptionIn:String):METADATA::URIDetailType
{
	uriDetails.uRIDetail+=result;
	uRIAddress:=self;
	uRIDescription:=uRIDescriptionIn;
}


mapping 	UML::UseCase::RelatedOrganizationInformationType(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::RelatedOrganizationInformationType
{
	serviceMetadata.relatedOrganizationInformation+=result;
	self.getAssociations().memberEnd.type
		->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor).map OrganizationType(result);
}
mapping 	UML::Actor::OrganizationType(inout relatedOrganization:METADATA::RelatedOrganizationInformationType):METADATA::OrganizationType
{
	relatedOrganization.organization+=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graOrganizationStereotype).oclAsType(Stdlib::Element);
	organizationName:=self.name;
	if(not(appliedStereotype.oclIsUndefined()))then{
		organizationAcronym:=appliedStereotype.getTagValue('organizationAcronym').oclAsType(String);
		organizationFullAddressText:=appliedStereotype.getTagValue('organizationFullAddressText').oclAsType(String);
		organizationWebSiteURL:=appliedStereotype.getTagValue('organizationWebSiteURL').oclAsType(String);
		organizationRoleDescriptionText:=appliedStereotype.getTagValue('organizationRoleDescriptionText').oclAsType(String);
		organizationRoleDetailedDescriptionText:=appliedStereotype.getTagValue('organizationRoleDetailedDescriptionText').oclAsType(String);
	}endif;
	self.map OrganizationPointOfContact(result);	
}
mapping 	UML::Actor::OrganizationPointOfContact(inout organization:METADATA::OrganizationType):METADATA::PersonContactInformationType
{
	organization.organizationPointOfContact:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graOrganizationStereotype).oclAsType(Stdlib::Element);
	if(not(appliedStereotype.oclIsUndefined()))then{
	
		contactPersonName:=appliedStereotype.getTagValue('contactPersonName').oclAsType(String);
		contactPersonEmailID:=appliedStereotype.getTagValue('contactPersonEmailID').oclAsType(String);
		contactPersonPhoneNumberID:=appliedStereotype.getTagValue('contactPersonPhoneNumberID').oclAsType(String);
		contactPersonAddress:=appliedStereotype.getTagValue('contactPersonAddress').oclAsType(String);
	}endif;
}

mapping UML::Component::ServiceIdentificationType():METADATA::ServiceIdentificationType
{
//	serviceMetadata.serviceIdentification:=result;
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(graServiceIdentificationStereotype).oclAsType(Stdlib::Element);
	serviceFullNameText+=appliedStereotype.getTagValues('serviceFullNameText').oclAsType(String)	;
	serviceID+=appliedStereotype.getTagValues('serviceID').oclAsType(String)	;
	serviceURI+=appliedStereotype.getTagValues('serviceURI').oclAsType(String)	;
	serviceNameAbbreviationText+=appliedStereotype.getTagValues('serviceNameAbbreviationText').oclAsType(String)	;
}


///////////////////////////////////////////iepd
/* TODO: assume this is handled as separate process
mapping 	SPPCAT::IepdCatalogType::IepdCatalogType(inout pimComponent:UML::Collaboration):UML::Usage
{
 //           <iepd-catalog href="artifacts/service model/information model/SAR/catalog.html">Suspicious Activity Report IEPD Catalog</iepd-catalog>
	// create a package/component for the iepd; create Usage to it and include name; use NIEM-UML to expand?
	//  however, we may want to do this via wsdl instead
	//  but: some of the wsdls reference schemas (ebxml, etc.) not in iepd
	var umlPackagePath:String=self.href.toRelativeSppLocation();
	var ownerPackage:UML::Package=umlPackagePath.getSppOwnerPackage(sppRootPackage);
	var fileTypePackage:UML::Component=null;
	
		var catalog:CAT::DocumentRoot=self.oclAsType(Stdlib::Element).getCatalogAtRelativeURI(self.href.replaceAll('\\\\','/')).oclAsType(CAT::DocumentRoot);
		log('getCatalogAt '+self.href+' = '+catalog.repr());
//if(false)then{		
		if(not(catalog.oclIsUndefined()))then{
			// and map it as catalog
			fileTypePackage:=catalog.mapAbstractCatalog(ownerPackage);
			if(not(fileTypePackage.oclIsUndefined()))then{
				ownerPackage.packagedElement+=fileTypePackage;
			}endif;
		}endif;
//}endif;		
	// TODO: package should be parent of href item
	if((fileTypePackage=null))then{
		fileTypePackage:=new UML::Component();
		ownerPackage.packagedElement+=fileTypePackage;
		fileTypePackage.name:=umlPackagePath.toSppBaseName();
	}endif;
	supplier+=fileTypePackage;
	client+=pimComponent;
	name=self.value;
	pimComponent.getNearestPackage().packagedElement+=result;
}
// reproduce logic in NIEMmpd2pim_run
helper CAT::DocumentRoot::mapAbstractCatalog(inout ownerPackage:UML::Package):UML::Component {
	documentRoot:= self;
    // set NIEM catalog        
	catalog:=documentRoot.catalog->asSequence()->first();
	// set pimRoot for NIEM; 
	// this
	pimRoot:=ownerPackage;
	mpdRootPackage:=pimRoot;
	//pimRoot.initializeProfileGlobals();// already done	
		gatherCatalogedSchemas(mpdRootPackage);
		// now fully expand schema content
		expandSchemaContent:=true;
		var schemaPackages:Set(UML::Package)=
			mpdRootPackage.allSubobjectsOfType(UML::Package).oclAsType(UML::Package)
			->select(p|p.isEditable() and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
			->asSet();
		log('expandSchemaContent from '+mpdRootPackage.qualifiedName+', schema count='+schemaPackages->size().repr());
		schemaPackages->sortedBy(p|p.name).expandSchemaContent();
		// schemaPackages may have changed during expandSchemaContent
		schemaPackages:=
			mpdRootPackage.allSubobjectsOfType(UML::Package).oclAsType(UML::Package)
			->select(p|p.isEditable() and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
			->asSet();
	// weed out property holders

		log('propertyHolder adjust');
		schemaPackages.ownedType
			->select(t|t.IsStereotypeApplied(NIEMPropertyHolderStereotype) or t.IsStereotypeApplied(NIEMInformationModelStereotype))
			.oclAsType(UML::Class).adjustPropertyHolders();
		
		log('remove propertyHolder temporary realizations');
		schemaPackages.ownedType
			->select(t|t.IsStereotypeApplied(NIEMPropertyHolderStereotype))
			.oclAsType(UML::Class).adjustPropertyHolderRealizations();
		return mpdComponent;
	}
*/
//////////////////////////////////soap sample
/*
mapping 	SPPCAT::SoapSampleType::SoapSampleType(inout pimComponent:UML::Collaboration):UML::Usage
{
 //           <soap-sample href="sample/SIP/Service Interface 1/SSA-SARInformationMessage-SOAP.xml">SSA-SAR Information Message SOAP Sample</soap-sample>
	// create a package/instance for the xml; create Usage to it and include name
	var umlPackagePath:String=self.href.toRelativeSppLocation();
	var ownerPackage:UML::Package=umlPackagePath.getSppOwnerPackage(sppRootPackage);
	var fileTypePackage:UML::InstanceSpecification=null;
	/ * TODO
		var soap:SOAP::Soap=self.oclAsType(Stdlib::Element).getSoapAtRelativeURI(self.href).oclAsType(SOAP::Soap);
		log('getSoapAt '+self.href+' = '+soap.repr());
		if(not(soap.oclIsUndefined()))then{
			// and map it as soap
			fileTypePackage:=wsdl.mapAbstractSoap();
			if(fileTypePackage.oclIsUndefined())then{return null;}endif;
			ownerPackage.packagedElement+=fileTypePackage;
		}endif;
	* /	
	if((fileTypePackage=null))then{
		fileTypePackage:=new UML::InstanceSpecification();
		ownerPackage.packagedElement+=fileTypePackage;
		fileTypePackage.name:=umlPackagePath.toSppBaseName();
	}endif;
	supplier+=fileTypePackage;
	client+=pimComponent;
	name=self.value;
	pimComponent.getNearestPackage().packagedElement+=result;
}
*/
////////////////////////////////////////////wsdl
//SPPCAT::WsdlSchemaType
// create a WSDL::Definition from 
/*
mapping 	SPPCAT::WsdlSchemaType::WsdlSchemaType(inout pimComponent:UML::Collaboration):UML::Usage
{
	pimComponent.getNearestPackage().packagedElement+=result;
 //       <wsdl-schema href="schema\SIP\NotificationServiceInterface.wsdl">Notification Service Schema</wsdl-schema>
	// create a package/component Participant for the wsdl; create Usage to it and include name
	var umlPackagePath:String=self.href.toRelativeSppLocation();
	//log('WsdlSchemaType '+self.href);
	//log('WsdlSchemaType '+umlPackagePath+', '+self.href);
	var ownerPackage:UML::Package=umlPackagePath.getSppOwnerPackage(sppRootPackage);
	var fileTypePackage:UML::Component=null;
		var wsdl:WSDL::Definition=self.oclAsType(Stdlib::Element).getWsdlAtRelativeURI(self.href).oclAsType(WSDL::Definition);
		log('getWsdlAt '+self.href+' = '+wsdl.repr());
		if(not(wsdl.oclIsUndefined()))then{
			// and map it as wsdl
			fileTypePackage:=wsdl.map Definition(ownerPackage);
		}endif;
	if((fileTypePackage=null))then{
		//fileTypePackage:=self.map FileTypePackage(ownerPackage);
		fileTypePackage:=new UML::Component();
		ownerPackage.packagedElement+=fileTypePackage;
		fileTypePackage.name:=umlPackagePath.toSppBaseName();
	}endif;
	supplier+=fileTypePackage;
	client+=pimComponent;
	name=self.value;
}
*/
/*
mapping 	UML::Component::Definition(inout wsdlSchemaType:SPPCAT::WsdlSchemaType):WSDL::Definition@wsdl
{
	// TODO: use the GRAsoaml2wsdl* transforms for rest of this..................
	
	
	// create and populate the wsdl definition
	// nested components are services
	location:=self.toRelativePathName(sppCatalogUml.getNearestPackage(),false);
	targetNamespace:=self.name;
	self.elementImport.importedElement->forEach(importElement){
		// create the wsdlImport, add to definition, set relativeFilePath and namespace
		var wsdlImport:WSDL::Import=new WSDL::Import();
		eImports+=wsdlImport;
		wsdlImport.namespace:=importElement.name;
		wsdlImport.relativeFilePath:=importElement.toRelativePathName(self.getNearestPackage(),false);
		// the actual wsdl should be created via the catalog
	};
			
			// TODO: hook up schemas to mpd component
			if(not(wsdlDefinition.eTypes.oclIsUndefined()))then{
				wsdlDefinition.eTypes.getSchemas().oclAsType(XSD::XSDSchema)->forEach(schema){
					// this will be schema embedded in wsdl; need to go one more level
					schema.contents->select(content|content.oclIsKindOf(XSD::XSDImport)).oclAsType(XSD::XSDImport)->forEach(xsdImport){
						if(xsdImport.resolvedSchema.oclIsUndefined())then{
							var wsdlschema:XSD::XSDSchema=self.oclAsType(CMOF::EObject).getWsdlSchemaAtRelativeURI(xsdImport.schemaLocation).oclAsType(XSD::XSDSchema);
							if(wsdlschema.oclIsUndefined())then{
								log('wsdl schema resolved '+wsdlschema.targetNamespace);
								xsdImport.resolvedSchema:=wsdlschema;
							}else{
								log('wsdl schema not found at '+xsdImport.schemaLocation);
							}endif;
						}endif;
					
						// force resolution of imported schema, if necessary;  
						//if(xsdImport.resolvedSchema.oclIsUndefined())then{xsdImport.importSchema();}endif;
					
						//xsdImport.importSchema();
						assert error (not(xsdImport.resolvedSchema.oclIsUndefined())) with log('failed to resolve schema at '+xsdImport.schemaLocation+' from schema '+xsdImport.schema.targetNamespace+' at '+xsdImport.schema.schemaLocation);
					
						var importedSchema:XSD::XSDSchema=xsdImport.resolvedSchema;
						//var importedSchema:XSD::XSDSchema=xsdImport.getResolvedSchema();
						//var fileTypePackage:UML::Package=importedSchema.XSDSchema();
						var fileTypePackage:UML::Package=importedSchema.mapAbstractXSDSchema();
						
					};
				};
			}endif;
	// TODO: Definition specific 
	//encoding
	//location
	//qName?
	//import?
	// resolve extensibilityElements so they can be subsequently referenced 
		self.eExtensibilityElements->forEach(ee){
			switch{
				case(ee.()){
					// wsp
					// should be applied to a Constraint
					ee.mapPolicy(result);
				};
				else{
					log('ERROR: Unsupported WSDL::Definition extension '+ee.repr());
				};
			};
	};		
	// transitive closure of references from services should encompass entire wsdl
	self.packagedElement->select(c|c.oclIsKindOf(UML::Component)).map ServicePoint(result);
	
}
*/
/*
mapping UML::Component::ServicePoint(inout pimOwner:WSDL::Definition):WSDL::Service@wsdl
{
	pimOwner.eServices+=result;
	result.setServiceQnameLocaPart(self.name);
	self.ownedAttribute->select(p|p.oclIsKindOf(UML::Port)).map WsdlPort(result);
	// TODO: Service specific 
	// qName
	// undefined
}
mapping UML::Port::WsdlPort(inout pimOwner:WSDL::Service):WSDL::Port@wsdl
{
	pimOwner.ePorts+=result;
	
	name:=self.name;
	self.type.map AbstractWsdlBinding(result);
	
//	type:=self.eBinding.map AbstractWsdlBinding(pimOwner);
//	var wsdlPortInstance:Stdlib::Element=result.applyStereotype(wsdlSoapAddressStereotype);
	
		self.eExtensibilityElements->forEach(ee){
			switch{
				case(ee.oclIsKindOf(SOAP::SOAPAddress)){
					var soapAddress:SOAP::SOAPAddress=ee.oclAsType(SOAP::SOAPAddress);
					var soapAddressInstance:Stdlib::Element=wsdlPortInstance;
					soapAddressInstance.setSoapAddressLocation(soapAddress.locationURI);
					soapAddressInstance.setSoapAddressWsdlRequired(soapAddress.required);
				};
				case(ee.getExtensibilityElementQNameLocalPart()='EndpointReference'){
					var endpointReferenceInstance:Stdlib::Element=result.applyStereotype(wsdlWsaEndpointReferenceStereotype);
					// TODO
					//endpointReferenceInstance.setEndpointReferenceAddress(endpointReference.getEndpointReferenceAddress());
				};
				else{
					log('ERROR: Unsupported WSDL::Port extension '+ee.repr());
				};
			};
			};		
	
}
*/

////////////////////////////////////////////bpmn  - no hooks from catalog
////////////////////////////////////////////ebxml  - how are these referenced?


/////////////////////////////////////////////was GRAsoaml2wsdlannotations
/*
helper UML::Classifier::DefinitionWsdlAnnotation(element:WSDL::WSDLElement){
	self.wsdlAnnotation(element);
	self.getRealizedInterfaces()->forEach(interface){
		var portType:WSDL::PortType=interface.map PortType(element.getEnclosingDefinition());
		interface.wsdlAnnotation(portType);
		interface.allBehavioralFeatures()->forEach(behavioralFeature){
			var operation:WSDL::Operation=behavioralFeature.map Operation(portType,interface);
			operation.setMpoModifiable();
			
			behavioralFeature.wsdlAnnotation(operation);
			var inputParameter:UML::NamedElement=behavioralFeature.getInputParameter();
			var outputParameter:UML::NamedElement=behavioralFeature.getOutputParameter();
			if(inputParameter.oclIsUndefined())then{}else{
				var eInput:WSDL::Input=inputParameter.map Input(portType,interface);
				inputParameter.wsdlAnnotation(eInput);
			}endif;
			if(outputParameter.oclIsUndefined())then{}else{
				var eOutput:WSDL::Output=outputParameter.map Output(portType);
				outputParameter.wsdlAnnotation(eOutput);
			}endif;
			//var eFaults:=behavioralFeature.raisedException.map Fault(portType);
			
		};
	};
	return;
}
*/	
/*
//helper UML::Collaboration::ServiceDefinitionWsdlAnnotation(element:WSDL::Definition){
helper UML::Artifact::ServiceDefinitionWsdlAnnotation(element:WSDL::Definition){
	self.wsdlAnnotation(element);
	self.service()->forEach(participant){
//		var service:WSDL::Service=self.map Service(element);
		var service:WSDL::Service=participant.map Service(element);
//		self.wsdlAnnotation(service);
//		self.getRealizedInterfaces()->forEach(interface){
		participant.wsdlAnnotation(service);
		participant.port()->forEach(participantPort){
//			var port:WSDL::Port=interface.map Port(element,service,self);
			var port:WSDL::Port=participantPort.map Port(element,service,participant);
//			interface.wsdlAnnotation(port);
			participantPort.wsdlAnnotation(port);
		};
	};
	return;
}	
*/
//helper UML::Class::BindingDefinitionWsdlAnnotation(element:WSDL::Definition){
/* no longer used	
helper UML::Class::BindingDefinitionWsdlAnnotation(element:WSDL::Definition,port:UML::Port){
	var isReliability:Boolean=false;
	var isAuthentication:Boolean=false;
	self.wsdlAnnotation(element);
	//
	self.getRealizedInterfaces()->forEach(interface){
//		var binding:WSDL::Binding=interface.map Binding(self);
		var binding:WSDL::Binding=self.map Binding(port,element);
		interface.wsdlAnnotation(binding);
		
//		if(self.stereotypedBy(policyProfileAuthentication))then{
		if(self.isStereotypeApplied(policyAuthenticationStereotype))then{
			binding.eExtensibilityElements+=wspPolicyReference('#PasswordAuthenticationOverSSL');
			isAuthentication:=true;
		}else{}endif;
//		if(self.stereotypedBy(policyProfileReliability))then{
		if(self.isStereotypeApplied(policyReliabilityStereotype))then{
			binding.eExtensibilityElements+=wspPolicyReference('#ReliableMessaging');
			isReliability:=true;
		}else{}endif;
		
		var ePortType:WSDL::PortType=interface.map PortType(element);
		ePortType.eOperations->forEach(eOperation){
//			var eBindingOperation:WSDL::BindingOperation=eOperation.map BindingOperation(interface);
			var eBindingOperation:WSDL::BindingOperation=eOperation.map BindingOperation(self);
			var umlOperation:UML::BehavioralFeature=eOperation.findUmlOperation();
			eBindingOperation.setMpoModifiable();
			var eBindingInput:WSDL::BindingInput=eOperation.eInput.map BindingInput();
			var eBindingOutput:WSDL::BindingOutput=eOperation.eOutput.map BindingOutput();
			if(eBindingInput.oclIsUndefined())then{}else{
//				eBindingInput.eExtensibilityElements+=new SOAPBody(umlOperation.use(),eOperation.eInput.parts());
				new SOAPBody(umlOperation.use(),eOperation.eInput.parts(),eBindingInput);
// DEBUG temp suppress TODO: where is the failure?
				eBindingInput.setElementAttribute(wsawsNamespace,'wsaws:Action',umlOperation.soapActionURI());
			}endif;
			if(eBindingOutput.oclIsUndefined())then{}else{
//				eBindingOutput.eExtensibilityElements+=new SOAPBody(umlOperation.use(),eOperation.eOutput.parts(),eBindingOutput);
				new SOAPBody(umlOperation.use(),eOperation.eOutput.parts(),eBindingOutput);
				eBindingOutput.setElementAttribute(wsawsNamespace,'wsaws:Action',umlOperation.soapActionURI()+'Response');
			}endif;
			eOperation.eFaults->forEach(eFault){
				var eBindingFault:WSDL::BindingFault=eFault.map BindingFault();
				eBindingFault.eExtensibilityElements+=new SOAPFault(eFault.name,umlOperation.use());
			};
		};
	};
	if(isReliability)then{
		wspPolicyReliableMessaging(element); 
	}else{}endif;
	if(isAuthentication)then{
		wspPolicyAuthentication(element); 
	}else{}endif;
	
	return;
}	
*/
helper UML::Element::wsdlAnnotation(element:WSDL::WSDLElement){
/*
	// element-specific additional information
	var appinfoElement:OclAny=null;
	if(self.ownedComment->isEmpty())then{appinfoElement:=element.warning(appinfoElement,'undocumented element');}else{}endif;
	if(self.oclIsKindOf(UML::NamedElement))then{
		var prop:UML::NamedElement=self.oclAsType(UML::NamedElement);
		if(prop.name="")then{appinfoElement:=element.warning(appinfoElement,'unnamed element');}else{
			if(prop.name<>prop.getName())then{appinfoElement:=element.warning(appinfoElement,'original uml element name '+prop.name);}else{}endif;
		}endif;
	}else{}endif;
	if(self.oclIsKindOf(UML::BehavioralFeature))then{
		var bf:UML::BehavioralFeature=self.oclAsType(UML::BehavioralFeature);
		if(bf.ownedParameter->select(p|
			(p.direction=UML::ParameterDirectionKind::_in)or(p.direction=UML::ParameterDirectionKind::_inout)
			)->size()>1)then{appinfoElement:=element.warning(appinfoElement,'operation has more than 1 in parameter');}else{}endif;
		if(bf.ownedParameter->select(p|
			(p.direction=UML::ParameterDirectionKind::_out)or(p.direction=UML::ParameterDirectionKind::_inout)or(p.direction=UML::ParameterDirectionKind::_return)
			)->size()>1)then{appinfoElement:=element.warning(appinfoElement,'operation has more than 1 out parameter');}else{}endif;
	}else{}endif;
	if(element.oclIsKindOf(WSDL::Input))then{
		var prop:UML::NamedElement=self.oclAsType(UML::NamedElement);
		if(element.oclAsType(WSDL::Input).name<>prop.getName())then{appinfoElement:=element.warning(appinfoElement,'WSDL input name not unique within PortType, original name: '+prop.name);}else{}endif;
	}else{}endif;
	if(self.oclIsKindOf(UML::Parameter))then{
		var type:UML::Type=self.oclAsType(UML::Parameter).type;
		if(type.stereotypedBy(soaMLProfileMessageType))then{}else{appinfoElement:=element.warning(appinfoElement,'parameter type is not MessageType');}endif;
	}else{}endif;

	if(self.ownedComment->notEmpty())then{
		var documentationElement:OclAny=element.createDocumentationElement();
		self.ownedComment->forEach(comment){
			var userInformationElement:OclAny='documentation'.createChildElement(documentationElement);
			comment.body.setTextContent(userInformationElement);
		};
	}else{}endif;
	if(self.oclIsKindOf(UML::Classifier)and element.oclIsKindOf(WSDL::Service))then{
		// Application Information
		appinfoElement:=element.getAppinfoElement(appinfoElement);
		var umlelement:OclAny=self.createUmlElement(appinfoElement);
		self.wsdlServiceAnnotation(element,umlelement);
	}else{}endif;
	if(self.oclIsKindOf(UML::BehavioralFeature)and element.oclIsKindOf(WSDL::Operation))then{
		// Application Information
		appinfoElement:=element.getAppinfoElement(appinfoElement);
		var umlelement:OclAny=self.createUmlElement(appinfoElement);
		var serviceInterface:UML::Classifier=self.owner.oclAsType(UML::Classifier);
		self.oclAsType(UML::BehavioralFeature).wsdlOperationAnnotation(element,umlelement,serviceInterface);
	}else{}endif;
*/	
	return;
}	
/*
helper WSDL::WSDLElement::getAppinfoElement(appinfoElementIn:OclAny):OclAny{
	var appinfoElement:OclAny=appinfoElementIn;
	if(appinfoElement=null)then{
		appinfoElement:='appinfo'.createChildElement(self.createDocumentationElement());
		'source'.setAttribute(appinfoElement,umlAnnotationSource);
	}else{}endif;
	return appinfoElement;
}
helper WSDL::WSDLElement::warning(appinfoElementIn:OclAny,text:String):OclAny{
	var appinfoElement:OclAny=self.getAppinfoElement(appinfoElementIn);
	var warningElement:OclAny='warning'.createChildElement(appinfoElement);
	text.setTextValue(warningElement);
	return appinfoElement;
}
*/
helper UML::Element::wsdlServiceAnnotation(element:WSDL::WSDLElement,inout umlelement:OclAny){
/*
	var newLine:String='';
		var serviceInterface:UML::Classifier=self.oclAsType(UML::Classifier);
		var service:WSDL::Service=element.oclAsType(WSDL::Service);
			if(serviceInterface.getAllUsedInterfaces()->isEmpty())then{
					('WARNING: service has no used interfaces'+newLine).setTextValue('warning'.createChildElement(umlelement));
			}else{
				serviceInterface.getAllUsedInterfaces()->forEach(usedInterface){
					var usedInterfaceElement:OclAny='usedInterface'.createChildElement(umlelement);
					('uses interface (wsdl port) defined by '+usedInterface.qualifiedName+newLine).setTextValue(usedInterfaceElement);
					// find implementors
					var usedInterfaceImplementors:Set(UML::BehavioredClassifier)=
						uml.objectsOfType(UML::BehavioredClassifier)
						->select(e|e.getAllImplementedInterfaces()->includes(usedInterface));
					var usedServices:Set(UML::Classifier)=usedInterfaceImplementors;
					if(usedServices->isEmpty())then{usedServices:=Set{usedInterface};}else{}endif;
					usedServices->forEach(usedService){
						('defined in service  '+usedService.qualifiedName+newLine).setTextValue('usesServiceInterface'.createChildElement(usedInterfaceElement));
					};	
				};
			}endif;
			// find all ports which reference the serviceInterface
			uml.objectsOfType(UML::Port)->select(e|e.type=serviceInterface).classifier->select(c|c.oclIsKindOf(UML::Class)).oclAsType(UML::Class)->forEach(owningClass){
				//var participantElement:OclAny='participant'.createChildElement(umlelement);
				var participantElement:OclAny=owningClass.createUmlChildElement(umlelement,'implementedByParticipant',true);
				//('serviceInterface implemented by participant '+owningClass.qualifiedName+newLine).setTextValue(participantElement);
				// find architectures
				uml.objectsOfType(UML::Collaboration).role->select(e|e.type=owningClass)->forEach(collaborationRole){
					var systemArchitectureElement:OclAny='systemArchitecture'.createChildElement(participantElement);
					('participant '+owningClass.qualifiedName+' collaborates in  '+collaborationRole.oclAsType(UML::Property).owner.oclAsType(UML::NamedElement).qualifiedName+newLine).setTextValue(systemArchitectureElement);
					if(not(collaborationRole.owner.oclAsType(UML::Collaboration).collaborationRole->includes(collaborationRole)))then{
						('WARNING: participant is not a collaborationRole'+newLine).setTextValue('warning'.createChildElement(systemArchitectureElement));
					}else{}endif;
					// find contracts	
					collaborationRole.clientDependency.supplier
						->select(s|s.oclIsKindOf(UML::Property)and (s.oclAsType(UML::Property).type=serviceInterface))
						->forEach(contractProperty){
							var contract:UML::Collaboration=contractProperty.owner.oclAsType(UML::Collaboration);
							var contractElement:OclAny='contract'.createChildElement(systemArchitectureElement);
							('service contract '+contract.qualifiedName+newLine).setTextValue(contractElement);
							// get connectors
							contract.feature
								->select(c|
									c.oclIsKindOf(UML::Connector) 
									and (c.oclAsType(UML::Connector)._end.role->asSet()->includes(contractProperty.oclAsType(UML::ConnectableElement)))
									).oclAsType(UML::Connector)._end.role
								->select(r|r<>contractProperty)
								->forEach(otherContractProperty){
									var contractServiceInterfaceElement:OclAny='serviceInterface'.createChildElement(contractElement);
									('contract for serviceInterface '+otherContractProperty.type.qualifiedName+newLine).setTextValue(contractServiceInterfaceElement);
									otherContractProperty.getTargetDirectedRelationships().source
										->select(s|s.oclIsKindOf(UML::Property)).oclAsType(UML::Property).type
										->forEach(otherParticipant){
											var contractServiceInterfaceParticipantElement:OclAny='participant'.createChildElement(contractServiceInterfaceElement);
											('contract with participant '+otherParticipant.qualifiedName+newLine).setTextValue(contractServiceInterfaceParticipantElement);
										};
								};
							if(contract.classifierBehavior.oclIsUndefined())then{}else{contract.classifierBehavior.contractBehavior(contractElement,serviceInterface);}endif;	
					};
				};
				// find activityPartition
				uml.objectsOfType(UML::ActivityPartition)->select(e|e.represents=owningClass)->forEach(activityPartition){
					var activityPartitionElement:OclAny=activityPartition.createUmlChildElement(participantElement,'hasActivityPartition',false);
					'inActivity'.setAttribute(activityPartitionElement,activityPartition.inActivity.displayQualifiedName(serviceInterface));
					activityPartition.node->forEach(node){
						var nodeElement:OclAny=node.createUmlChildElement(activityPartitionElement,'hasNode',false);
						'name'.setAttribute(nodeElement,node.name);
						if(node.oclIsKindOf(UML::CallBehaviorAction))then{
							
						}else{}endif;
					};
				};
			};
			*/
	return;
}	
/*
helper UML::BehavioralFeature::wsdlOperationAnnotation(element:WSDL::WSDLElement,inout umlelement:OclAny,serviceInterface:UML::Classifier){
	// find all behavioral references to the feature
	if(self.oclIsKindOf(UML::Operation))then{
		var operation:UML::Operation=self.oclAsType(UML::Operation);
		uml.objectsOfType(UML::CallEvent)->select(e|e.operation=self)->forEach(callEvent){
			callEvent.wsdlEventAnnotation(element,umlelement,serviceInterface);
		};
		/ *
		uml.objectsOfType(UML::ReceiveOperationEvent)->select(e|e.operation=self)->forEach(callEvent){
			callEvent.wsdlEventAnnotation(element,umlelement,serviceInterface);
		};
		uml.objectsOfType(UML::SendOperationEvent)->select(e|e.operation=self)->forEach(callEvent){
			callEvent.wsdlEventAnnotation(element,umlelement,serviceInterface);
		};
		* /
	}else{
		var reception:UML::Reception=self.oclAsType(UML::Reception);
		var signal:UML::Signal=reception.signal;
		uml.objectsOfType(UML::SignalEvent)->select(e|e.signal=signal)->forEach(signalEvent){
			signalEvent.wsdlSignalEventAnnotation(element,umlelement,serviceInterface);
		};
		/ *
	
}		uml.objectsOfType(UML::SendSignalEvent)->select(e|e.signal=signal)->forEach(signalEvent){
			signalEvent.wsdlSignalEventAnnotation(element,umlelement,serviceInterface);
		};
		uml.objectsOfType(UML::ReceiveSignalEvent)->select(e|e.signal=signal)->forEach(signalEvent){
			signalEvent.wsdlSignalEventAnnotation(element,umlelement,serviceInterface);
		};
		* /
 
	}endif;
	return;
}
	
helper UML::Event::wsdlSignalEventAnnotation(element:WSDL::WSDLElement,inout umlelement:OclAny,serviceInterface:UML::Classifier){
	var eventElement:OclAny=self.createUmlChildElement(umlelement,'event',false);
	uml.objectsOfType(UML::OccurrenceSpecification)->select(s|(s.event=self)and(s.isCoveredType(serviceInterface)))->forEach(occurrence){
		var fragmentElement:OclAny=occurrence.createUmlChildElement(eventElement,'interaction',false);
		occurrence.interactionFragmentSequence(fragmentElement,serviceInterface,true);
	};
	return;
}	
helper UML::Event::wsdlEventAnnotation(element:WSDL::WSDLElement,inout umlelement:OclAny,serviceInterface:UML::Classifier){
	var eventElement:OclAny=self.createUmlChildElement(umlelement,'event',false);
	uml.objectsOfType(UML::OccurrenceSpecification)->select(s|s.event=self)->forEach(occurrence){
		var fragmentElement:OclAny=occurrence.createUmlChildElement(eventElement,'interaction',false);
		occurrence.interactionFragmentSequence(fragmentElement,serviceInterface,true);
	};
	return;
}	

helper UML::NamedElement::createUmlChildElement(inout parentElement:OclAny,label:String,includeName:Boolean):OclAny{
	var interactionElement:OclAny=label.createChildElement(parentElement);
	if(includeName)then{'qualifiedName'.setAttribute(interactionElement,self.qualifiedName);}else{}endif;
	'metaClass'.setAttribute(interactionElement,self.oclAsType(ECORE::EObject).eClass().name);
	return interactionElement;
}
helper UML::Behavior::contractBehavior(inout contractElement:OclAny,serviceInterface:UML::Classifier){
	var interactionElement:OclAny=self.createUmlChildElement(contractElement,'contractBehavior',true);
	if(self.oclIsKindOf(UML::Interaction))then{
		var interaction:UML::Interaction=self.oclAsType(UML::Interaction);
		interaction.fragment->forEach(fragment){
			var fragmentElement:OclAny=fragment.createUmlChildElement(interactionElement,'fragment',false);
			fragment.interactionFragment(fragmentElement,serviceInterface);
		};
	}else{}endif;	
	return;
}	
*/	
helper UML::NamedElement::displayQualifiedName(serviceInterface:UML::NamedElement):String{
	if(self=serviceInterface)then{return 'this';}else{}endif;
	return self.qualifiedName;
}
//helper UML::InteractionFragment::getCoveredType():UML::Type=self.covered.represents.type->asSequence()->first();
helper UML::InteractionFragment::getCoveredTypes():Set(UML::Type)=self.covered.represents.type->asSet();
helper UML::InteractionFragment::isCoveredType(type:UML::Type):Boolean=self.covered.represents.type->includes(type);
helper UML::InteractionFragment::interactionFragmentSequence(inout fragmentElement:OclAny,serviceInterface:UML::Classifier,useDelegation:Boolean){
	//  get prior and next
	if(self.enclosingInteraction.oclIsUndefined())then{
		if(self.enclosingOperand.oclIsUndefined())then{}else{
			self.fromToInteraction(self.enclosingOperand.fragment,fragmentElement,serviceInterface,useDelegation);
		}endif;
	}else{
		self.fromToInteraction(self.enclosingInteraction.fragment,fragmentElement,serviceInterface,useDelegation);
	}endif;
}	
helper UML::InteractionFragment::interactionFragment(inout fragmentElement:OclAny,serviceInterface:UML::Classifier){
	//  get prior and next
	self.interactionFragmentSequence(fragmentElement,serviceInterface,false);
	/*
	if(self.oclIsKindOf(UML::MessageOccurrenceSpecification))then{
		var sendMOS:UML::MessageOccurrenceSpecification=self.oclAsType(UML::MessageOccurrenceSpecification);
		var fromTypes:Set(UML::Type)=sendMOS.getCoveredTypes();
		fromTypes->forEach(fromType){
			var fromClassifier:String=fromType.displayQualifiedName(serviceInterface);
			var fromElement:OclAny=fromType.createUmlChildElement(fragmentElement,'from',false);
			'serviceInterface'.setAttribute(fromElement,fromClassifier);
		};
		var event:UML::Event=sendMOS.event;
		if(event.oclIsUndefined())then{}else{
			var fromEvent:String=event.oclAsType(ECORE::EObject).eClass().name;
			'event'.setAttribute(fragmentElement,fromEvent);
			if(event.oclIsKindOf(UML::CallEvent))then{
				var operation:UML::Operation=event.oclAsType(UML::CallEvent).operation;
				'operation'.setAttribute(fragmentElement,operation.owner.oclAsType(UML::NamedElement).displayQualifiedName(serviceInterface)+'::'+operation.name);
			}else{}endif;
//			if(event.oclIsKindOf(UML::SendSignalEvent))then{
//				var signal:UML::Signal=event.oclAsType(UML::SendSignalEvent).signal;
			if(event.oclIsKindOf(UML::SignalEvent))then{
				var signal:UML::Signal=event.oclAsType(UML::SignalEvent).signal;
				'signal'.setAttribute(fragmentElement,signal.displayQualifiedName(serviceInterface));
			}else{}endif;
		}endif;
	}else{}endif;
	if(self.oclIsKindOf(UML::CombinedFragment))then{
		var combinedFragment:UML::CombinedFragment=self.oclAsType(UML::CombinedFragment);
		combinedFragment.operand->forEach(operand){
			var operandElement:OclAny=operand.createUmlChildElement(fragmentElement,'operand',false);
			operand.interactionFragment(operandElement,serviceInterface);
		};
	}else{}endif;	
	if(self.oclIsKindOf(UML::InteractionOperand))then{
		var interactionOperandFragment:UML::InteractionOperand=self.oclAsType(UML::InteractionOperand);
		interactionOperandFragment.fragment->forEach(fragment){
			var operandfragmentElement:OclAny=fragment.createUmlChildElement(fragmentElement,'fragment',false);
			fragment.interactionFragment(operandfragmentElement,serviceInterface);
		};
	}else{}endif;	
	if(self.oclIsKindOf(UML::ExecutionSpecification))then{
		var executionSpecification:UML::ExecutionSpecification=self.oclAsType(UML::ExecutionSpecification);
		var start:UML::OccurrenceSpecification=executionSpecification.start;
		var finish:UML::OccurrenceSpecification=executionSpecification.finish;
		
		if(start.oclIsUndefined())then{}else{
			var fromTypes:Set(UML::Type)=start.getCoveredTypes();
			fromTypes->forEach(fromType){
				var fromClassifier:String=fromType.displayQualifiedName(serviceInterface);
				var fromElement:OclAny=fromType.createUmlChildElement(fragmentElement,'start',false);
				'serviceInterface'.setAttribute(fromElement,fromClassifier);
			};
		}endif;

		if(finish.oclIsUndefined())then{}else{
			var fromTypes:Set(UML::Type)=finish.getCoveredTypes();
			fromTypes->forEach(fromType){
				var fromClassifier:String=fromType.displayQualifiedName(serviceInterface);
				var fromElement:OclAny=fromType.createUmlChildElement(fragmentElement,'finish',false);
				'serviceInterface'.setAttribute(fromElement,fromClassifier);
			};
		}endif;

	}else{}endif;	
	*/	
	return;
}	
helper UML::InteractionFragment::getFromFragment(fragmentsIn:OrderedSet(UML::InteractionFragment),
	serviceInterface:UML::Classifier,useDelegation:Boolean):UML::InteractionFragment{
	var fragments:OrderedSet(UML::InteractionFragment)=fragmentsIn;
	if(useDelegation)then{
		fragments:=fragmentsIn->select(f|f.oclIsKindOf(UML::MessageOccurrenceSpecification));
	}else{}endif;
	var myIndex:Integer=fragments->indexOf(self);
	if(myIndex>1)then{
		var fromFragment:UML::InteractionFragment=fragments->at(myIndex-1);
		/*
		if(useDelegation and (fromFragment.isCoveredType(serviceInterface)))then{
			var fromPriorFragment:UML::InteractionFragment=fromFragment.getFromFragment(fragments,serviceInterface,useDelegation);
			if(fromPriorFragment=null)then{}else{return fromPriorFragment;}endif;
		}else{}endif;
		*/
		return fromFragment;
	}else{}endif;
	return null;
}	
query UML::InteractionFragment::isCombinedMOS():Boolean=
	self.oclIsKindOf(UML::MessageOccurrenceSpecification)or self.oclIsKindOf(UML::CombinedFragment);
query UML::CombinedFragment::getNestedMessageOccurrenceSpecifications(serviceInterface:UML::Classifier):Set(UML::MessageOccurrenceSpecification){
	var operands:Set(UML::InteractionOperand)=self.operand
		->select(o|o.fragment->select(f|f.isCombinedMOS())->first().isCoveredType(serviceInterface))
		->select(o|o.fragment->select(f|f.isCombinedMOS())->size()>1 or o.fragment->select(f|f.oclIsKindOf(UML::CombinedFragment))->notEmpty());
	var fragments:Set(UML::InteractionFragment)=operands
		->collect(o|
			if(o.fragment->first().oclIsKindOf(UML::CombinedFragment))
			then o.fragment->first()
			else o.fragment->select(f|f.isCombinedMOS())->at(2)
			endif
			)
		->asSet();	
	return fragments
				->collect(f|
					if(f.oclIsKindOf(UML::MessageOccurrenceSpecification))
					then Set{f.oclAsType(UML::MessageOccurrenceSpecification)}
					else f.oclAsType(UML::CombinedFragment).getNestedMessageOccurrenceSpecifications(serviceInterface)
					endif
				)	
		->asSet();
}
helper UML::InteractionFragment::getToFragments(fragmentsIn:OrderedSet(UML::InteractionFragment),
	serviceInterface:UML::Classifier,useDelegation:Boolean):Set(UML::InteractionFragment){
	var fragments:OrderedSet(UML::InteractionFragment)=fragmentsIn;
	if(useDelegation)then{
		fragments:=fragmentsIn->select(f|f.isCombinedMOS());
	}else{}endif;
	var myIndex:Integer=fragments->indexOf(self);
	if(myIndex<fragments->size())then{
		var toFragment:UML::InteractionFragment=fragments->at(myIndex+1);
		/*
		if(useDelegation and (toFragment.isCoveredType(serviceInterface)))then{
			var toPriorFragment:UML::InteractionFragment=toFragment.getToFragment(fragments,serviceInterface,useDelegation);
			if(toPriorFragment=null)then{}else{return toPriorFragment;}endif;
		}else{}endif;
		*/
		if(useDelegation and (toFragment.oclIsKindOf(UML::CombinedFragment)))then{
			return toFragment.oclAsType(UML::CombinedFragment).getNestedMessageOccurrenceSpecifications(serviceInterface);
		}else{}endif;
		return OrderedSet{toFragment};
	}else{}endif;
	return null;
}	
helper UML::InteractionFragment::fromToInteraction(fragments:OrderedSet(UML::InteractionFragment),
	inout fragmentElement:OclAny,serviceInterface:UML::Classifier,useDelegation:Boolean){
	if(fragments->includes(self))then{}else{return;}endif;
	/*
	var fromFragment:UML::InteractionFragment=self.getFromFragment(fragments,serviceInterface,useDelegation);
	var toFragments:Set(UML::InteractionFragment)=self.getToFragments(fragments,serviceInterface,useDelegation);
	if(fromFragment<>null)then{
		//var fromType:UML::Type=fromFragment.getCoveredType();
		//'from'.setAttribute(fragmentElement,fromType.displayQualifiedName(serviceInterface));
		var fromTypes:Set(UML::Type)=fromFragment.getCoveredTypes();
		fromTypes->forEach(fromType){
			var fromClassifier:String=fromType.displayQualifiedName(serviceInterface);
			var fromElement:OclAny=fromType.createUmlChildElement(fragmentElement,'from',false);
			'serviceInterface'.setAttribute(fromElement,fromClassifier);
		};
	}else{}endif;
	toFragments->forEach(toFragment){
		var toElement:OclAny=toFragment.createUmlChildElement(fragmentElement,'to',false);
		//var fromType:UML::Type=toFragment.getCoveredType();
		//'to'.setAttribute(fragmentElement,fromType.displayQualifiedName(serviceInterface));
		var toTypes:Set(UML::Type)=toFragment.getCoveredTypes();
		toTypes->forEach(fromType){
			var fromClassifier:String=fromType.displayQualifiedName(serviceInterface);
			var fromElement:OclAny=fromType.createUmlChildElement(toElement,'type',false);
			'serviceInterface'.setAttribute(fromElement,fromClassifier);
		};
		if(toFragment.enclosingOperand.oclIsUndefined())then{}else{
			if(toFragment.enclosingOperand.guard.oclIsUndefined())then{}else{
				if(toFragment.enclosingOperand.guard.specification.oclIsUndefined())then{}else{
					'guard'.setAttribute(toElement,toFragment.enclosingOperand.guard.specification.stringValue());
				}endif;
			}endif;
		}endif;
		if(toFragment.oclIsKindOf(UML::OccurrenceSpecification)
			and not(toFragment.oclAsType(UML::OccurrenceSpecification).event.oclIsUndefined()))then{
			var event:UML::Event=toFragment.oclAsType(UML::OccurrenceSpecification).event;
			'toEventMetaClass'.setAttribute(toElement,event.oclAsType(ECORE::EObject).eClass().name);
			if(event.oclIsKindOf(UML::CallEvent))then{
				'toOperation'.setAttribute(toElement,event.oclAsType(UML::CallEvent).operation.name);
			}else{}endif;
			if(event.oclIsKindOf(UML::ReceiveOperationEvent))then{
				'toOperation'.setAttribute(toElement,event.oclAsType(UML::ReceiveOperationEvent).operation.name);
			}else{}endif;
			if(event.oclIsKindOf(UML::SendOperationEvent))then{
				'toOperation'.setAttribute(toElement,event.oclAsType(UML::SendOperationEvent).operation.name);
			}else{}endif;
			if(event.oclIsKindOf(UML::SignalEvent))then{
				'toSignal'.setAttribute(toElement,event.oclAsType(UML::SignalEvent).signal.qualifiedName);
			}else{}endif;
			if(event.oclIsKindOf(UML::SendSignalEvent))then{
				'toSignal'.setAttribute(toElement,event.oclAsType(UML::SendSignalEvent).signal.qualifiedName);
			}else{}endif;
			if(event.oclIsKindOf(UML::ReceiveSignalEvent))then{
				'toSignal'.setAttribute(toElement,event.oclAsType(UML::ReceiveSignalEvent).signal.qualifiedName);
			}else{}endif;
		}else{}endif;
	};
	*/
	return;
}	
////////////////////////////////////////////was GRAsoaml2wsdl

property wsdlNamespace:String='http://schemas.xmlsoap.org/wsdl/';
property soapNamespace:String='http://schemas.xmlsoap.org/wsdl/soap/';
property soapPrefix:String='soap';
property wsawsNamespace:String='http://www.w3.org/2006/05/addressing/wsdl';
property wsawsPrefix:String='wsaws';
property wspNamespace:String='http://schemas.xmlsoap.org/ws/2004/09/policy';
property wspPrefix:String='wsp';
property wsuNamespace:String='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd';
property wsuPrefix:String='wsu';
property wsrmNamespace:String='http://schemas.xmlsoap.org/ws/2005/02/rm/policy';
property wsrmPrefix:String='wsrm';
property spNamespace:String='http://schemas.xmlsoap.org/ws/2005/07/securitypolicy';
property spPrefix:String='sp';

//property mpoNamespace:String='http://modelDriven.org/schema/modelPro/override';
//property mpoPrefix:String='mpo';
////////////////////abstract methods
//abstract helper UML::Collaboration::ServiceDefinitionWsdlAnnotation(element:WSDL::Definition);
//abstract helper UML::Artifact::ServiceDefinitionWsdlAnnotation(element:WSDL::Definition);
//abstract helper UML::Class::BindingDefinitionWsdlAnnotation(element:WSDL::Definition,port:UML::Port);
//abstract helper UML::Classifier::DefinitionWsdlAnnotation(element:WSDL::WSDLElement);

//abstract helper UML::Class::JavaService();
///////////////////////////////queries and helpers
query WSDL::Input::parts():String="request";
query WSDL::Output::parts():String="response";
query WSDL::WSDLElement::getContainer():WSDL::WSDLElement=self.oclAsType(CMOF::EObject).eContainer().oclAsType(WSDL::WSDLElement);

query WSDL::Operation::findUmlOperation(context:UML::Class):UML::BehavioralFeature{
	//return self.allBehavioralFeatures()->select(f|(f.map Operation())=wsdlOperation)->first();
//	return wsdlOperation.invresolveoneIn(BindingOperation);
//	return wsdlOperation.invresolveoneIn(UML::BehavioralFeature::Operation);
//	return self.invresolveone(UML::BehavioralFeature);
	var ifcOperation:UML::BehavioralFeature=self.invresolveone(UML::BehavioralFeature);
	context.ownedOperation->select(o|o.name=ifcOperation.name)->forEach(bindingOperation){
		ifcOperation:=bindingOperation;
	};
	// find operation in Class
	return ifcOperation;
//	return self.invresolveone(UML::Operation);
}
/*
helper WSDL::WSDLElement::setMpoModifiable(){
	//  provide some indicator as to whether or not this segment is modifiable
	self.setElementAttribute(mpoNamespace,'mpo:modifiable','');
}
*/
////////////////////////////extensions
constructor SOAP::SOAPAddress::SOAPAddress(locationURIin:String){
	locationURI:=locationURIin;
}

constructor SOAP::SOAPFault::SOAPFault(nameIn:String,useIn:String){
	name:=nameIn;
	use:=useIn;
}

constructor SOAP::SOAPBinding::SOAPBinding(transportURIin:String,stylein:String){
	transportURI:=transportURIin;
	style:=stylein;
}
constructor SOAP::SOAPBody::SOAPBody(useIn:String,partsIn:String,inout eBinding:WSDL::ExtensibleElement){
	use:=useIn;
	eBinding.eExtensibilityElements+=result;
	// defer this until containment setup?
	result.setElementAttribute('parts',partsIn);

}
constructor SOAP::SOAPOperation::SOAPOperation(soapActionIn:String,stylein:String){
	soapActionURI:=soapActionIn;
	style:=stylein;
}

constructor WSDL::UnknownExtensibilityElement::UnknownExtensibilityElement(namespace:String,name:String){
	result.setElementType(namespace,name);
}
constructor WSDL::Namespace::Namespace(uriIn:String,prefixIn:String){
	URI:=uriIn;
	prefix:=prefixIn;
}
	
helper wsawsUsingAddressing(inout extensibleElement:WSDL::ExtensibleElement):WSDL::UnknownExtensibilityElement{
	var wsawsUsingAddressing:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wsawsNamespace,'UsingAddressing');
	extensibleElement.eExtensibilityElements+=wsawsUsingAddressing;
	
	wsawsUsingAddressing.setElementAttribute(wsdlNamespace,'wsdl:required','true');
	return wsawsUsingAddressing;
}
helper wsrmRMAssertion():WSDL::UnknownExtensibilityElement{
	var wsrmRMAssertion:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wsrmNamespace,'RMAssertion');
	return wsrmRMAssertion;
}

/*
	
helper wspPolicyReference(uri:String):WSDL::UnknownExtensibilityElement{
	var wspPolicyReference:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'PolicyReference');
	wspPolicyReference.setElementAttribute('URI',uri);
	return wspPolicyReference;
}
helper wspPolicyReliableMessaging(inout element:WSDL::ExtensibleElement){
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	element.eExtensibilityElements+=wspPolicy;
	wspPolicy.setElementAttribute(wsuNamespace,'wsu:Id','ReliableMessaging');
	var wspExactlyOne:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'ExactlyOne');
	wspPolicy.children+=wspExactlyOne;
	var wspEAll:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'All');
	wspExactlyOne.children+=wspEAll;
	wspEAll.children+=wsawsUsingAddressing();
	wspEAll.children+=wsrmRMAssertion();
	return;
}
helper wspPolicyAuthentication(inout element:WSDL::ExtensibleElement){
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	element.eExtensibilityElements+=wspPolicy;
	wspPolicy.setElementAttribute(wsuNamespace,'wsu:Id','PasswordAuthenticationOverSSL');
	var wspExactlyOne:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'ExactlyOne');
	wspPolicy.children+=wspExactlyOne;
	var wspEAll:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'All');
	wspExactlyOne.children+=wspEAll;
	spSymmetricBinding(wspEAll);
	spWss11(wspEAll);
	spTrust10(wspEAll);
	return;
}
helper spWss11(inout element:WSDL::UnknownExtensibilityElement){
	var spWss11:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Wss11');
	element.children+=spWss11;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spWss11.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefKeyIdentifier');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefIssuerSerial');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefThumbprint');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefEncryptedKey');
	return;
}
helper spTrust10(inout element:WSDL::UnknownExtensibilityElement){
	var spTrust10:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Trust10');
	element.children+=spTrust10;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spTrust10.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireClientEntropy');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireServerEntropy');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportIssuedTokens');
	return;
}
helper spLayout(inout element:WSDL::UnknownExtensibilityElement,layoutPolicy:String){
	var spLayout:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Layout');
	element.children+=spLayout;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spLayout.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,layoutPolicy);
	return;
}
helper spAlgorithmSuite(inout element:WSDL::UnknownExtensibilityElement){
	var spAlgorithmSuite:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'AlgorithmSuite');
	element.children+=spAlgorithmSuite;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spAlgorithmSuite.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'Basic128');
	return;
}
helper spSymmetricBinding(inout element:WSDL::UnknownExtensibilityElement){
	var spSymmetricBinding:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SymmetricBinding');
	element.children+=spSymmetricBinding;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spSymmetricBinding.children+=wspPolicy;
	spProtectionToken(wspPolicy);
	spLayout(wspPolicy,'Strict');
	spAlgorithmSuite(wspPolicy);
	return;
}
helper spProtectionToken(inout element:WSDL::UnknownExtensibilityElement){
	var spProtectionToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'ProtectionToken');
	element.children+=spProtectionToken;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spProtectionToken.children+=wspPolicy;
	spSecureConversationToken(wspPolicy);
	return;
}
helper spSecureConversationToken(inout element:WSDL::UnknownExtensibilityElement){
	var spSecureConversationToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SecureConversationToken');
	element.children+=spSecureConversationToken;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spSecureConversationToken.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireDerivedKeys');
	spBootstrapPolicy(wspPolicy);
	return;
}
helper spBootstrapPolicy(inout element:WSDL::UnknownExtensibilityElement){
	var spBootstrapPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'BootstrapPolicy');
	element.children+=spBootstrapPolicy;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spBootstrapPolicy.children+=wspPolicy;
	spTransportBinding(wspPolicy);
	spSignedSupportingTokens(wspPolicy);
	spWss10(wspPolicy);
	var encryptedParts:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'EncryptedParts');
	wspPolicy.children+=encryptedParts;
	encryptedParts.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'Body');
	var signedParts:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SignedParts');
	wspPolicy.children+=signedParts;
	signedParts.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'Body');
	spHeader(signedParts,'To','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'From','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'FaultTo','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'ReplyTo','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'MessageID','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'RelatesTo','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'Action','http://www.w3.org/2005/08/addressing');
	spHeader(signedParts,'AckRequested','http://schemas.xmlsoap.org/ws/2005/02/rm');
	spHeader(signedParts,'SequenceAcknowledgement','http://schemas.xmlsoap.org/ws/2005/02/rm');
	spHeader(signedParts,'Sequence','http://schemas.xmlsoap.org/ws/2005/02/rm');
	return;
}
helper spHeader(inout element:WSDL::UnknownExtensibilityElement,name:String,namespace:String){
	var spHeader:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Header');
	element.children+=spHeader;
	spHeader.setElementAttribute('Name',name);
	spHeader.setElementAttribute('Namespace',namespace);
	return;
}
helper spWss10(inout element:WSDL::UnknownExtensibilityElement){
	var spWss10:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Wss10');
	element.children+=spWss10;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spWss10.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefKeyIdentifier');
	return;
}
helper spSignedSupportingTokens(inout element:WSDL::UnknownExtensibilityElement){
	var spSignedSupportingTokens:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SignedSupportingTokens');
	element.children+=spSignedSupportingTokens;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spSignedSupportingTokens.children+=wspPolicy;
	spUsernameToken(wspPolicy);
	return;
}
helper spUsernameToken(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SignedSupportingTokens');
	element.children+=spUsernameToken;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spUsernameToken.children+=wspPolicy;
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'WssUsernameToken10');
	return;
}
helper spTransportBinding(inout element:WSDL::UnknownExtensibilityElement){
	var spTransportBinding:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'TransportBinding');
	element.children+=spTransportBinding;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spTransportBinding.children+=wspPolicy;
	spTransportToken(wspPolicy);
	spLayout(wspPolicy,'Lax');
	wspPolicy.children+=new WSDL::UnknownExtensibilityElement(spNamespace,'IncludeTimestamp');
	spAlgorithmSuite(wspPolicy);
	return;
}
helper spTransportToken(inout element:WSDL::UnknownExtensibilityElement){
	var spTransportToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'TransportToken');
	element.children+=spTransportToken;
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	spTransportToken.children+=wspPolicy;
	spHttpsToken(wspPolicy);
	return;
}
helper spHttpsToken(inout element:WSDL::UnknownExtensibilityElement){
	var spHttpsToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'HttpsToken');
	element.children+=spHttpsToken;
	spHttpsToken.setElementAttribute('spHttpsToken','false');
	return;
}
*/	        
//////////////////////////////////////////////////////////////////////////////////////////wsdl leaf mapping
// possible mapping:
//		<<Participant>> is Definition
//		port.type (ServiceInterface) is Service
//		<<ServiceInterface>> is service  
//		realized interface is service port
//			service port-->1 binding
//			binding-->1 portType
//		Interface is portType 


//      architecture-->* participant-->*port-->1 serviceInterface -->(1?)interface
//		definition  -->* service    -->*port -->1 binding         -->1 portType
//	
helper UML::InstanceSpecification::mapPolicy(inout element:WSDL::ExtensibleElement):WSDL::UnknownExtensibilityElement@wsdl{
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	element.eExtensibilityElements+=wspPolicy;
	wspPolicy.updateElement();	
	self.slot->select(s|s.definingFeature.name='ExactlyOne').wspExactlyOne(wspPolicy);
	var Id:String=self.name;
	if(not(Id.oclIsUndefined()))then{
		wspPolicy.setElementAttribute(wsuNamespace,'wsu:Id',Id);
	}endif;
	
	return wspPolicy;
} 
helper UML::InstanceSpecification::mapNestedPolicy(inout element:WSDL::UnknownExtensibilityElement):WSDL::UnknownExtensibilityElement@wsdl{
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');
	element.children+=wspPolicy;
	wspPolicy.updateElement();	
	self.slot->select(s|s.definingFeature.name='ExactlyOne').wspExactlyOne(wspPolicy);
	var Id:String=self.name;
	if(not(Id.oclIsUndefined()))then{
		wspPolicy.setElementAttribute(wsuNamespace,'wsu:Id',Id);
	}endif;
	
	return wspPolicy;
} 
helper UML::InstanceSpecification::EndpointReference(inout element:WSDL::ExtensibleElement):WSDL::UnknownExtensibilityElement@wsdl{
	var wspPolicy:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement('http://www.w3.org/2005/08/addressing','EndpointReference');
	element.eExtensibilityElements+=wspPolicy;
	
	wspPolicy.updateElement();	

//	self.slot.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(wspPolicy);
	self.slot.mapSlot(wspPolicy);
	
	return wspPolicy;
} 
	
helper UML::Slot::wspExactlyOne(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'ExactlyOne');
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspExactlyOneStereotype);
	element.children+=spUsernameToken;
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}

helper UML::InstanceSpecification::expressionOperand(inout expression:WSDL::UnknownExtensibilityElement){
	log('expressionOperand '+self.toString()+', '+expression.toString());
/*		
	switch{
		case(self.isSpX509Token()){
			self.spX509Token(expression);			
		};
		case(self.isSpWssX509V3Token10()){
			self.spWssX509V3Token10(expression);			
		};
		case(self.isSpRequireIssuerSerialReference()){
			self.spRequireIssuerSerialReference(expression);			
		};
		case(self.isSpStrict()){
			self.spStrict(expression);			
		};
		case(self.isSpBasic256Sha256()){
			self.spBasic256Sha256(expression);			
		};
		case(self.isSpEndorsingSupportingTokens()){
			self.spEndorsingSupportingTokens(expression);			
		};
		case(self.isSpIssuedToken()){
			self.spIssuedToken(expression);			
		};
		case(self.isSpRequestSecurityTokenTemplate()){
			self.spRequestSecurityTokenTemplate(expression);			
		};
		case(self.isSpRequireDerivedKeys()){
			self.spRequireDerivedKeys(expression);			
		};
		case(self.isSpRequireInternalReference()){
			self.spRequireInternalReference(expression);			
		};
		case(self.isTKeyType()){
			self.tKeyType(expression);			
		};
		case(self.isTKeySize()){
			self.tKeySize(expression);			
		};
		case(self.isTEncryptWith()){
			self.tEncryptWith(expression);			
		};
		case(self.isTSignWith()){
			self.tSignWith(expression);			
		};
		case(self.isTCanonicalizationAlgorithm()){
			self.tCanonicalizationAlgorithm(expression);			
		};
		case(self.isTEncryptionAlgorithm()){
			self.tEncryptionAlgorithm(expression);			
		};
		
		
		
		case(self.isSpBody()){
			self.spBody(expression);			
		};
		case(self.isSpHeader()){
			self.spHeader(expression);			
		};
		case(self.isSpMustSupportRefIssuerSerial()){
			self.SsMustSupportRefIssuerSerial(expression);			
		};
	
	case(self.isWspExactlyOne()){
			self.wspExactlyOne(expression);			
		};
		case(self.isWspAll()){
			self.wspAll(expression);			
		};
		case(self.isWsawUsingAddressing()){
			self.wsawUsingAddressing(expression);			
		};
		case(self.isWsrmRMAssertion()){
			self.wsrmRMAssertion(expression);			
		};
		case(self.isWsrmInactivityTimeout()){
			self.wsrmInactivityTimeout(expression);			
		};
		case(self.isWsrmAcknowledgementInterval()){
			self.wsrmAcknowledgementInterval(expression);			
		};
		case(self.isWspPolicy()){
			self.wspPolicy(expression);			
		};
		case(self.isSpAsymmetricBinding()){
			self.spAsymmetricBinding(expression);			
		};
		case(self.isWspPolicyReference()){
			self.wspPolicyReference(expression);			
		};
		////////////////////
		case(self.isSpInitiatorToken()){
			self.spInitiatorToken(expression);			
		};
		case(self.isSpRecipientToken()){
			self.spRecipientToken(expression);			
		};
		case(self.isSpLayout()){
			self.spLayout(expression);			
		};
		case(self.isSpIncludeTimestamp()){
			self.spIncludeTimestamp(expression);			
		};
		case(self.isSpOnlySignEntireHeadersAndBody()){
			self.spOnlySignEntireHeadersAndBody(expression);			
		};
		case(self.isSpAlgorithmSuite()){
			self.spAlgorithmSuite(expression);			
		};
		case(self.isSpWss10()){
			self.spWss10(expression);			
		};
		case(self.isWssX509V3Token10()){
			self.WssX509V3Token10(expression);			
		};
		
		case(self.isSpEncryptedParts()){
			self.spEncryptedParts(expression);			
		};
		case(self.isSpSignedParts()){
			self.spSignedParts(expression);			
		};
		else{
			log('ERROR: unsupported wsp::Expression choice '+self.repr());
		};
	};
*/		
	self.extensibleElementCommon(expression);
	return;
}
query UML::InstanceSpecification::isPolicy():Boolean=self.classifier->exists(c|c.name='Policy');
query UML::InstanceSpecification::isPolicyReference():Boolean=self.classifier->exists(c|c.name='PolicyReference');
query UML::InstanceSpecification::isEndpointReference():Boolean=self.classifier->exists(c|c.name='EndpointReference');
/*
query UML::InstanceSpecification::isSpX509Token():Boolean=self.classifier->exists(c|c.name='X509Token');	
query UML::InstanceSpecification::isSpWssX509V3Token10():Boolean=self.classifier->exists(c|c.name='X509V3Token10');	
query UML::InstanceSpecification::isSpRequireIssuerSerialReference():Boolean=self.classifier->exists(c|c.name='RequireIssuerSerialReference');	
query UML::InstanceSpecification::isSpStrict():Boolean=self.classifier->exists(c|c.name='Strict');	
query UML::InstanceSpecification::isSpBasic256Sha256():Boolean=self.classifier->exists(c|c.name='Basic256Sha256');	
query UML::InstanceSpecification::isSpEndorsingSupportingTokens():Boolean=self.classifier->exists(c|c.name='EndorsingSupportingTokens');	
query UML::InstanceSpecification::isSpIssuedToken():Boolean=self.classifier->exists(c|c.name='IssuedToken');	
query UML::InstanceSpecification::isSpRequestSecurityTokenTemplate():Boolean=self.classifier->exists(c|c.name='RequestSecurityTokenTemplate');	
query UML::InstanceSpecification::isSpRequireDerivedKeys():Boolean=self.classifier->exists(c|c.name='RequireDerivedKeys');	
	
		
query UML::InstanceSpecification::isSpRequireInternalReference():Boolean=self.classifier->exists(c|c.name='RequireInternalReference');	
query UML::InstanceSpecification::isTKeyType():Boolean=self.classifier->exists(c|c.name='KeyType');	
query UML::InstanceSpecification::isTKeySize():Boolean=self.classifier->exists(c|c.name='KeySize');	
query UML::InstanceSpecification::isTEncryptWith():Boolean=self.classifier->exists(c|c.name='EncryptWith');	
query UML::InstanceSpecification::isTSignWith():Boolean=self.classifier->exists(c|c.name='SignWith');	
query UML::InstanceSpecification::isTCanonicalizationAlgorithm():Boolean=self.classifier->exists(c|c.name='CanonicalizationAlgorithm');	
query UML::InstanceSpecification::isTEncryptionAlgorithm():Boolean=self.classifier->exists(c|c.name='EncryptionAlgorithm');	
	


query UML::InstanceSpecification::isSpBody():Boolean=self.classifier->exists(c|c.name='Body');	
query UML::InstanceSpecification::isSpHeader():Boolean=self.classifier->exists(c|c.name='Header');	
query UML::InstanceSpecification::isSpMustSupportRefIssuerSerial():Boolean=self.classifier->exists(c|c.name='MustSupportRefIssuerSerial');	
query UML::InstanceSpecification::isWspExactlyOne():Boolean=self.classifier->exists(c|c.name='ExactlyOne');	
query UML::InstanceSpecification::isWspAll():Boolean=self.classifier->exists(c|c.name='All');	
query UML::InstanceSpecification::isWsawUsingAddressing():Boolean=self.classifier->exists(c|c.name='UsingAddressing');	
	query UML::InstanceSpecification::isWsrmRMAssertion():Boolean=self.classifier->exists(c|c.name='RMAssertion');	
	query UML::InstanceSpecification::isWsrmInactivityTimeout():Boolean=self.classifier->exists(c|c.name='WsrmInactivityTimeout');	
	query UML::InstanceSpecification::isWsrmAcknowledgementInterval():Boolean=self.classifier->exists(c|c.name='AcknowledgementInterval');	
	query UML::InstanceSpecification::isWspPolicy():Boolean=self.classifier->exists(c|c.name='Policy');	
	query UML::InstanceSpecification::isSpAsymmetricBinding():Boolean=self.classifier->exists(c|c.name='AsymmetricBinding');	
	query UML::InstanceSpecification::isWspPolicyReference():Boolean=self.classifier->exists(c|c.name='PolicyReference');	
query UML::InstanceSpecification::isSpInitiatorToken():Boolean=self.classifier->exists(c|c.name='InitiatorToken');	
query UML::InstanceSpecification::isSpRecipientToken():Boolean=self.classifier->exists(c|c.name='RecipientToken');	
query UML::InstanceSpecification::isSpLayout():Boolean=self.classifier->exists(c|c.name='Layout');	
query UML::InstanceSpecification::isSpIncludeTimestamp():Boolean=self.classifier->exists(c|c.name='IncludeTimestamp');	
query UML::InstanceSpecification::isSpOnlySignEntireHeadersAndBody():Boolean=self.classifier->exists(c|c.name='OnlySignEntireHeadersAndBody');	
query UML::InstanceSpecification::isSpAlgorithmSuite():Boolean=self.classifier->exists(c|c.name='AlgorithmSuite');	
query UML::InstanceSpecification::isSpWss10():Boolean=self.classifier->exists(c|c.name='Wss10');	
query UML::InstanceSpecification::isWssX509V3Token10():Boolean=self.classifier->exists(c|c.name='WssX509V3Token10');	
	

query UML::InstanceSpecification::isSpEncryptedParts():Boolean=self.classifier->exists(c|c.name='EncryptedParts');	
query UML::InstanceSpecification::isSpSignedParts():Boolean=self.classifier->exists(c|c.name='SignedParts');	
*/
/*
property hasBeenMappedSet:Set(OclAny)=Set{};
query OclAny::hasBeenMapped():Boolean=hasBeenMappedSet->includes(self);
helper OclAny::setHasBeenMapped(){
	hasBeenMappedSet+=self;
	return;
}
*/
query UML::Slot::hasBeenMapped(hasBeenMappedSet:Set(UML::Slot)):Boolean=hasBeenMappedSet->includes(self);
/*
helper UML::Slot::setHasBeenMapped(inout hasBeenMappedSet:Set(UML::Slot)){
	hasBeenMappedSet+=self;
	return;
}
*/	
helper UML::Slot::mapSlot(inout spUsernameToken:WSDL::UnknownExtensibilityElement){
	var slot:UML::Slot=self;
		var feature:UML::StructuralFeature=slot.definingFeature;
		var featureURI:String=feature.getNearestPackage().URI;
		if((slot.value->notEmpty())and (feature.name<>'Policy'))then{
			var classifier:UML::Classifier=feature.type.oclAsType(UML::Classifier);
			switch{
				case(classifier.oclIsKindOf(UML::Artifact)or classifier.oclIsKindOf(UML::Enumeration)){
					slot.value
						->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue)
						.instance->forEach(instance){
							if((feature.name='IncludeToken'))then{
								var prefix:String='sp';
								spUsernameToken.setElementAttribute(featureURI,prefix+':'+feature.name,instance.name);
								
							}else{
								if((feature.name='URI'))then{
									// get the id of the referenced instance
									spUsernameToken.setElementAttribute('',feature.name,'#'+instance.name);
									log('URI '+instance.name);
								}else{
									instance.expressionOperand(spUsernameToken);
								}endif;
							}endif;
							
						};
						
						
						
				};
				case(classifier.oclIsKindOf(UML::PrimitiveType)and (classifier.name='Boolean')){
					// there may be some actual boolean attributes?
					slot.value
						->select(s|s.oclIsKindOf(UML::LiteralBoolean)).oclAsType(UML::LiteralBoolean).value
						->select(v|v)->forEach(qnameAssertion){
							var qname:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(featureURI,feature.name);
							spUsernameToken.children+=qname;
						}
				};
				case(classifier.oclIsKindOf(UML::PrimitiveType)and (classifier.name='String')){
					// this could be a mixed element or an attribute
					slot.value
						->select(s|s.oclIsKindOf(UML::LiteralString)).oclAsType(UML::LiteralString).value
						->forEach(stringValue){
							// 
							if((feature.name='XPath')
								or (feature.name='IssuerName')
								or (feature.name='Address')
								)then{
								var qname:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(featureURI,feature.name);
								spUsernameToken.children+=qname;
								qname.setElementValue(stringValue);
							}else{
							var prefix:String='sp';
							spUsernameToken.setElementAttribute(featureURI,prefix+':'+feature.name,stringValue);
							}endif;
						}
				};
				case(classifier.oclIsKindOf(UML::PrimitiveType)and (classifier.name='Integer')){
					// this could be a mixed element or an attribute
					slot.value
						->select(s|s.oclIsKindOf(UML::LiteralInteger)).oclAsType(UML::LiteralInteger).value.toString()
						->forEach(stringValue){
							var prefix:String='sp';
							spUsernameToken.setElementAttribute(featureURI,prefix+':'+feature.name,stringValue);
						}
				};
			};
		}endif;
	
}
helper UML::InstanceSpecification::extensibleElementCommon(inout element:WSDL::UnknownExtensibilityElement){
	// in general, iterate through instance containment hierarchy
	// primitive types are generally attributes;  booleans may be an indicator of a simple extensibility element
	// do policy first to avoid duplicates
	// note that classifier name and namespace should uniquely identify each instance;
	// special actions required for some elements which are flattened in UML
	var hasBeenMappedSet:Set(UML::Slot)=Set{};
	
	var extensionNamespace:String='';
	var extensionName:String='';
	self.classifier->select(c|not(c.getNearestPackage().URI.oclIsUndefined()))->forEach(extension){
		extensionName:=extension.name;
		extensionNamespace:=extension.getNearestPackage().URI;
		if(self.oclIsKindOf(UML::EnumerationLiteral))then{
			extensionName:=self.name;
		}endif;
		if(extensionName.startsWith('SymmetricBinding'))then{extensionName:='SymmetricBinding';}endif;
		if(extensionName.startsWith('AsymmetricBinding'))then{extensionName:='AsymmetricBinding';}endif;
	};
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(extensionNamespace,extensionName);
	element.children+=spUsernameToken;
	var policies:Sequence(UML::InstanceSpecification)=self.slot.value
		->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance
		->select(i|i.isPolicy())->asSequence();
	var policyElements:Sequence(WSDL::UnknownExtensibilityElement)=policies.mapNestedPolicy(spUsernameToken);
	var exactlyOneElements:Sequence(WSDL::UnknownExtensibilityElement)=policyElements.children;
	var allElements:Sequence(WSDL::UnknownExtensibilityElement)=exactlyOneElements.children;
	if((exactlyOneElements->notEmpty())and (allElements->isEmpty()))then{
		// create an all element and append to exactlyOneElement
		var wspEAll:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'All');
		exactlyOneElements->first().children+=wspEAll;
		allElements+=wspEAll;
		
	}endif;
	var allExtension:WSDL::UnknownExtensibilityElement=allElements->first();
	// handle flattened policies
	switch{
		case(extensionName='UserNameToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='Password')or(featureName='RequireDerivedKeys')
					or(featureName='WssUsernameToken'))then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='IssuedToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireExternalReference')or(featureName='RequireInternalReference')
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='X509Token'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireKeyIdentifierReference')or(featureName='RequireIssuerSerialReference')
					or(featureName='RequireEmbeddedTokenReference')or(featureName='RequireThumbprintReference')
					or(featureName='WssX509')
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='KerberosToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireKeyIdentifierReference')
					or(featureName='WssKerberos')
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='SpnegoContextToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='MustNotSendCancel')
					or(featureName='MustNotSendAmend')
					or(featureName='MustNotSendRenew')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='SecurityContextToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireExternalUriReference')
					or(featureName='SC13SecurityContextToken')
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='SecureConversationToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireExternalUriReference')
					or(featureName='SC13SecurityContextToken')
					or(featureName='MustNotSendCancel')
						or(featureName='MustNotSendAmend')
						or(featureName='MustNotSendRenew')
						or(featureName='BootstrapPolicy')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='SamlToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireKeyIdentifierReference')
					or(featureName='WssSaml')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='RelToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RequireDerivedKeys')
					or(featureName='RequireKeyIdentifierReference')
					or(featureName='WssRel')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='HttpsToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='Https')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='KeyValueToken'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='RsaKeyValue')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='AlgorithmSuite'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='AlgorithmSuiteCode')
					or(featureName='InclusiveC14N')
					or(featureName='InclusiveC14N11')
					or(featureName='SOAPNormalization10')
					or(featureName='STRTransform10')
					or(featureName='XPath')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='Layout'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='SecurityHeaderLayout')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='TransportBinding'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='TransportToken')
					or(featureName='AlgorithmSuite')
					or(featureName='Layout')
						or(featureName='IncludeTimestamp')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='SymmetricBinding'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='EncryptionToken')
					or(featureName='SignatureToken')
					or(featureName='ProtectionToken')
						or(featureName='AlgorithmSuite')
						or(featureName='Layout')
						or(featureName='IncludeTimestamp')
						or(featureName='EncryptBeforeSigning')
						or(featureName='EncryptSignature')
						or(featureName='ProtectTokens')
						or(featureName='OnlySignEntireHeadersAndBody')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='AsymmetricBinding'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='InitiatorToken')
					or(featureName='InitiatorSignatureToken')
					or(featureName='InitiatorEncryptionToken')
					or(featureName='RecipientToken')
					or(featureName='RecipientSignatureToken')
					or(featureName='RecipientEncryptionToken')
						or(featureName='AlgorithmSuite')
						or(featureName='Layout')
						or(featureName='IncludeTimestamp')
						or(featureName='EncryptBeforeSigning')
						or(featureName='EncryptSignature')
						or(featureName='ProtectTokens')
						or(featureName='OnlySignEntireHeadersAndBody')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case((extensionName='SupportingTokens')
			or(extensionName='SignedSupportingTokens')
			or(extensionName='EndorsingSupportingTokens')
			or(extensionName='SignedEndorsingSupportingTokens')
			or(extensionName='SignedEncryptedSupportingTokens')
			or(extensionName='EncryptedSupportingTokens')
			or(extensionName='EndorsingEncryptedSupportingTokens')
			or(extensionName='SignedEndorsingEncryptedSupportingTokens')
				
			){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='TokenAssertion')
						or(featureName='AlgorithmSuite')
						or(featureName='SignedParts')
						or(featureName='SignedElements')
						or(featureName='EncryptedParts')
						or(featureName='EncryptedElements')
						or(featureName='ContentEncryptedElements')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='Wss10'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='MustSupportRefKeyIdentifier')
					or(featureName='MustSupportRefIssuerSerial')
					or(featureName='MustSupportRefExternalURI')
					or(featureName='MustSupportRefEmbeddedToken')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='Wss11'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='MustSupportRefKeyIdentifier')
					or(featureName='MustSupportRefIssuerSerial')
					or(featureName='MustSupportRefExternalURI')
					or(featureName='MustSupportRefEmbeddedToken')
					or(featureName='MustSupportRefThumbprint')
					or(featureName='MustSupportRefEncryptedKey')
					or(featureName='RequireSignatureConfirmation')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};
		case(extensionName='Trust13'){
			self.slot->forEach(slot){
				var feature:UML::StructuralFeature=slot.definingFeature;
				var featureName:String=feature.name;
				if((featureName='MustSupportClientChallenge')
					or(featureName='MustSupportServerChallenge')
					or(featureName='RequireClientEntropy')
					or(featureName='RequireServerEntropy')
					or(featureName='MustSupportIssuedTokens')
					or(featureName='RequireRequestSecurityTokenCollection')
					or(featureName='RequireAppliesTo')
	
					)then{
						hasBeenMappedSet+=slot;
						slot.mapSlot(allExtension);
					}endif;
			};
		};


		else{
			
		};
	};
	self.slot->select(s|not(s.hasBeenMapped(hasBeenMappedSet)))->forEach(slot){
		slot.mapSlot(spUsernameToken);
	};
}
/*
helper UML::InstanceSpecification::spX509Token(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'X509Token');
	element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(wsdlSpTokenAssertionStereotype).oclAsType(Stdlib::Element);
	var IncludeToken:String=appliedStereotype.getTagValue('IncludeToken').toString();
	if(not(IncludeToken.oclIsUndefined()))then{
		spUsernameToken.setElementAttribute(SP_NAMESPACE,'sp:IncludeToken',IncludeToken);
	}endif;
	
	return;
}
	helper UML::InstanceSpecification::spWssX509V3Token10(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'WssX509V3Token10');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spRequireIssuerSerialReference(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireIssuerSerialReference');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spStrict(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Strict');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spBasic256Sha256(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Basic256Sha256');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spEndorsingSupportingTokens(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'EndorsingSupportingTokens');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spIssuedToken(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'IssuedToken');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spRequestSecurityTokenTemplate(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RequestSecurityTokenTemplate');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spRequireDerivedKeys(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireDerivedKeys');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::spRequireInternalReference(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RequireInternalReference');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tKeyType(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'KeyType');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tKeySize(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'KeySize');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tEncryptWith(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'EncryptWith');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tSignWith(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SignWith');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tCanonicalizationAlgorithm(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'CanonicalizationAlgorithm');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	helper UML::InstanceSpecification::tEncryptionAlgorithm(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'EncryptionAlgorithm');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	


helper UML::InstanceSpecification::spBody(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Body');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpBodyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spHeader(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Header');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSpHeaderStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::SsMustSupportRefIssuerSerial(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'MustSupportRefIssuerSerial');element.children+=spUsernameToken;
	//TODO var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlSsMustSupportRefIssuerSerialStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}

helper UML::InstanceSpecification::wspAll(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'All');
	element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspAllStereotype);
	self.slot.value->select(v|v.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::wsawUsingAddressing(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'UsingAddressing');
	element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWsaUsingAddressingStereotype);
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(wsdlWsaUsingAddressingStereotype).oclAsType(Stdlib::Element);
	var wsdlRequired:String=appliedStereotype.getTagValue('wsdlRequired').toString();
	if(not(wsdlRequired.oclIsUndefined()))then{
		spUsernameToken.setElementAttribute(WSDL_NAMESPACE,'wsdl:required',wsdlRequired);
	}endif;
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::wsrmRMAssertion(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RMAssertion');element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsrmRMAssertionStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::wsrmInactivityTimeout(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'InactivityTimeout');element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsrmInactivityTimeoutStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::wsrmAcknowledgementInterval(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'AcknowledgementInterval');element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsrmAcknowledgementIntervalStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::wspPolicy(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(wspNamespace,'Policy');element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spAsymmetricBinding(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'AsymmetricBinding');element.children+=spUsernameToken;
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(spAsymmetricBindingStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
*/
//helper UML::InstanceSpecification::wspPolicyReference(inout element:WSDL::UnknownExtensibilityElement){
	
helper UML::InstanceSpecification::wspPolicyReference(inout extensibleElement:WSDL::ExtensibleElement):WSDL::UnknownExtensibilityElement{
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'PolicyReference');
	extensibleElement.eExtensibilityElements+=spUsernameToken;
	
//	element.children+=spUsernameToken;
	// need to allow this stereotype on Expression
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
//	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
//	self.slot.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	self.slot.mapSlot(spUsernameToken);
	
	return spUsernameToken;
}
/*
//////////////////////////////////////////////
helper UML::InstanceSpecification::spInitiatorToken(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'InitiatorToken');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spRecipientToken(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'RecipientToken');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spLayout(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Layout');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spIncludeTimestamp(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'IncludeTimestamp');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spOnlySignEntireHeadersAndBody(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'OnlySignEntireHeadersAndBody');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spAlgorithmSuite(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'AlgorithmSuite');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spWss10(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Wss10');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::WssX509V3Token10(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'WssX509V3Token10');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
	


helper UML::InstanceSpecification::spEncryptedParts(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'EncryptedParts');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	return;
}
helper UML::InstanceSpecification::spSignedParts(inout element:WSDL::UnknownExtensibilityElement){
	var spUsernameToken:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'SignedParts');element.children+=spUsernameToken;
	// TODO:no stereotype yet
	//var stereotypeInstance:Stdlib::Element=owner.applyStereotype(wsdlWspPolicyReferenceStereotype);
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(wsdlSpSignedPartsStereotype).oclAsType(Stdlib::Element);
	var body:Boolean=appliedStereotype.getTagValue('body').oclAsType(Boolean);
	if(body)then{
		var spBody:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Body');
		spUsernameToken.children+=spBody;
	}endif;
	appliedStereotype.getTagValues('header').oclAsType(Stdlib::Element)->forEach(header){
		var name:String=header.getTagValue('name').toString();
		var namespace:String=header.getTagValue('namespace').toString();
		var spHeader:WSDL::UnknownExtensibilityElement=new WSDL::UnknownExtensibilityElement(spNamespace,'Header');
		spUsernameToken.children+=spHeader;
		if(not(name.oclIsUndefined()))then{
			spHeader.setElementAttribute(null,'Name',name);
		}endif;
		if(not(namespace.oclIsUndefined()))then{
			spHeader.setElementAttribute(null,'Namespace',namespace);
		}endif;
	};
	self.value->select(s|s.oclIsKindOf(UML::InstanceValue)).oclAsType(UML::InstanceValue).instance.expressionOperand(spUsernameToken);
	
	return;
}

*/	
//mapping 	UML::Collaboration::ServiceDefinition():WSDL::Definition@wsdl 
mapping 	UML::Artifact::ServiceDefinition():WSDL::Definition@wsdl 
{
	log('ServiceDefinition from '+self.qualifiedName);
//	targetNamespace:=self.getTargetNamespace()+'Service';
	targetNamespace:=self.getTargetNamespace();
//	location:=self.getWsdlPartLocation('Service');
	location:=self.getWsdlPartLocation('');
	//eNamespaces+=new WSDL::Namespace(self.getBindingNamespace(),'serviceBinding');
	self.setCommonDefinitionFeatures(result);
	// find extensions as artifact instances
		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				else{
					log('ERROR: Unsupported WSDL::Definition extension '+ee.repr());
				};
			};
	};		
	
//	eServices+=self.map Service(result);
//	eServices+=self.ownedPort.map Service(result);
//	eServices+=self.service().map Service(result);
	self.service().map Service(result);
	// import the bindings
//	eImports+=self.getRealizedInterfaces().map ServiceImport(self,result);
//	eImports+=self.map ServiceImport(self,result);
/* lets not break this apart for GRA
	self.service().port()
	->select(port|not(port.binding().portType(port).oclIsUndefined()))
	->forEach(port){
		eImports+=port.binding().map ServiceImport(self,port);
	};
	*/
	//self.ServiceDefinitionWsdlAnnotation(result);
	
	
}	
query UML::NamedElement::findRealizingExtensions():Sequence(UML::InstanceSpecification)=
	self.getTargetDirectedRelationships()
		->select(r|r.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization).client
		->select(r|r.oclIsKindOf(UML::InstanceSpecification)).oclAsType(UML::InstanceSpecification)->asSequence();

//query UML::Collaboration::service():Set(UML::Component)=self.collaborationRole.type->select(r|r.oclIsKindOf(UML::Component)).oclAsType(UML::Component)->asSet();
query UML::Artifact::service():Set(UML::Component)=self.manifestation.utilizedElement->select(r|r.oclIsKindOf(UML::Component)).oclAsType(UML::Component)->asSet();
query UML::Component::port():Set(UML::Port)=self.ownedPort;
//query UML::Component::binding():Set(UML::Class)=self.port().type->select(t|t.oclIsKindOf(UML::Class)).oclAsType(UML::Class)->asSet();
query UML::Port::binding():UML::Class=self.type->select(t|t.oclIsKindOf(UML::Class)).oclAsType(UML::Class)->asSequence()->first();
query UML::Class::portType(port:UML::Port):UML::Interface=
	if(port.isConjugated)
		then self.getAllUsedInterfaces()->asSequence()->first() 
		else self.getRealizedInterfaces()->asSequence()->first()
		endif;
//query UML::Collaboration::getBindingNamespace():String=self.getTargetNamespace()+'Binding';		
helper UML::Classifier::setCommonDefinitionFeatures(inout definition:WSDL::Definition):Void{
	definition.setQName(self.getName());
	// is it just getting first namespace?  YES
// TODO: this should be unique since we may be importing another wsdl namespace
	definition.addNamespace('tns',definition.targetNamespace);
	definition.addNamespace(wsawsPrefix,wsawsNamespace);
	definition.addNamespace(soapPrefix,soapNamespace);
	definition.addNamespace(wspPrefix,wspNamespace);
	definition.addNamespace(wsuPrefix,wsuNamespace);
	//definition.addNamespace(mpoNamespace,mpoPrefix);
	definition.addNamespace(wsrmPrefix,wsrmNamespace);
	definition.addNamespace(spPrefix,spNamespace);
	/*
	definition.eNamespaces+=new WSDL::Namespace(definition.targetNamespace,'tns');
	
	definition.eNamespaces+=new WSDL::Namespace(wsawsNamespace,wsawsPrefix);
	definition.eNamespaces+=new WSDL::Namespace(soapNamespace,soapPrefix);
	definition.eNamespaces+=new WSDL::Namespace(wspNamespace,wspPrefix);
	definition.eNamespaces+=new WSDL::Namespace(wsuNamespace,wsuPrefix);
	definition.eNamespaces+=new WSDL::Namespace(mpoNamespace,mpoPrefix);
	definition.eNamespaces+=new WSDL::Namespace(wsrmNamespace,wsrmPrefix);
	definition.eNamespaces+=new WSDL::Namespace(spNamespace,spPrefix);
	
	// we are not getting any of the namespace through
	definition.updateDocument();
	*/
}	
/* not for GRA	
mapping 	UML::Class::BindingDefinition(port:UML::Port):WSDL::Definition@wsdl 
{
//	targetNamespace:=self.getBindingNamespace();
	targetNamespace:=self.getTargetNamespace();
//	location:=self.getWsdlPartLocation('Binding');
	location:=self.getWsdlPartLocation('');
	self.setCommonDefinitionFeatures(result);
//	eBindings+=self.map Binding(service,port);
	eBindings+=self.map Binding(port,result);		
	
	// import the portTypes
	eImports+=self.map BindingImport(self,port);
	self.BindingDefinitionWsdlAnnotation(result,port);
}
	
mapping 	UML::Collaboration::BindingDefinition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getBindingNamespace();
	result.setQName(self.getName());
	location:=self.getWsdlPartLocation('Binding');
	eNamespaces+=new WSDL::Namespace(wsawsNamespace,wsawsPrefix);
	eNamespaces+=new WSDL::Namespace(soapNamespace,soapPrefix);
	eNamespaces+=new WSDL::Namespace(wspNamespace,wspPrefix);
	eNamespaces+=new WSDL::Namespace(wsuNamespace,wsuPrefix);
	eNamespaces+=new WSDL::Namespace(mpoNamespace,mpoPrefix);
	eNamespaces+=new WSDL::Namespace(wsrmNamespace,wsrmPrefix);
	eNamespaces+=new WSDL::Namespace(spNamespace,spPrefix);
	result.updateDocument();
//	eBindings+=self.getRealizedInterfaces().map Binding(self);
//	eBindings+=self.ownedPort.type.map Binding(self);
	self.service()->forEach(service){
		
	 	service.port()->forEach(port){
			eBindings+=port.binding().map Binding(service,port);
		};
	};
	//eBindings+=self.service().binding().map Binding(self);

	// import the portTypes
//	eImports+=self.getRealizedInterfaces().map BindingImport(self,result);
	eImports+=self.map BindingImport(self,result);
	self.BindingDefinitionWsdlAnnotation(result);
}
*/	
/*
mapping 	UML::Interface::Definition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getTargetNamespace();
	location:=self.getWsdlLocation();
	self.allInterfaceSchemaPackages().toPsmPackage()->forEach(schema){
		var targetNamespace:String=schema.targetNamespace;
		var prefix:String=schema.getSchemaPrefix();
		eNamespaces+=new WSDL::Namespace(targetNamespace,prefix);
	};
	self.setCommonDefinitionFeatures(result);
	ePortTypes+=self.map PortType(result);
	eMessages+=ePortTypes.eOperations->select(o|not(o.eInput.oclIsUndefined())).eInput.eMessage
		->union(ePortTypes.eOperations->select(o|not(o.eOutput.oclIsUndefined())).eOutput.eMessage)
		->union(ePortTypes.eOperations.eFaults.eMessage)->asSet();
	// import the schemas
	eImports+=self.allInterfaceSchemaPackages().map Import(self,result);
	self.DefinitionWsdlAnnotation(result);
	
}
*/	
/*
mapping 	UML::Collaboration::Definition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getTargetNamespace();
	result.setQName(self.getName());
	location:=self.getWsdlLocation();
	self.service().port()->forEach(port){
		port.binding().allSchemaPackages().toPsmPackage()->forEach(schema){
			var targetNamespace:String=schema.targetNamespace;
			var prefix:String=schema.getSchemaPrefix();
			eNamespaces+=new WSDL::Namespace(targetNamespace,prefix);
		};
	};
	result.updateDocument();
//	ePortTypes+=self.getRealizedInterfaces().map PortType();
//	ePortTypes+=self.ownedPort.type.getRealizedInterfaces().map PortType();
	self.service().port()->forEach(port){
		ePortTypes+=port.binding().portType(port).map PortType();
	};
	//ePortTypes+=self.service().binding().portType().map PortType();
	eMessages+=ePortTypes.eOperations->select(o|not(o.eInput.oclIsUndefined())).eInput.eMessage
		->union(ePortTypes.eOperations->select(o|not(o.eOutput.oclIsUndefined())).eOutput.eMessage)
		->union(ePortTypes.eOperations.eFaults.eMessage)->asSet();
	// import the schemas
	self.service().port()->forEach(port){
		eImports+=port.binding().allSchemaPackages().map Import(self,result);
	};
//	eImports+=self.service().binding().allSchemaPackages().map Import(self,result);
	self.DefinitionWsdlAnnotation(result);
	
}	
*/
//mapping UML::Classifier::Service(in definition:WSDL::Definition):WSDL::Service@wsdl
mapping UML::Component::Service(inout definition:WSDL::Definition):WSDL::Service@wsdl
	when{self.port()->exists(port|not(port.binding().portType(port).oclIsUndefined()))}
{
	
	result.setQName(definition,self.getName()+'Service');// if not set before added to container, it does not get added
//	ePorts+=self.getRealizedInterfaces().map Port(definition,result,self);
	definition.eServices+=result;
//	ePorts+=self.port().map Port(definition,result,self);
	self.port().map Port(definition,result,self);

	//result.setQName(self.getName()+'Service');// now attached to definition so we can get namespace
}
	
/*
mapping 	UML::Classifier::ServiceDefinition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getTargetNamespace()+'Service';
	result.setQName(self.getName());
	location:=self.getWsdlPartLocation('Service');
	result.updateDocument();
	eServices+=self.map Service(result);
	// import the bindings
//	eImports+=self.getRealizedInterfaces().map ServiceImport(self,result);
	eImports+=self.map ServiceImport(self,result);
	self.ServiceDefinitionWsdlAnnotation(result);
	
}	
mapping 	UML::Classifier::BindingDefinition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getTargetNamespace()+'Binding';
	result.setQName(self.getName());
	location:=self.getWsdlPartLocation('Binding');
	eNamespaces+=new WSDL::Namespace(wsawsNamespace,wsawsPrefix);
	eNamespaces+=new WSDL::Namespace(soapNamespace,soapPrefix);
	eNamespaces+=new WSDL::Namespace(wspNamespace,wspPrefix);
	eNamespaces+=new WSDL::Namespace(wsuNamespace,wsuPrefix);
	eNamespaces+=new WSDL::Namespace(mpoNamespace,mpoPrefix);
	eNamespaces+=new WSDL::Namespace(wsrmNamespace,wsrmPrefix);
	eNamespaces+=new WSDL::Namespace(spNamespace,spPrefix);
	result.updateDocument();
	eBindings+=self.getRealizedInterfaces().map Binding(self);

	// import the portTypes
//	eImports+=self.getRealizedInterfaces().map BindingImport(self,result);
	eImports+=self.map BindingImport(self,result);
	self.BindingDefinitionWsdlAnnotation(result);
}	
mapping 	UML::Classifier::Definition():WSDL::Definition@wsdl 
{
	
	targetNamespace:=self.getTargetNamespace();
	result.setQName(self.getName());
	location:=self.getWsdlLocation();
	result.updateDocument();
	self.allSchemaPackages().toPsmPackage()->forEach(schema){
		var targetNamespace:String=schema.targetNamespace;
		var prefix:String=schema.getSchemaPrefix();
		eNamespaces+=new WSDL::Namespace(targetNamespace,prefix);
	};
	ePortTypes+=self.getRealizedInterfaces().map PortType();
	eMessages+=ePortTypes.eOperations->select(o|not(o.eInput.oclIsUndefined())).eInput.eMessage
		->union(ePortTypes.eOperations->select(o|not(o.eOutput.oclIsUndefined())).eOutput.eMessage)
		->union(ePortTypes.eOperations.eFaults.eMessage)->asSet();
	// import the schemas
	eImports+=self.allSchemaPackages().map Import(self,result);
	self.DefinitionWsdlAnnotation(result);
	
}	

mapping UML::Classifier::Service(in definition:WSDL::Definition):WSDL::Service@wsdl
{
	
	result.setQName(self.getName()+'Service');
	ePorts+=self.getRealizedInterfaces().map Port(definition,result,self);
	
}
*/
//mapping UML::Interface::Port(in definition:WSDL::Definition,in service:WSDL::Service,serviceInterface:UML::Classifier):WSDL::Port@wsdl
mapping UML::Port::Port(inout definition:WSDL::Definition,inout service:WSDL::Service,participant:UML::Component):WSDL::Port@wsdl
	when{not(self.binding().portType(self).oclIsUndefined())}
{
	
	name:=self.getName()+'Port';
	service.ePorts+=result;
	
//	eBinding:=self.map Binding(serviceInterface);
//	eBinding:=self.binding().map Binding(participant,self);
	eBinding:=self.binding().map Binding(self,definition);
	// must define address
//	eExtensibilityElements+=new SOAPAddress(self.locationURI());
	var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(wsdlSoapAddressStereotype).oclAsType(Stdlib::Element);
	
	var required:Boolean=appliedStereotype.getTagValue('wsdlRequired').oclAsType(Boolean);
	var location:String=appliedStereotype.getTagValue('location').oclAsType(String);
	var soapAddress:SOAP::SOAPAddress=new SOAP::SOAPAddress(location);
	if(required)then{
		soapAddress.required:=required;
	}endif;	
	eExtensibilityElements+=soapAddress;

		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
//					eExtensibilityElements+=ee.wspPolicyReference();
					ee.wspPolicyReference(result);
				};
				case(ee.isEndpointReference()){
//					eExtensibilityElements+=ee.EndpointReference();
					ee.EndpointReference(result);
				};
					
				
				else{
					log('ERROR: Unsupported WSDL::Port extension '+ee.repr());
				};
			};
	};		
	
}
//mapping UML::Interface::Binding(serviceInterface:UML::Classifier):WSDL::Binding@wsdl
//mapping UML::Class::Binding(participant:UML::Component,port:UML::Port):WSDL::Binding@wsdl
mapping UML::Class::Binding(port:UML::Port,inout definition:WSDL::Definition):WSDL::Binding@wsdl
	when{not(self.portType(port).oclIsUndefined())}
{
	result.setQName(definition,self.getName()+port.getName()+'Binding');
	definition.eBindings+=result;
	
//	ePortType:=self.map PortType();
	ePortType:=self.portType(port).map PortType(definition);
//	ePortType:=self.portType().map PortType();
//	eBindingOperations+=ePortType.eOperations.map BindingOperation(self);
	ePortType.eOperations.map BindingOperation(self,result);
	// must define binding
	eExtensibilityElements+=new SOAPBinding(self.transportURI(),self.style());
	//     	<wsaws:UsingAddressing/>
//	eExtensibilityElements+=wsawsUsingAddressing();
	wsawsUsingAddressing(result);
	/*
	if(serviceInterface.stereotypedBy(policyProfileAuthentication))then{
		eExtensibilityElements+=wspPolicyReference('#PasswordAuthenticationOverSSL');
	}else{}endif;
	if(serviceInterface.stereotypedBy(policyProfileReliability))then{
		eExtensibilityElements+=wspPolicyReference('#ReliableMessaging');
	}else{}endif;
	
	*/
	/*
	self.clientDependency
			->select(d|d.IsStereotypeApplied(wsdlWspPolicyReferenceStereotype)).oclAsType(UML::Usage).supplier
			->select(d|d.IsStereotypeApplied(wsdlWspPolicyStereotype))
			->forEach(ref){
					var appliedStereotype:Stdlib::Element=self.GetStereotypeApplication(wsdlWspPolicyStereotype).oclAsType(Stdlib::Element);
					var Id:String=appliedStereotype.getTagValue('Id').toString();
					eExtensibilityElements+=wspPolicyReference('#'+Id);
		};
	*/
		self.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
//					eExtensibilityElements+=ee.wspPolicyReference();
					ee.wspPolicyReference(result);
					
				};
				else{
					log('ERROR: Unsupported WSDL::Definition extension '+ee.repr());
				};
			};
	};		

	// null ptr exception: is it this? TODO temporary suppress
//	definition.eBindings+=result;
	
}
mapping UML::Interface::PortType(inout definition:WSDL::Definition):WSDL::PortType@wsdl
{
	
	result.setQName(definition,self.getName());
	definition.ePortTypes+=result;
//	eOperations+=self.allBehavioralFeatures().map Operation(result,self,definition);
	self.allBehavioralFeatures().map Operation(result,self,definition);
	
	// TODO: test if this causes null ptr exception
//	definition.ePortTypes+=result;
	//result.setQName(self.getName());// failure occurs if done here
}
//mapping WSDL::Operation::BindingOperation(context:UML::Interface):WSDL::BindingOperation@wsdl
mapping WSDL::Operation::BindingOperation(context:UML::Class,inout binding:WSDL::Binding):WSDL::BindingOperation@wsdl
{
	
	name:=self.name;
	eOperation:=self;
	var umlOperation:UML::BehavioralFeature=self.findUmlOperation(context);
	binding.eBindingOperations+=result;
//	var umlOperation:UML::BehavioralFeature=context.ownedOperation->select(o|o.name=self.name)->asSequence()->first();
	
	eExtensibilityElements+=new SOAPOperation(umlOperation.soapActionURI(),umlOperation.style());
	//result.setElementAttribute(mpoNamespace,'mpo:modifieable','');
//	eBindingInput:=self.eInput.map BindingInput(umlOperation);
//	eBindingOutput:=self.eOutput.map BindingOutput(umlOperation);
//	eBindingFaults:=self.eFaults.map BindingFault(umlOperation);
	self.eInput.map BindingInput(umlOperation,result);
	self.eOutput.map BindingOutput(umlOperation,result);
	self.eFaults.map BindingFault(umlOperation,result);
	
}

mapping WSDL::Input::BindingInput(umlOperation:UML::BehavioralFeature,inout bindingOperation:WSDL::BindingOperation):WSDL::BindingInput@wsdl
{
	name:=self.name;
	eInput:=self;
	bindingOperation.eBindingInput:=result;
//	var umlOperation:UML::BehavioralFeature=self.getContainer().oclAsType(WSDL::Operation).findUmlOperation();
//	eExtensibilityElements+=new SOAPBody(umlOperation.use(),self.parts());
	new SOAPBody(umlOperation.use(),self.parts(),result);
//	result.setElementAttribute(wsawsNamespace,'wsaws:Action',umlOperation.soapActionURI());
//					log('WSDL::BindingInput umlOperation ');
//					log('WSDL::BindingInput umlOperation '+umlOperation.repr());
	umlOperation.ownedParameter->select(p|(p.name=self.name)or(p.name.oclIsUndefined() and self.name.oclIsUndefined()))->forEach(parameter){
//					log('WSDL::BindingInput parameter '+parameter.repr());
		parameter.findRealizingExtensions()->forEach(ee){
//					log('WSDL::BindingInput extension '+ee.repr());
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
//					eExtensibilityElements+=ee.wspPolicyReference();
					ee.wspPolicyReference(result);
					
				};
				else{
					log('ERROR: Unsupported WSDL::BindingInput extension '+ee.repr());
				};
			};
		};
		// SOAPHeader is represented as a Usage to a property, which is a Message/Part
		parameter.clientDependency->select(d|d.oclIsKindOf(UML::Usage))->forEach(soapHeader){
			
			var soapHeaderInstance:Stdlib::Element=soapHeader.GetStereotypeApplication(wsdlSoapHeaderStereotype).oclAsType(Stdlib::Element);
			
			var namespace:String=soapHeaderInstance.getTagValue('namespace').oclAsType(String);
			var encodingStyle:String=soapHeaderInstance.getTagValue('encodingStyle').oclAsType(String);
			var use:UML::EnumerationLiteral=soapHeaderInstance.getTagValue('use').oclAsType(UML::EnumerationLiteral);
			var header:SOAP::SOAPHeader=new SOAP::SOAPHeader();
			eExtensibilityElements+=header;
			header.namespaceURI:=namespace;
			header.eEncodingStyles:=encodingStyle;
			header.use:=use.name;
			soapHeader.supplier->forEach(messagePart){
				var part:WSDL::Part=messagePart.resolveone(WSDL::Part);
				header.ePart:=part;
			};
		};		
	};

}
mapping WSDL::Output::BindingOutput(umlOperation:UML::BehavioralFeature,inout bindingOperation:WSDL::BindingOperation):WSDL::BindingOutput@wsdl
{
	name:=self.name;
	eOutput:=self;
	bindingOperation.eBindingOutput:=result;
//	var umlOperation:UML::BehavioralFeature=self.getContainer().oclAsType(WSDL::Operation).findUmlOperation();
//	eExtensibilityElements+=new SOAPBody(umlOperation.use(),self.parts());
	new SOAPBody(umlOperation.use(),self.parts(),result);
//	result.setElementAttribute(wsawsNamespace,'wsaws:Action',umlOperation.soapActionURI()+'Response');
	umlOperation.ownedParameter->select(p|p.name=self.name)->forEach(parameter){
		parameter.findRealizingExtensions()->forEach(ee){
			switch{
				case(ee.isPolicy()){
					// wsp
					ee.mapPolicy(result);
				};
				case(ee.isPolicyReference()){
//					eExtensibilityElements+=ee.wspPolicyReference();
					ee.wspPolicyReference(result);
					
				};
				else{
					log('ERROR: Unsupported WSDL::BindingInput extension '+ee.repr());
				};
			};
		};		
		// SOAPHeader is represented as a Usage to a property, which is a Message/Part
		parameter.clientDependency->select(d|d.oclIsKindOf(UML::Usage))->forEach(soapHeader){
			
			var soapHeaderInstance:Stdlib::Element=soapHeader.GetStereotypeApplication(wsdlSoapHeaderStereotype).oclAsType(Stdlib::Element);
			
			var namespace:String=soapHeaderInstance.getTagValue('namespace').oclAsType(String);
			var encodingStyle:String=soapHeaderInstance.getTagValue('encodingStyle').oclAsType(String);
			var use:UML::EnumerationLiteral=soapHeaderInstance.getTagValue('use').oclAsType(UML::EnumerationLiteral);
			var header:SOAP::SOAPHeader=new SOAP::SOAPHeader();
			eExtensibilityElements+=header;
			
			header.namespaceURI:=namespace;
			header.eEncodingStyles:=encodingStyle;
			header.use:=use.name;
			soapHeader.supplier->forEach(messagePart){
				var part:WSDL::Part=messagePart.resolveone(WSDL::Part);
				header.ePart:=part;
			};
		};		
	};
}
mapping WSDL::Fault::BindingFault(umlOperation:UML::BehavioralFeature,inout bindingOperation:WSDL::BindingOperation):WSDL::BindingFault@wsdl
{
	name:=self.name;
	bindingOperation.eBindingFaults+=result;
	eFault:=self;
//	var umlOperation:UML::BehavioralFeature=self.getContainer().oclAsType(WSDL::Operation).findUmlOperation();
//	eExtensibilityElements+=new SOAPFault(self.name,umlOperation.use());
}
	
mapping UML::BehavioralFeature::Operation(inout portType:WSDL::PortType,owningInterface:UML::Interface,inout definition:WSDL::Definition):WSDL::Operation@wsdl
{
	
	name:=self.getName();
	portType.eOperations+=result;
	
//	eInput:=self.getInputParameter().map Input(portType,owningInterface,definition);
//	eOutput:=self.getOutputParameter().map Output(portType,definition);
//	eFaults:=self.raisedException.map Fault(portType,definition);
	self.getInputParameter().map Input(portType,owningInterface,definition,result);
	self.getOutputParameter().map Output(portType,definition,result);
	self.raisedException.map Fault(portType,definition,result);
}
mapping UML::Type::Fault(portType:WSDL::PortType,inout definition:WSDL::Definition,inout operation:WSDL::Operation):WSDL::Fault@wsdl
{
	name:=self.getName();
	operation.eFaults+=result;
	eMessage:=self.oclAsType(UML::Classifier).map Message(portType,definition);
}
mapping UML::NamedElement::Input(portType:WSDL::PortType,owningInterface:UML::Interface,inout definition:WSDL::Definition,inout operation:WSDL::Operation):WSDL::Input@wsdl
{
	// name must be unique amongst all input/output names in portType 
	name:=self.getName()+self.uniqueInputNameSuffix(owningInterface);
	operation.eInput:=result;
	eMessage:=self.getUmlType().map Message(portType,definition);
}
mapping UML::NamedElement::Output(portType:WSDL::PortType,inout definition:WSDL::Definition,inout operation:WSDL::Operation):WSDL::Output@wsdl
{
	name:=self.getName();
	operation.eOutput:=result;
	eMessage:=self.getUmlType().map Message(portType,definition);
}
mapping UML::Classifier::Message(inout portType:WSDL::PortType,inout definition:WSDL::Definition):WSDL::Message@wsdl
{
//	portType.getEnclosingDefinition().eMessages+=result;
	result.setQName(definition,self.getName());
	definition.eMessages+=result;
//	eParts+=self.attribute.map Part(portType,definition);
	self.attribute.map Part(portType,definition,result);
}
mapping UML::Property::Part(in portType:WSDL::PortType,inout definition:WSDL::Definition,inout message:WSDL::Message):WSDL::Part@wsdl
{
		
	// may need to do this based on psm model
	name:=self.getName();
	message.eParts+=result;
//	typeDefinition:=self.map AbstractTypeDefinition();
	// we should actually do an element here
	//typeDefinition:=self.toPsmClassifier();
	// TODO: this is reliable only at PSM level
	var topLevelProperty:UML::Property=self.usesTopLevelProperty();
	/*
	if(topLevelProperty.oclIsUndefined())then{
		// TODO: temporary workaround
		topLevelProperty:=self;
	}endif;
	*/
	//var xsdElementDeclaration:XSD::XSDElementDeclaration=self.usesTopLevelProperty().toPsmTopLevelElement()->asSequence()->first();
	// this needs psm level stereotype, so this too needs a work-around
	var xsdElementDeclaration:XSD::XSDElementDeclaration=topLevelProperty.toPsmTopLevelElement();
	if(xsdElementDeclaration.oclIsUndefined())then{
		// TODO: temporary workaround
		var schema:XSD::XSDSchema=topLevelProperty.getNearestNIEMSchemaPackage().toPsmPackage();
		if(schema.oclIsUndefined())then{
			schema:=topLevelProperty.getNearestPackage().map NamespaceGRA();
		}endif;
		if(not(schema.oclIsUndefined()))then{
			schema.map TypeSchema(definition);
			xsdElementDeclaration:=topLevelProperty.map TopLevelElement_declarationGRA(schema);
		}endif;
	}endif;
	
	if(not(xsdElementDeclaration.oclIsUndefined()))then{
		elementDeclaration:=xsdElementDeclaration;
		result.setElementName(xsdElementDeclaration,definition);
	}endif;
	
}
mapping XSD::XSDSchema::TypeSchema(inout definition:WSDL::Definition):XSD::XSDSchema
{
		// set xmlns mapping now, or else the Q* prefixes may be in table
		result.setSchemaForSchema('xsd',schemaForSchemaNamespace);
		/*
		this.schemaForSchema:=result.schemaForSchema;
		// get instance of Stereotype
		var pimStereotypeInstance:Stdlib::Element=self.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
		// set schema targetNamespace from <<Namespace>>
		result.targetNamespace:=pimStereotypeInstance.getSchemaTargetNamespace();
		// set prefix to be used for Schema namespace
			var defaultPrefix:String=pimStereotypeInstance.getSchemaDefaultPrefix();
		
		result.setPrefixForSchemaNamespace(defaultPrefix);
	*/
	if(definition.eTypes.oclIsUndefined())then{
		definition.eTypes:=new WSDL::Types();
	}endif;
	elementFormDefault:=self.elementFormDefault;
	attributeFormDefault:=self.attributeFormDefault;
	schemaLocation:=definition.location;
	//targetNamespace:=self.targetNamespace;
	var xsdImport:XSD::XSDImport=new XSD::XSDImport();
	xsdImport.namespace:=self.targetNamespace;
	xsdImport.resolvedSchema:=self;
	
	var referencedSchema:String=self.schemaLocation.startsWithXmlSchemasFolder();
	var thisSchema:String=definition.location;
	var relativePath:String=thisSchema.relativePathTo(referencedSchema);
//	log('Wsdl internal schema referencedSchema '+referencedSchema);
//	log('Wsdl internal schema thisSchema '+thisSchema);
//	log('Wsdl internal schema relativePath '+relativePath);
	contents+=xsdImport;
	xsdImport.schemaLocation:=relativePath;
	/*
			<xsd:schema xmlns:notice="http://www.iir.com/sorna/NIEM/2.1/notification/1.0"
			elementFormDefault="qualified" attributeFormDefault="unqualified">
			<xsd:import namespace="http://www.iir.com/sorna/NIEM/2.1/notification/1.0"
				schemaLocation="../information/XMLschemas/exchange/RelNotice.xsd" />
		</xsd:schema>
	*/
	definition.eTypes.eExtensibilityElements+=result.map XSDSchemaExtensibilityElement();
}

mapping XSD::XSDSchema::XSDSchemaExtensibilityElement():WSDL::XSDSchemaExtensibilityElement@wsdl{
	schema:=self;
}
mapping UML::Package::NamespaceGRA():XSD::XSDSchema
	inherits UML::Package::XSDSchema
{
	
	var catalog:UML::Package:=sppCatalogUml.getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=self.qualifiedName;
	}else{
		relativePath:=self.qualifiedName.substringAfter(catalog.qualifiedName);
		if(relativePath.oclIsUndefined())then{
			var targetPath:String=self.qualifiedName.substringAfter(catalog.nestingPackage.qualifiedName);// TODO: should be relative to package above MPD
			relativePath:='artifacts::service model::information model::'+targetPath;
		}endif;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}else{relativePath:='.'+relativePath;}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	schemaLocation:=relativePath;

}
mapping UML::Property::TopLevelElement_declarationGRA(inout psmClass:XSD::XSDSchema):XSD::XSDElementDeclaration
		inherits UML::Property::XSDElementDeclaration_topLevel
{
	typeDefinition:=self.type.oclAsType(UML::Classifier).toPsmClassifier();
}


mapping UML::Package::Import(referencingPackage:UML::Namespace,definition:WSDL::Definition):WSDL::Import@wsdl
{
	
	//eSchema:=self.map Schema();
	var xsdSchema:XSD::XSDSchema=self.toPsmPackage();
	eSchema:=xsdSchema;
	namespaceURI:=xsdSchema.targetNamespace;
	locationURI:=self.getRelativeWsdlLocation(referencingPackage);
}
