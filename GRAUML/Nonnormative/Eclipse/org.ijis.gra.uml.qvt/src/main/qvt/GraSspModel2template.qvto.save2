import GRAcommon;// common GRA operations
import NIEMmpdmodel2artifact;// NIEM 2.1 UML QVT
import NIEMpsm2xsd;// NIEM 2.1 UML QVT
import NIEMpim2psm;
modeltype UML uses 'http://www.omg.org/spec/UML/20110701';

modeltype XSD  uses 'http://www.eclipse.org/xsd/2002/XSD';// implicit metamodel for Schemas ala XMI Specification
modeltype SPPCAT  uses 'http://gra.ijis.org/catalog/1.0.0';// metamodel for SPP Catalog
modeltype METADATA  uses 'http://it.ojp.gov/gsp/services/1.0.0';// metamodel for SPP metadata


modeltype CAT  uses 'http://reference.niem.gov/niem/resource/mpd/catalog/1.0/';// NIEM 2.1 Catalog metamodel

modeltype GRAA uses 'http://ijis.org/GRA/Annotations';// GRA Annotation metamodel
modeltype GRAW uses 'http:/ijis.org/GRA/WSDLAnnotations';// GRA WSDL Annotation metamodel

transformation GraSspModel2artifact (in uml:UML,in schemaForProxy:XSD,out cat:SPPCAT,out metadata:METADATA,out graa:GRAA)
	;
main() {
	GraSspModel2artifact_run();
}	
property graRoot:UML::Model=null;
property sppCatalogUml:UML::InstanceSpecification=null;
property metadataDocument:METADATA::DocumentRoot=null;	
property theServiceCollaboration:UML::Collaboration=null;
helper GraSspModel2artifact_run() {
	umlSchemaForProxy:=schemaForProxy.objectsOfType(XSD::XSDSchema)->asSequence()->first();
	// initialize the Schema for Schemas
	umlSchemaForSchema:=umlSchemaForProxy.schemaForSchema;
	
	graRoot:=
			uml.rootObjects()
			->select(r|r.oclIsKindOf(UML::Model)).oclAsType(UML::Model)
			->asSequence()->first();
    log('GRA uml model root '+graRoot.repr());    

	graRoot.initializeProfileGlobals();	
	graRoot.initializeSppProfileGlobals();
	// locate the uml spp catalog and map it to target catalog
	graRoot.allSubobjectsOfKind(UML::Package).oclAsType(UML::Package).packagedElement
		->select(e|e.isGraCatalog()).oclAsType(UML::InstanceSpecification)
		.map SppCatalog_DocumentRoot();	 
	return;
	}
query UML::Element::isGraCatalog():Boolean=
	self.oclIsKindOf(UML::InstanceSpecification) 
	and 
	self.oclAsType(UML::InstanceSpecification).classifier->exists(c|c.name='ServiceDescription');
	 
/////////////////////////////////////////////////catalog mappings
// represents the ssp model as a whole, all elements will be contained in the model
// within the model, it is also a servicesArchitecture
// context is GRA Service Specification
mapping 	UML::InstanceSpecification::SppCatalog_DocumentRoot():SPPCAT::DocumentRoot@cat{
	catalog:=self.map SppCatalog_ProvisioningComponent();
}

// context is GRA Service Specification
mapping 	UML::InstanceSpecification::SppCatalog_ProvisioningComponent():SPPCAT::CatalogType1@cat{
	sppCatalogUml:=self;
	
	//  get metadata and other artifacts during Catalog processing
	//  fully expand wsdl target content
	//  in the process, expand the spp schemas
	// process all content
	// create the items, establish containment, set stereotypes and apply tags discretely
	// catalog implicit
	// metadata : combine-in
	// service-description implicit
	// 	service-interface-description implicit from wsdl-schema
	//  wsdl-schema : similar to NIEM FileType
	//  soap-sample : similar to NIEM FileType
	// iepd-catalog : similar to NIEM FileType
	self.map Catalog(result);// entry for SSP Catalog
	self.map Metadata(result);// entry for SSP Metadata
	self.map ServiceDescriptionType(result);// entry for SDD

	self.wsdlInterfaceSchema().map ServiceInterfaceDescriptionType(self,result);// entries for SIDD
	// self.soapSample().map SoapSampleType(result);// Soap Samples via stage 2 processing
	self.wsdlSchema().map WsdlSchemaType(result);// entries for WSDL documents
	self.iepdCatalog().map IepdCatalogType(result);// entry for NIEM IEPD Catalog
	self.map GRA_WSDL();// annotation xmi
	
}
/*
    - <!--   Service Description Files Section    -->
	<service-description href="artifacts/SIRS_SDD_v_1.0.0.doc">Service Description Document</service-description>
    - <!--   Service Interface Files Section    -->
	<service-interface-description href="artifacts/Notification Service Interface/SIRS_SIDD_NSI_v_1.0.0.doc">Service Interface Description Document</service-interface-description>
	<service-interface-description href="artifacts/Relocation Service Interface/SIRS_SIDD_RSI_v_1.0.0.doc">Service Interface Description Document</service-interface-description>

*/
// context is property whose type is a component representing ServiceInterfaceDescription
// return value of href to the SIDD
query UML::Property::SIDDhref(serviceMetadata:METADATA::ServiceMetadataType,serviceInterfaceNameAbbreviationText:String):String{
		
	var serviceIdentification:METADATA::ServiceIdentificationType=serviceMetadata.serviceIdentification;
	// gather components of document name from metadata; provide defaults if undefined
	var abbrev:String=serviceIdentification.serviceNameAbbreviationText->first();	
	if(abbrev.oclIsUndefined())then{
		abbrev:='UNK(no ServiceIdentification@serviceNameAbbreviationText)';
	}endif;
	var versionInformation:METADATA::VersionInformationType=serviceMetadata.versionInformation;
	var majorVersion:Integer=versionInformation.majorVersion;
	var minorVersion:Integer=versionInformation.minorVersion;
	var revisionVersion:Integer=versionInformation.revisionVersion;
	if(majorVersion.oclIsUndefined())then{majorVersion:=1;}endif;
	if(minorVersion.oclIsUndefined())then{minorVersion:=0;}endif;
	if(revisionVersion.oclIsUndefined())then{revisionVersion:=0;}endif;
	// the SIDD abbreviation from serviceInterfaceSpecification
//	var ifcAbbrev:String=self.name.replace(' ','');
	var ifcAbbrev:String=serviceInterfaceNameAbbreviationText;
	if(ifcAbbrev.oclIsUndefined())then{
		ifcAbbrev:=self.name.replace(' ','');
		if(ifcAbbrev.oclIsUndefined())then{
			ifcAbbrev:='UNK(no @serviceInterfaceNameAbbreviationText)';
		}endif;
	}endif;
	// directory name based on name of component
	var ifcName:String=self.type.name;
	if(ifcName.oclIsUndefined())then{
		ifcName:=self.name.replace(' ','');
		if(ifcName.oclIsUndefined())then{
			ifcName:='UNK(no role name or role type name)';
		}endif;
	}endif;
//	var href:String='artifacts/'+ifcName+'/'+abbrev+'_SIDD_'+ifcAbbrev+'_v_'+majorVersion.toString()+'.'+minorVersion.toString()+'.'+revisionVersion.toString()+'.docx';
	var href:String='artifacts/'+ifcName+'/'+abbrev+'_SIDD_'+ifcAbbrev+'_v_'+majorVersion.toString()+'.'+minorVersion.toString()+'.'+revisionVersion.toString()+'.xhtml';
	return href;
}
mapping 	UML::Property::ServiceInterfaceDescriptionType(spp:UML::InstanceSpecification,inout catalog:SPPCAT::CatalogType1):SPPCAT::ServiceInterfaceDescriptionType@cat{
	// create ServiceInterfaceDescription element, add to catalog, populate with href and value attributes
	catalog.serviceInterfaceDescription+=result;
	var serviceMetadata:METADATA::ServiceMetadataType=spp.map MetadataDocument(catalog.metadata).serviceMetadata->asSequence()->first();
	var serviceComponent:UML::Type=self.type;
	var serviceInterface:UML::InstanceSpecification=spp.getInstanceValues('ServiceInterface')
		->select(si|si.getInstanceValues('Service').realizedComponent()->exists(c|c=serviceComponent))->asSequence()->first();
	var 	serviceInterfaceNameAbbreviationText:String=serviceInterface.getStringValue('ServiceInterfaceNameAbbreviationText');
		
	href:=self.SIDDhref(serviceMetadata,serviceInterfaceNameAbbreviationText);
	value:='Service Interface Description Document';
}
// compute href entry to the SDD document; name constructed from metadata
query 	METADATA::ServiceMetadataType::SDDhref():String{
	var serviceIdentification:METADATA::ServiceIdentificationType=self.serviceIdentification;
	var abbrev:String=serviceIdentification.serviceNameAbbreviationText->first();
	if(abbrev.oclIsUndefined())	then{
		abbrev:='UNK';
	}endif;
	var versionInformation:METADATA::VersionInformationType=self.versionInformation;
	
	var majorVersion:Integer=versionInformation.majorVersion;
	var minorVersion:Integer=versionInformation.minorVersion;
	var revisionVersion:Integer=versionInformation.revisionVersion;
	// name of document, per SSP specification
//	var href:String='artifacts/'+abbrev+'_SDD_v_'+majorVersion.toString()+'.'+minorVersion.toString()+'.'+revisionVersion.toString()+'.docx';
	var href:String='artifacts/'+abbrev+'_SDD_v_'+majorVersion.toString()+'.'+minorVersion.toString()+'.'+revisionVersion.toString()+'.xhtml';
	return href;
}
mapping 	UML::InstanceSpecification::ServiceDescriptionType(inout catalog:SPPCAT::CatalogType1):SPPCAT::ServiceDescriptionType@cat{
	// create serviceDescription entry in catalog and populate attributes href, value
	catalog.serviceDescription:=result;
	var serviceMetadata:METADATA::ServiceMetadataType=self.map MetadataDocument(catalog.metadata).serviceMetadata->asSequence()->first();
	href:=serviceMetadata.SDDhref();
	value:='Service Description Document';
}
// various specialized navigations across realizations from client to supplier, specialized by type of supplier	
query UML::NamedElement::clientRealization():Sequence(UML::Realization)=
	self.clientDependency->select(s|s.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization)->asSequence();
query UML::NamedElement::realizedCollaboration():Sequence(UML::Collaboration)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Collaboration)).oclAsType(UML::Collaboration)->asSequence();
query UML::NamedElement::realizedNamedElement():Sequence(UML::NamedElement)=
	self.clientRealization().supplier->select(s|s.oclIsKindOf(UML::NamedElement)).oclAsType(UML::NamedElement)->asSequence();
query UML::NamedElement::realizedPackage():Sequence(UML::Package)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Package)).oclAsType(UML::Package)->asSequence();
query UML::NamedElement::realizedUseCase():Sequence(UML::UseCase)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::UseCase)).oclAsType(UML::UseCase)->asSequence();
query UML::NamedElement::realizedComponent():Sequence(UML::Component)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Component)).oclAsType(UML::Component)->asSequence();
query UML::NamedElement::realizedPort():Sequence(UML::Port)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Port)).oclAsType(UML::Port)->asSequence();
query UML::NamedElement::realizedParameter():Sequence(UML::Parameter)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Parameter)).oclAsType(UML::Parameter)->asSequence();
query UML::NamedElement::realizedTypedElement():Sequence(UML::TypedElement)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::TypedElement)).oclAsType(UML::TypedElement)->asSequence();
query UML::NamedElement::realizedBehavioralFeature():Sequence(UML::BehavioralFeature)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::BehavioralFeature)).oclAsType(UML::BehavioralFeature)->asSequence();
query UML::NamedElement::realizedInterface():Sequence(UML::Interface)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Interface)).oclAsType(UML::Interface)->asSequence();
query UML::NamedElement::realizedActor():Sequence(UML::Actor)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSequence();
query UML::NamedElement::realizedInteraction():Sequence(UML::Interaction)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Interaction)).oclAsType(UML::Interaction)->asSequence();
query UML::NamedElement::realizedType():Sequence(UML::Type)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Type)).oclAsType(UML::Type)->asSequence();
// is a wsdl component if it matches the pattern of owning ports with provided interfaces	
query UML::Type::isWsdlComponent():Boolean=
	self.oclIsKindOf(UML::Component)
	and
	self.oclAsType(UML::Component).ownedPort->exists(p|p.provided->notEmpty());
// navigate from a ServiceDescription Instance, to its realized Collaboration, to owned attributes whose types are wsdl components	
query UML::InstanceSpecification::wsdlInterfaceSchema():Sequence(UML::Property)=
	self.realizedCollaboration().ownedAttribute->select(a|a.type.isWsdlComponent())
	->asSequence();
// same as wsdlInterfaceSchema	
query UML::InstanceSpecification::wsdlSchema():Sequence(UML::Property)=
	self.wsdlInterfaceSchema();
// navigate from a 	ServiceDescription Instance to the Usage whose supplier is an MPD Catalog
query UML::InstanceSpecification::iepdCatalog():Sequence(UML::Usage)=
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).oclAsType(UML::Usage)
		->select(d|d.supplier->forAll(s|s.isStereotypeApplied(prompdStereotype)))->asSequence();
// adjust href, if necessary, to be relative to spp package
query UML::Usage::toRelativeSppLocation():String{
	// client is spp catalog, we want relative path to supplier from catalog's package
	// 	<service-interface-description href="artifacts/Notification Service Interface/SIRS_SIDD_NSI_v_1.0.0.doc">Service Interface Description Document</service-interface-description>
	var sppRootPackage:UML::Package=self.client->asSequence()->first().getNearestPackage();
	var target:UML::NamedElement=self.supplier->asSequence()->first();
	// if not in containment of spp package, then assume it is an iepd
	var relativePackagePath:String=target.qualifiedName.substringAfter(sppRootPackage.qualifiedName+'::');
	if(relativePackagePath.oclIsUndefined())then{
		// default package path if not in spp containment structure
		relativePackagePath:='artifacts::service model::information model::'+target.name;
	}endif;
	// convert qualifiedName to path
	return relativePackagePath.replace('::','/');
};
// location of wsdl based on an instance specification
query UML::InstanceSpecification::toRelativeSppLocation():String{
	// have to assume this is wsdl at standard location, plus name of instance
	var relativePackagePath:String:='schema::SIP::'+self.name;
	return relativePackagePath.replace('::','/');
};
// location of wsdl based on a component
	
query UML::Component::toRelativeSppLocation():String{
	// have to assume this is wsdl at standard location, plus name of instance
	var relativePackagePath:String:='schema::SIP::'+self.name;
	return relativePackagePath.replace('::','/');
};
// context is GRA Service Specification
// create metadata entry in catalog, populate attributes href and value, create the metadata document 
mapping 	UML::InstanceSpecification::Metadata(inout catalog:SPPCAT::CatalogType1):SPPCAT::MetadataType@cat{
	catalog.metadata:=result;
	href:='metadata.xml';
	value:='Metadata';
	//	<metadata href="metadata.xml">Metadata</metadata>
	self.map MetadataDocument(result);
}

query UML::NamedElement::supplierRealization():Sequence(UML::Realization)=
	self.getTargetDirectedRelationships()->select(d|d.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization)->asSequence();
query UML::NamedElement::realizingInstance(artifactName:String):Sequence(InstanceSpecification)=
	self.supplierRealization().client
		->select(d|d.oclIsKindOf(UML::InstanceSpecification) 
			and d.oclAsType(UML::InstanceSpecification).classifier->exists(c|c.name=artifactName))
			.oclAsType(UML::InstanceSpecification)->asSequence();
query UML::NamedElement::realizingInstance():Sequence(InstanceSpecification)=
	self.supplierRealization().client
		->select(d|d.oclIsKindOf(UML::InstanceSpecification)).oclAsType(UML::InstanceSpecification);
query UML::Property::wsdlLocation():String{
	var wsdlComponent:UML::Component=self.type.oclAsType(UML::Component);
	//var serviceInterfaceDescription:UML::InstanceSpecification=wsdlComponent.realizingInstance('ServiceInterfaceDescription')->first();
	var value:String=self.name;
	if(value.oclIsUndefined())then{
		if(wsdlComponent.oclIsUndefined())then{
			value:='unknown(role type is not service component)';
		}else{
			value:=wsdlComponent.name;
			if(value.oclIsUndefined())then{
				value:='unknown(unnamed service component)';
			}endif;
		}endif;
	}endif;
	var wsdlLocation:String:='schema/SIP/'+value+'.wsdl';
	return wsdlLocation;
}		
query UML::Property::wsdlDescription():String{
	var wsdlComponent:UML::Component=self.type.oclAsType(UML::Component);
	var serviceInterfaceDescription:UML::InstanceSpecification=wsdlComponent.realizingInstance('ServiceInterfaceDescription')->first();
	var value:String=serviceInterfaceDescription.name;
	if(value.oclIsUndefined())then{
		value:=wsdlComponent.name;
	}endif;
	return value+' Service Schema';
}		
// context is property in collaboration whose type is a component corresponding to wsdl
mapping 	UML::Property::WsdlSchemaType(inout catalog:SPPCAT::CatalogType1):SPPCAT::WsdlSchemaType@cat
{
	catalog.wsdlSchema+=result;
	var wsdlComponent:UML::Component=self.type.oclAsType(UML::Component);
	var serviceInterfaceDescription:UML::InstanceSpecification=wsdlComponent.realizingInstance('ServiceInterfaceDescription')->first();
	value:=self.wsdlDescription();
	var wsdlLocation:String:=self.wsdlLocation();
	href:=wsdlLocation;
	//log('Catalog WsdlSchemaType reference '+result.href);
	//wsdlComponent.);// no wsdl
	
}
mapping 	UML::Usage::IepdCatalogType(inout catalog:SPPCAT::CatalogType1):SPPCAT::IepdCatalogType@cat
{
	catalog.iepdCatalog:=result;
	href:=self.toRelativeSppLocation();
	if(not(result.href.endsWith('catalog.xml')))then{href:=result.href+'/catalog.xml';}endif;
	value:=self.name;
	if(value.oclIsUndefined())then{
		self.supplier->forEach(s){
			value:=s.name;
		};
	}endif;
	// accumulate schemas for use during element/type resolution
	self.supplier->select(p|p.oclIsKindOf(UML::Component)).oclAsType(UML::Component)
		->forEach(iepd){gatherAllGraSchemas+=iepd.gatherAllPimSchemas();};
	// iepd catalog constructed in a separate process via NIEM 2.1 UML QVT
}
property gatherAllGraSchemas:Set(UML::Package)=Set{};
/*
property gatherAllPimSchemas:Set(UML::Package)=Set{};

helper  UML::Component::gatherAllPimSchemas():Set(UML::Package){
	gatherAllPimSchemas:=Set{};
	self.getPimInformationModels().gatherAllPimSchemas();	
	return 	gatherAllPimSchemas;
	}
query UML::Component::getPimInformationModels():Set(UML::Package)=
		self.elementImport.importedElement.oclAsType(UML::NamedElement)->asSet()
		->union(self.clientDependency.supplier->select(p|p.oclIsKindOf(UML::Package))
		// tjd added nested filesets
		->union(self.packagedElement.clientDependency.supplier->select(p|p.oclIsKindOf(UML::Package)))
		->select(c|c.IsStereotypeApplied(NIEMInformationModelStereotype))
		->asSet())
		.oclAsType(UML::Package)
		->asSet();
	
helper  UML::Package::gatherAllPimSchemas(){
	if(gatherAllPimSchemas->includes(self))then{return;}endif;
        if(self.name=XMLPrimitiveTypesPackageName)then{return ;}endif;
        if(self.name=UMLPrimitiveTypesPackageName)then{return ;}endif;
	
		gatherAllPimSchemas+=self;
		self.ownedType
			->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier)
			->forEach(c){
				// pick up general, property types
               c.general.getPimClassifier(self).getNearestNIEMSchemaPackage().gatherAllPimSchemas();
               c.attribute
               	->select(a|
               		not(a.type.oclIsUndefined()) 
               		and a.type.oclIsKindOf(UML::Classifier)
               		).type.oclAsType(UML::Classifier)
               	.getPimClassifier(self).getNearestNIEMSchemaPackage().gatherAllPimSchemas();
                                
			};
	return;
	}
query UML::Element::getNearestNIEMSchemaPackage():UML::Package{
    var schemaPackage:UML::Package=self.getNearestPackage();
    if(schemaPackage.IsStereotypeApplied(NIEMSchemaStereotype) or schemaPackage.IsStereotypeApplied(NIEMInformationModelStereotype)) then {return schemaPackage;} endif;
        if(schemaPackage.name=XMLPrimitiveTypesPackageName)then{return schemaPackage;}endif;
        if(schemaPackage.name=UMLPrimitiveTypesPackageName)then{return schemaPackage;}endif;

    var nestingPackage:UML::Package=schemaPackage.nestingPackage;
    if(nestingPackage.oclIsUndefined())then{return null;}endif;
    return nestingPackage.getNearestNIEMSchemaPackage();
}
*/
mapping 	UML::InstanceSpecification::Catalog(inout catalog:SPPCAT::CatalogType1):SPPCAT::CatalogType@cat{
	catalog.catalog:=result;
	href:='catalog.html';
	value:='Catalog';
}
////////////////////////////////////////////metadata
// context is GRA Service Specification

mapping 	UML::InstanceSpecification::MetadataDocument(inout metadataType:SPPCAT::MetadataType):METADATA::DocumentRoot@metadata{
	metadataDocument:=result;
	self.map ServiceMetadataType(result);
	result.addXsiSchemaLocation('http://it.ojp.gov/gsp/services/1.0.0','Metadata.xsd');// via blackbox
}
query UML::Element::isServiceIdentification():Boolean=
	self.oclIsKindOf(UML::Component) and self.oclAsType(UML::Component).ownedPort->exists(p|p.provided->notEmpty())
	;
	
query UML::Element::isServiceInterfaceSpecification():Boolean=
	self.oclIsKindOf(UML::Class) or self.oclIsKindOf(UML::Interface)
	;
query UML::Collaboration::serviceIdentifications():Sequence(UML::InstanceSpecification)=
	self.realizingInstance();
	
query UML::Collaboration::serviceIdentification():METADATA::ServiceIdentificationType=
	self.serviceIdentifications()->first().map ServiceIdentificationType();
	
// context is GRA Service Specification
mapping 	UML::InstanceSpecification::ServiceMetadataType(inout document:METADATA::DocumentRoot):METADATA::ServiceMetadataType@metadata
{
	document.serviceMetadata:=result;
	var serviceCollaboration:UML::Collaboration=self.realizedCollaboration()->first();
	theServiceCollaboration:=serviceCollaboration;
	// serviceIdentification is a participant component and a role of the services architecture 
	serviceIdentification:=serviceCollaboration.serviceIdentification();
	serviceCollaboration.map RelatedOrganizationInformationType(result);
	
	serviceCollaboration.ownedAttribute
		.type
		->select(t|t.isServiceIdentification()).oclAsType(UML::Component)
		.map ServiceInterfaceSpecification(result);
		
	self.map ServiceDescription(result);
	self.map VersionInformation(result);
	self.map BusinessContext(result);
	self.slot->select(s|s.definingFeature.name='ServiceLevelAgreement').value.oclAsType(UML::InstanceValue).instance	
		.map ServiceLevelAgreements(result);
}

mapping UML::InstanceSpecification::ServiceLevelAgreements(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceLevelAgreementsType
{
	serviceMetadata.serviceLevelAgreements:=result;
	self.map ServicePolicyAndContracts(result);
	self.map PerformanceMetrics(result);
	self.map ServiceUsageDetails(result);
}

mapping UML::InstanceSpecification::ServiceUsageDetails(inout serviceLevelAgreementsType:METADATA::ServiceLevelAgreementsType):METADATA::ServiceUsageType
{
	serviceLevelAgreementsType.serviceUsageDetails:=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	
	approvalRequiredIndicator:=false;
	if(not(appliedStereotype.oclIsUndefined())and  appliedStereotype.slot->select(s|s.definingFeature.name='ApprovalRequiredIndicator').value.oclAsType(UML::LiteralBoolean).value->notEmpty())then{
		approvalRequiredIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='ApprovalRequiredIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	}endif;
	licensingRequiredIndicator:=true;
	if(not(appliedStereotype.oclIsUndefined())and  appliedStereotype.slot->select(s|s.definingFeature.name='LicensingRequiredIndicator').value.oclAsType(UML::LiteralBoolean).value->notEmpty())then{
		licensingRequiredIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='LicensingRequiredIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	}endif;
	
	self.map LicensingAgreement(result);
	self.map ServiceCost(result);
}
mapping UML::InstanceSpecification::ServiceCost(inout serviceUsageDetailsType:METADATA::ServiceUsageType):METADATA::CostType
{
	serviceUsageDetailsType.serviceCost:=result;
	self.map UsageCostAmount(result);
	self.map UsageUnitCostAmount(result);
	self.map CreationCostAmount(result);
}
mapping UML::InstanceSpecification::CreationCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.creationCostAmount:=result;
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='CreationCostAmount').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	value:=appliedStereotype.slot->select(s|s.definingFeature.name='value').value.oclAsType(UML::LiteralReal).value->asSequence()->first();
	currencyText:=appliedStereotype.slot->select(s|s.definingFeature.name='currencyText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	if(value.oclIsUndefined())then{
		value:=0;
	}endif;
	
}
mapping UML::InstanceSpecification::UsageUnitCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.usageUnitCostAmount:=result;
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='UsageUnitCostAmount').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	value:=appliedStereotype.slot->select(s|s.definingFeature.name='value').value.oclAsType(UML::LiteralReal).value->asSequence()->first();
	currencyText:=appliedStereotype.slot->select(s|s.definingFeature.name='currencyText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	if(value.oclIsUndefined())then{
		value:=0;
	}endif;
	
}
mapping UML::InstanceSpecification::UsageCostAmount(inout serviceCostType:METADATA::CostType):METADATA::AmountType
{
	serviceCostType.usageCostAmount:=result;
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='UsageCostAmount').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	value:=appliedStereotype.slot->select(s|s.definingFeature.name='value').value.oclAsType(UML::LiteralReal).value->asSequence()->first();
	currencyText:=appliedStereotype.slot->select(s|s.definingFeature.name='currencyText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	if(value.oclIsUndefined())then{
		value:=0;
	}endif;
	
}
mapping UML::InstanceSpecification::LicensingAgreement(inout serviceUsageDetailsType:METADATA::ServiceUsageType):METADATA::AgreementType
{
	serviceUsageDetailsType.licensingAgreement:=result;
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='LicensingAgreement').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	agreementDescriptionText:=appliedStereotype.ownedComment.body->asSequence()->first();
	agreementURI:=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementURI').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	if(agreementDescriptionText.oclIsUndefined() and agreementURI.oclIsUndefined())then{
		agreementDescriptionText:='unknownDescription';
	}endif;
	
}
mapping UML::InstanceSpecification::PerformanceMetrics(inout serviceLevelAgreementsType:METADATA::ServiceLevelAgreementsType):METADATA::PerformanceMetricsType
{
	serviceLevelAgreementsType.performanceMetrics:=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	serviceResponseTime:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceResponseTime').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDuration();
	serviceAverageThroughput:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceAverageThroughput').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	serviceMaximumThroughput:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceMaximumThroughput').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	serviceAvailability:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceAvailability').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	if(serviceResponseTime.oclIsUndefined())then{
		serviceResponseTime:='P1Y2M3DT10H30M'.toDuration();
	}endif;
	
}

mapping UML::InstanceSpecification::ServicePolicyAndContracts(inout serviceLevelAgreementsType:METADATA::ServiceLevelAgreementsType):METADATA::ServicePolicyAndContractsType
{
	serviceLevelAgreementsType.servicePolicyAndContracts:=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	
	var appliedContractStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='ApplicableContract').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	var contractAgreementDescriptionTexts:Sequence(String)=appliedContractStereotype.ownedComment.body->asSequence();
	if(contractAgreementDescriptionTexts->notEmpty())then{
		self.map ApplicableContracts(result);	
	}endif;
	
	if(not(appliedStereotype.oclIsUndefined())and  appliedStereotype.slot->select(s|s.definingFeature.name='ApplicableContractsIndicator').value.oclAsType(UML::LiteralBoolean).value->notEmpty())then{
		applicableContractsIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='ApplicableContractsIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	}else{
		applicableContractsIndicator:=not(applicableContracts.oclIsUndefined());		
	}endif;
	
	var appliedApplicableAgreementStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='Agreement').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	var agreementAgreementDescriptionTexts:Sequence(String)=appliedApplicableAgreementStereotype.ownedComment.body->asSequence();
	var agreementAgreementURIs:Sequence(String)=appliedApplicableAgreementStereotype.slot->select(s|s.definingFeature.name='AgreementURI').value.oclAsType(UML::LiteralString).value->asSequence();
	if(agreementAgreementDescriptionTexts->notEmpty() and agreementAgreementURIs->notEmpty())then{
		self.map ApplicableAgreements(result);	
	}endif;
	if(not(appliedStereotype.oclIsUndefined())and  appliedStereotype.slot->select(s|s.definingFeature.name='ApplicableAgreementsIndicator').value.oclAsType(UML::LiteralBoolean).value->notEmpty())then{
		applicableAgreementsIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='ApplicableAgreementsIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	}else{
		applicableAgreementsIndicator:=not(applicableAgreements.oclIsUndefined());		
	}endif;
	
	var appliedUmbrellaStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='UmbrellaAgreement').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	var umbrellaAgreementAgreementDescriptionTexts:Sequence(String)=appliedUmbrellaStereotype.ownedComment.body->asSequence();
	if(umbrellaAgreementAgreementDescriptionTexts->notEmpty())then{
	self.map ApplicableUmbrellaAgreements(result);	
	}endif;
	
	
	
	if(not(appliedStereotype.oclIsUndefined())and  appliedStereotype.slot->select(s|s.definingFeature.name='ApplicableUmbrellaAgreementsIndicator').value.oclAsType(UML::LiteralBoolean).value->notEmpty())then{
		applicableUmbrellaAgreementsIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='ApplicableUmbrellaAgreementsIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();
	}else{
		applicableUmbrellaAgreementsIndicator:=not(applicableUmbrellaAgreements.oclIsUndefined());		
	}endif;
	
	applicablePoliciesIndicator:=false;// make sure it is set
	if(not(appliedStereotype.oclIsUndefined())and  appliedStereotype.slot->select(s|s.definingFeature.name='ApplicablePoliciesIndicator').value.oclAsType(UML::LiteralBoolean).value->notEmpty())then{
		applicablePoliciesIndicator:=appliedStereotype.slot->select(s|s.definingFeature.name='ApplicablePoliciesIndicator').value.oclAsType(UML::LiteralBoolean).value->asSequence()->first();	
	}endif;
	
}
mapping UML::InstanceSpecification::ApplicablePolicies(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicablePoliciesType
{
	servicePolicyAndContractsType.applicablePolicies:=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	policyText:=appliedStereotype.slot->select(s|s.definingFeature.name='ApplicablePolicies').value.oclAsType(UML::LiteralString).value->asSequence()->first();
		if((policyText.oclIsUndefined() or (policyText='')))then{
			policyText:='undefinedPolicy';
		}endif;
	
}

mapping UML::InstanceSpecification::ApplicableUmbrellaAgreements(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicableUmbrellaAgreementsType
{
	servicePolicyAndContractsType.applicableUmbrellaAgreements:=result;
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='UmbrellaAgreement').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	var umbrellaAgreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.ownedComment.body->asSequence();
	var umbrellaAgreementAgreementURIs:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementURI').value.oclAsType(UML::LiteralString).value->asSequence();
	
	umbrellaAgreementAgreementDescriptionTexts->forEach(umbrellaAgreementAgreementDescriptionText){
		umbrellaAgreementAgreementDescriptionText.map UmbrellaAgreement(result,umbrellaAgreementAgreementURIs->at(umbrellaAgreementAgreementDescriptionTexts->indexOf(umbrellaAgreementAgreementDescriptionText))); 
	};
	if(umbrellaAgreement->isEmpty())	then{
		var umbrellaAgreementNew:METADATA::AgreementType=new METADATA::AgreementType();
		umbrellaAgreement+=umbrellaAgreementNew;
		umbrellaAgreementNew.agreementDescriptionText:='unknownDescription';
		//umbrellaAgreementNew.agreementURI:='unknownURI';
	}endif;
	
}
mapping String::UmbrellaAgreement(inout applicableUmbrellaAgreementsType:METADATA::ApplicableUmbrellaAgreementsType,umbrellaAgreementAgreementURIIn:String):METADATA::AgreementType
{
	applicableUmbrellaAgreementsType.umbrellaAgreement+=result;
	agreementDescriptionText:=self;
	agreementURI:=umbrellaAgreementAgreementURIIn;
}

mapping UML::InstanceSpecification::ApplicableAgreements(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicableAgreementsType
{
	servicePolicyAndContractsType.applicableAgreements:=result;
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='Agreement').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	var agreementAgreementDescriptionTexts:Sequence(String)=appliedStereotype.ownedComment.body->asSequence();
	
	var agreementAgreementURIs:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementURI').value.oclAsType(UML::LiteralString).value->asSequence();
	agreementAgreementDescriptionTexts.map Agreement(result); 
	agreementAgreementURIs.map AgreementURI(result); 
	
/*	
	agreementAgreementDescriptionTexts->forEach(agreementAgreementDescriptionText){
		agreementAgreementDescriptionText.map Agreement(result,agreementAgreementURIs->at(agreementAgreementDescriptionTexts->indexOf(agreementAgreementDescriptionText))); 
	};
	*/
}
//mapping String::Agreement(inout applicableAgreementsType:METADATA::ApplicableAgreementsType,agreementAgreementURIIn:String):METADATA::AgreementType
mapping String::Agreement(inout applicableAgreementsType:METADATA::ApplicableAgreementsType):METADATA::AgreementType
{
	applicableAgreementsType.agreement+=result;
	agreementDescriptionText:=self;
	//agreementURI:=agreementAgreementURIIn;
}
mapping String::AgreementURI(inout applicableAgreementsType:METADATA::ApplicableAgreementsType):METADATA::AgreementType
{
	applicableAgreementsType.agreement+=result;
	agreementURI:=self;
}
mapping UML::InstanceSpecification::ApplicableContracts(inout servicePolicyAndContractsType:METADATA::ServicePolicyAndContractsType):METADATA::ApplicableContractsType
{
	servicePolicyAndContractsType.applicableContracts:=result;
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='ApplicableContract').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	var contractAgreementDescriptionTexts:Sequence(String)=appliedStereotype.ownedComment.body->asSequence();
	
	var contractAgreementURIs:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='AgreementURI').value.oclAsType(UML::LiteralString).value->asSequence();
	log('ApplicableContracts '+contractAgreementDescriptionTexts->size().repr()+', '+contractAgreementURIs->size().repr());
	contractAgreementDescriptionTexts->forEach(contractAgreementDescriptionText){
		contractAgreementDescriptionText.map Contract(result,contractAgreementURIs->at(contractAgreementDescriptionTexts->indexOf(contractAgreementDescriptionText))); 
	};
	if(contract->isEmpty())	then{
		var contractNew:METADATA::AgreementType=new METADATA::AgreementType();
		contract+=contractNew;
		contractNew.agreementDescriptionText:='unknownDescription';
		//contractNew.agreementURI:='unknownURI';
	}endif;
	
}
mapping String::Contract(inout applicableContractsType:METADATA::ApplicableContractsType,contractAgreementURIIn:String):METADATA::AgreementType
{
	applicableContractsType.contract+=result;
	agreementDescriptionText:=self;
	agreementURI:=contractAgreementURIIn;
	log('Contract  '+self+', '+contractAgreementURIIn);
}
// context is exchange partner 
mapping UML::InstanceSpecification::BusinessContext(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::BusinessContextType
{
	serviceMetadata.businessContext:=result;
	self.map DomainDescription(result);
	self.map Classifications(result);
	self.map ExchangePartnerTypes(result);
	self.map Endorsements(result);
	if(self.slot->select(s|s.definingFeature.name='Sponsors').value.oclAsType(UML::LiteralString).value->notEmpty())then{
		self.map Sponsors(result);
	}endif;
	
}
//mapping UML::Component::Classifications(inout businessContext:METADATA::BusinessContextType):METADATA::ClassificationsType
mapping UML::InstanceSpecification::Classifications(inout businessContext:METADATA::BusinessContextType):METADATA::ClassificationsType
{
	businessContext.classifications:=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	classification:=appliedStereotype.slot->select(s|s.definingFeature.name='Classification').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	if(result.classification.oclIsUndefined())then{
		classification:='unknownClassification';
	}endif;
	
}
mapping UML::InstanceSpecification::DomainDescription(inout businessContext:METADATA::BusinessContextType):METADATA::DomainDescriptionType
{
	businessContext.domainDescription:=result;
	var serviceCollaboration:UML::Collaboration=self.realizedCollaboration()->first();
	domainNameText:=serviceCollaboration.ownedComment.body->asSequence()->first();
	if(result.domainNameText.oclIsUndefined())then{
		domainNameText:='unknownDomainNameText';
	}endif;
}

mapping UML::InstanceSpecification::Sponsors(inout businessContext:METADATA::BusinessContextType):METADATA::SponsorsType
{
	businessContext.sponsors:=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	sponsor+=appliedStereotype.slot->select(s|s.definingFeature.name='Sponsors').value.oclAsType(UML::LiteralString).value->asSequence();
	if(sponsor->isEmpty())then{
		sponsor+='unnamedSponsor';
	}endif;
		
}
mapping UML::InstanceSpecification::Endorsements(inout businessContext:METADATA::BusinessContextType):METADATA::EndorsementsType
{
	businessContext.endorsements:=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	endorser+=appliedStereotype.slot->select(s|s.definingFeature.name='Endorsements').value.oclAsType(UML::LiteralString).value->asSequence();
	
}
mapping UML::InstanceSpecification::ExchangePartnerTypes(inout businessContext:METADATA::BusinessContextType):METADATA::ExchangePartnerTypesType
{
	businessContext.exchangePartnerTypes:=result;
	var serviceCollaboration:UML::Collaboration=self.realizedCollaboration()->first();
	exchangePartnerTypeDescriptionText:=serviceCollaboration.role
		->select(r|r.oclIsKindOf(UML::Property) and r.oclAsType(UML::Property).isComposite).type
		->select(s|s.oclIsKindOf(UML::Component)).ownedComment.body->asSequence()->first();
	if(result.exchangePartnerTypeDescriptionText.oclIsUndefined())then{
		exchangePartnerTypeDescriptionText:='unknownExchangePartnerTypeDescription';
	}endif;
}
// context is GRA Service Specification

mapping UML::InstanceSpecification::VersionInformation(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::VersionInformationType
{
	serviceMetadata.versionInformation:=result;
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='Version').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	majorVersion:=appliedStereotype.slot->select(s|s.definingFeature.name='MajorVersion').value.oclAsType(UML::LiteralInteger).value->asSequence()->first();
	minorVersion:=appliedStereotype.slot->select(s|s.definingFeature.name='MinorVersion').value.oclAsType(UML::LiteralInteger).value->asSequence()->first();
	if(result.majorVersion.oclIsUndefined())then{
		majorVersion:=1;
	}endif;
	if(result.minorVersion.oclIsUndefined())then{
		minorVersion:=0;
	}endif;
	lastRevisionDate:=appliedStereotype.slot->select(s|s.definingFeature.name='LastRevisionDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	lifecycleStatus:=appliedStereotype.slot->select(s|s.definingFeature.name='LifecycleStatus').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
	revisionVersion:=appliedStereotype.slot->select(s|s.definingFeature.name='RevisionVersion').value.oclAsType(UML::LiteralInteger).value->asSequence()->first();
	creationDate:=appliedStereotype.slot->select(s|s.definingFeature.name='CreationDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	activationDate:=appliedStereotype.slot->select(s|s.definingFeature.name='ActivationDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	nextRevisionDate:=appliedStereotype.slot->select(s|s.definingFeature.name='NextRevisionDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	expirationDate:=appliedStereotype.slot->select(s|s.definingFeature.name='ExpirationDate').value.oclAsType(UML::LiteralString).value->asSequence()->first().toDate();
	alertsAndNotifications+=appliedStereotype.slot->select(s|s.definingFeature.name='AlertsAndNotification').value.oclAsType(UML::LiteralString).value->asSequence();
	if(result.revisionVersion.oclIsUndefined())then{
		revisionVersion:=0;
	}endif;
	if(result.creationDate.oclIsUndefined())then{
		creationDate:='dummy'.date();
	}endif;
	if(result.lifecycleStatus.oclIsUndefined())then{
		lifecycleStatus:='In Design';
	}endif;
	
}
// context is GRA Service Specification

mapping UML::InstanceSpecification::ServiceDescription(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceDescriptionType
{
	serviceMetadata.serviceDescription:=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	
	servicePurposeText:=appliedStereotype.descriptionText('ServicePurpose');
	serviceScopeDescriptionText:=appliedStereotype.descriptionText('ServiceScopeDescription');
	serviceDescriptionSummaryText:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceDescriptionSummaryText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	serviceDescriptionText:=appliedStereotype.descriptionText('ServiceDescription');
	
	serviceDescriptionKeywordText+=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceDescriptionKeywordText').value.oclAsType(UML::LiteralString).value->asSequence();
	self.map ServiceCapabilities(result);
	self.map ServiceRealWorldEffects(result);
	
	securityClassificationText:=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceSecurityClassification').value.oclAsType(UML::InstanceValue).instance.name->asSequence()->first();
	if(self.slot->select(s|s.definingFeature.name='ServiceDependency').value.oclAsType(UML::InstanceValue).instance->notEmpty())then{
		self.map ServiceDependencies(result);
	}endif;
	if(	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).supplier->select(s|s.isStereotypeApplied(prompdStereotype))->notEmpty())then{
		self.map IEPDReferences(result);
	}endif;
	
	if(servicePurposeText.oclIsUndefined())then{
		servicePurposeText:='unknownPurpose';
	}endif;
	if(serviceScopeDescriptionText.oclIsUndefined())then{
		serviceScopeDescriptionText:='unknownDescription';
	}endif;
	
	
	
}
query UML::InstanceSpecification::descriptionText(featureName:String):String=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::InstanceValue).instance
		.realizedNamedElement().ownedComment.body->asSequence()->first();
// context is GRA Service Specification
mapping UML::InstanceSpecification::ServiceRealWorldEffects(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::ServiceRealWorldEffectsType
{
	serviceDescription.serviceRealWorldEffects:=result;
	var appliedStereotype:Sequence(UML::InstanceSpecification)=self.slot->select(s|s.definingFeature.name='RealWorldEffect').value.oclAsType(UML::InstanceValue).instance->asSequence();
	realWorldEffectDescriptionText+=appliedStereotype.realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::UseCase)).name;
	realWorldEffectDescriptionText+=appliedStereotype.realizedUseCase().name;
	
}
// context is GRA Service Specification
mapping UML::InstanceSpecification::ServiceCapabilities(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::ServiceCapabilitiesType
{
	serviceDescription.serviceCapabilities:=result;
	capabilityDescriptionText+=self.slot->select(s|s.definingFeature.name='ServiceCapabilities').value.oclAsType(UML::InstanceValue).instance
		.realizedNamedElement().ownedComment.body;
	if(capabilityDescriptionText->isEmpty())	then{
		capabilityDescriptionText+=self.ownedComment.body;
		if(capabilityDescriptionText->isEmpty())	then{
			capabilityDescriptionText+='unknownServiceCapabilityDescription';
		}endif;
	}endif;
		
}

// context is GRA Service Specification
mapping UML::InstanceSpecification::IEPDReferences(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::IEPDReferencesType
{
	serviceDescription.iEPDReferences:=result;
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).supplier->select(s|s.isStereotypeApplied(prompdStereotype)).oclAsType(UML::Component)->forEach(mpd){
		mpd.map IEPDReference(result);
	};
}
mapping 	UML::Component::IEPDReference(inout iEPDReferencesType:METADATA::IEPDReferencesType):METADATA::IEPDReferenceType
{
	iEPDReferencesType.iEPDReference+=result;
	var pimmpd:Stdlib::Element=self.GetStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
	var baseURI:String=pimmpd.getMpdBaseURI();
	iEPDURL+=baseURI;
	iEPDName+=baseURI.getLastSegmentGRA();
}
// context is GRA Service Specification
mapping UML::InstanceSpecification::ServiceDependencies(inout serviceDescription:METADATA::ServiceDescriptionType):METADATA::ServiceDependenciesType
{
	serviceDescription.serviceDependencies:=result;
	serviceDependency+=self.slot->select(s|s.definingFeature.name='ServiceDependency').value.oclAsType(UML::InstanceValue).instance
		.map ServiceIdentificationType();
}

mapping UML::Component::ServiceInterfaceSpecification(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::ServiceInterfaceSpecificationType
{
	serviceMetadata.serviceInterface+=result;
	var appliedStereotype:UML::InstanceSpecification=self.realizingInstance()->first();
	// make sure explicitly set to something otherwise will have no value
	securityImplementedIndicator:=false;
	if(not(appliedStereotype.oclIsUndefined()))then{
		appliedStereotype.slot->select(s|s.definingFeature.name='SecurityImplementedIndicator').value.oclAsType(UML::LiteralBoolean).value->forEach(indicator){
			securityImplementedIndicator:=indicator;
		};
	}endif;
	
	securityDescriptionText:=appliedStereotype.slot->select(s|s.definingFeature.name='SecurityDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
	appliedStereotype.map URIDetails(result);
	self
		.ownedPort.type
		->select(s|s.isServiceInterfaceSpecification()).oclAsType(UML::Classifier)
		.map ServiceActions(result);
		
	var appliedServiceInteractionStereotype:UML::InstanceSpecification=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceInteractionProfile').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	var sIPNames:Sequence(String)=appliedServiceInteractionStereotype.slot->select(s|s.definingFeature.name='SIPName').value.oclAsType(UML::LiteralString).value->asSequence();
	if(sIPNames->notEmpty())then{
		appliedStereotype.map ServiceInteractionProfiles(result);
	}endif;
}
// context is a ServiceInterface, a Class or Interface
mapping 	UML::InstanceSpecification::ServiceInteractionProfiles(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType):METADATA::ServiceInteractionProfilesType
{
	serviceInterfaceSpecification.serviceInteractionProfiles:=result;
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='ServiceInteractionProfile').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	var sIPNames:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='SIPName').value.oclAsType(UML::LiteralString).value->asSequence();
	var sIPVersions:Sequence(String)=appliedStereotype.slot->select(s|s.definingFeature.name='SIPVersion').value.oclAsType(UML::LiteralString).value->asSequence();
	log('ServiceInteractionProfiles '+sIPNames->size().repr()+', '+sIPVersions->size().repr());
	sIPNames->forEach(sIPName){
		sIPName.map ServiceInteractionProfile(result,sIPVersions->at(sIPNames->indexOf(sIPName))); 
	};
	if(serviceInteractionProfile->isEmpty())	then{
		var serviceInteractionProfileType:METADATA::ServiceInteractionProfileType=new METADATA::ServiceInteractionProfileType();
		serviceInteractionProfile+=serviceInteractionProfileType;
		serviceInteractionProfileType.sIPName:='unknownName';
		serviceInteractionProfileType.sIPVersion:='unknownVersion';
	}endif;
	
}
mapping 	String::ServiceInteractionProfile(inout serviceInteractionProfiles:METADATA::ServiceInteractionProfilesType,sIPVersionIn:String):METADATA::ServiceInteractionProfileType
{
	serviceInteractionProfiles.serviceInteractionProfile+=result;
	sIPName:=self;
	sIPVersion:=sIPVersionIn;
}
// context is a ServiceInterface, a Class or Interface
mapping 	UML::Classifier::ServiceActions(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType):METADATA::ServiceActionsType
{
	serviceInterfaceSpecification.serviceActions+=result;
	var operations:Sequence(UML::BehavioralFeature)=self.feature
		->select(f|f.oclIsKindOf(UML::BehavioralFeature)).oclAsType(UML::BehavioralFeature)->asSequence();
	if(operations->isEmpty() and self.oclIsKindOf(UML::BehavioredClassifier))then{
		operations:=self.oclAsType(UML::BehavioredClassifier).getAllImplementedInterfaces().feature
			->select(f|f.oclIsKindOf(UML::BehavioralFeature)).oclAsType(UML::BehavioralFeature)->asSequence();		
	}endif;
	operations->forEach(operation){
		var appliedStereotype:UML::InstanceSpecification=operation.realizingInstance()->first();
		var actionName:String=operation.name;
		if((actionName.oclIsUndefined() or (actionName=''))and operation.oclIsKindOf(UML::Reception))then{
			actionName:=operation.oclAsType(UML::Reception).signal.name;
		}endif;
		actionName.map ServiceAction(result,operation.ownedComment.body->asSequence()->first(),
				appliedStereotype.slot->select(s|s.definingFeature.name='MessageExchangePattern').value.oclAsType(UML::InstanceValue).instance.oclAsType(UML::EnumerationLiteral).name->asSequence()->first()); 
	};
}
mapping 	String::ServiceAction(inout serviceActions:METADATA::ServiceActionsType,actionPurposeIn:String,messageExchangePatternIn:String):METADATA::ServiceActionType
{
	serviceActions.serviceAction+=result;
	actionName:=self;
	actionPurpose:=actionPurposeIn;
		if(actionPurpose.oclIsUndefined() or (actionPurpose=''))then{
			actionPurpose:='unknownPurpose';
		}endif;
	messageExchangePattern:=messageExchangePatternIn;
		if(messageExchangePattern.oclIsUndefined() or (messageExchangePattern=''))then{
			messageExchangePattern:='unknownMessageExchangePattern';
		}endif;
	
	
}

// context is a ServiceInterface, a Class or Interface
mapping 	UML::InstanceSpecification::URIDetails(
	inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType):METADATA::URIDetailsType
{
	serviceInterfaceSpecification.uRIDetails:=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	var uriDescription:String=appliedStereotype.slot
		->select(s|s.definingFeature.name='URIDescription').value
		.oclAsType(UML::LiteralString).value->asSequence()->first();
	appliedStereotype.slot
		->select(s|s.definingFeature.name='URIAddress').value
		.oclAsType(UML::LiteralString).value
		.map URIDetail(result,uriDescription);
	if(uRIDetail->isEmpty())	then{
		var uriDetailNew:METADATA::URIDetailType=new METADATA::URIDetailType();
		uRIDetail+=uriDetailNew;
		uriDetailNew.uRIAddress:='unknownURI';
		uriDetailNew.uRIDescription:='unknownDescription';
	}endif;
}
mapping 	String::URIDetail(inout uriDetails:METADATA::URIDetailsType,uRIDescriptionIn:String):METADATA::URIDetailType
{
	uriDetails.uRIDetail+=result;
	uRIAddress:=self;
	uRIDescription:=uRIDescriptionIn;
}

mapping 	UML::Collaboration::RelatedOrganizationInformationType(inout serviceMetadata:METADATA::ServiceMetadataType):METADATA::RelatedOrganizationInformationType
{
	serviceMetadata.relatedOrganizationInformation+=result;
	var serviceDescription:UML::InstanceSpecification=self.realizingInstance()->first();
	serviceDescription.slot->select(s|s.definingFeature.name='RelatedOrganization').value.oclAsType(UML::InstanceValue).instance.map OrganizationType(result);
		
}
mapping 	UML::InstanceSpecification::OrganizationType(inout relatedOrganization:METADATA::RelatedOrganizationInformationType):METADATA::OrganizationType
{
	relatedOrganization.organization+=result;
	var appliedStereotype:UML::InstanceSpecification=self;
	organizationAcronym:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationAcronym').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	organizationFullAddressText:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationFullAddressText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	organizationWebSiteURL:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationWebSiteURL').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	organizationRoleDescriptionText:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationRoleDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	if(organizationRoleDescriptionText.oclIsUndefined())then{
		organizationRoleDescriptionText:='unspecifiedRoleDescription';
	}endif;
	organizationRoleDetailedDescriptionText:=appliedStereotype.slot->select(s|s.definingFeature.name='OrganizationRoleDetailedDescriptionText').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
	organizationName:=self.realizedComponent()->first().name;
	if(organizationName.oclIsUndefined())then{
		organizationName:=self.name;
		if(organizationName.oclIsUndefined())then{
			organizationName:='unnamedOrganization';
		}endif;
	}endif;
	self.map OrganizationPointOfContact(result);	
}
mapping 	UML::InstanceSpecification::OrganizationPointOfContact(inout organization:METADATA::OrganizationType):METADATA::PersonContactInformationType
{
	organization.organizationPointOfContact:=result;
	var appliedStereotype:UML::InstanceSpecification=self.slot->select(s|s.definingFeature.name='OrganizationPointOfContact').value.oclAsType(UML::InstanceValue).instance->asSequence()->first();
	contactPersonName:=appliedStereotype.realizedNamedElement()->first().name;
	contactPersonEmailID:=appliedStereotype.slot->select(s|s.definingFeature.name='ContactPersonEmailID').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	contactPersonPhoneNumberID:=appliedStereotype.slot->select(s|s.definingFeature.name='ContactPersonPhoneNumberID').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	contactPersonAddress:=appliedStereotype.slot->select(s|s.definingFeature.name='ContactPersonAddress').value.oclAsType(UML::LiteralString).value->asSequence()->first();
	
	if(contactPersonName.oclIsUndefined())then{
		contactPersonName:=appliedStereotype.name;
		if(contactPersonName.oclIsUndefined())then{
			contactPersonName:='unnamedContactPerson';
		}endif;
	}endif;
	if(contactPersonPhoneNumberID.oclIsUndefined())then{
		contactPersonPhoneNumberID:='unspecifiedPersonPhoneNumber';
	}endif;
	
}

mapping UML::InstanceSpecification::ServiceIdentificationType():METADATA::ServiceIdentificationType
	
{
	var appliedStereotype:UML::InstanceSpecification=self;// ServiceIdentification
	serviceFullNameText+=self.realizedCollaboration().name;
	serviceID+=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceID').value.oclAsType(UML::LiteralString).value	;
	serviceURI+=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceURI').value.oclAsType(UML::LiteralString).value	;
	serviceNameAbbreviationText+=appliedStereotype.slot->select(s|s.definingFeature.name='ServiceNameAbbreviationText').value.oclAsType(UML::LiteralString).value	;
}


///////////////////////////////////////////iepd
helper UML::NamedElement::displayQualifiedName(serviceInterface:UML::NamedElement):String{
	if(self=serviceInterface)then{return 'this';}else{}endif;
	return self.qualifiedName;
}
helper UML::InteractionFragment::getCoveredTypes():Set(UML::Type)=self.covered.represents.type->asSet();
helper UML::InteractionFragment::isCoveredType(type:UML::Type):Boolean=self.covered.represents.type->includes(type);
helper UML::InteractionFragment::interactionFragmentSequence(inout fragmentElement:OclAny,serviceInterface:UML::Classifier,useDelegation:Boolean){
	//  get prior and next
	if(self.enclosingInteraction.oclIsUndefined())then{
		if(self.enclosingOperand.oclIsUndefined())then{}else{
			self.fromToInteraction(self.enclosingOperand.fragment,fragmentElement,serviceInterface,useDelegation);
		}endif;
	}else{
		self.fromToInteraction(self.enclosingInteraction.fragment,fragmentElement,serviceInterface,useDelegation);
	}endif;
}	
helper UML::InteractionFragment::interactionFragment(inout fragmentElement:OclAny,serviceInterface:UML::Classifier){
	//  get prior and next
	self.interactionFragmentSequence(fragmentElement,serviceInterface,false);
	return;
}	
helper UML::InteractionFragment::getFromFragment(fragmentsIn:OrderedSet(UML::InteractionFragment),
	serviceInterface:UML::Classifier,useDelegation:Boolean):UML::InteractionFragment{
	var fragments:OrderedSet(UML::InteractionFragment)=fragmentsIn;
	if(useDelegation)then{
		fragments:=fragmentsIn->select(f|f.oclIsKindOf(UML::MessageOccurrenceSpecification));
	}else{}endif;
	var myIndex:Integer=fragments->indexOf(self);
	if(myIndex>1)then{
		var fromFragment:UML::InteractionFragment=fragments->at(myIndex-1);
		return fromFragment;
	}else{}endif;
	return null;
}	
query UML::InteractionFragment::isCombinedMOS():Boolean=
	self.oclIsKindOf(UML::MessageOccurrenceSpecification)or self.oclIsKindOf(UML::CombinedFragment);
query UML::CombinedFragment::getNestedMessageOccurrenceSpecifications(serviceInterface:UML::Classifier):Set(UML::MessageOccurrenceSpecification){
	var operands:Set(UML::InteractionOperand)=self.operand
		->select(o|o.fragment->select(f|f.isCombinedMOS())->first().isCoveredType(serviceInterface))
		->select(o|o.fragment->select(f|f.isCombinedMOS())->size()>1 or o.fragment->select(f|f.oclIsKindOf(UML::CombinedFragment))->notEmpty());
	var fragments:Set(UML::InteractionFragment)=operands
		->collect(o|
			if(o.fragment->first().oclIsKindOf(UML::CombinedFragment))
			then o.fragment->first()
			else o.fragment->select(f|f.isCombinedMOS())->at(2)
			endif
			)
		->asSet();	
	return fragments
				->collect(f|
					if(f.oclIsKindOf(UML::MessageOccurrenceSpecification))
					then Set{f.oclAsType(UML::MessageOccurrenceSpecification)}
					else f.oclAsType(UML::CombinedFragment).getNestedMessageOccurrenceSpecifications(serviceInterface)
					endif
				)	
		->asSet();
}
helper UML::InteractionFragment::getToFragments(fragmentsIn:OrderedSet(UML::InteractionFragment),
	serviceInterface:UML::Classifier,useDelegation:Boolean):Set(UML::InteractionFragment){
	var fragments:OrderedSet(UML::InteractionFragment)=fragmentsIn;
	if(useDelegation)then{
		fragments:=fragmentsIn->select(f|f.isCombinedMOS());
	}else{}endif;
	var myIndex:Integer=fragments->indexOf(self);
	if(myIndex<fragments->size())then{
		var toFragment:UML::InteractionFragment=fragments->at(myIndex+1);
		if(useDelegation and (toFragment.oclIsKindOf(UML::CombinedFragment)))then{
			return toFragment.oclAsType(UML::CombinedFragment).getNestedMessageOccurrenceSpecifications(serviceInterface);
		}else{}endif;
		return OrderedSet{toFragment};
	}else{}endif;
	return null;
}	
helper UML::InteractionFragment::fromToInteraction(fragments:OrderedSet(UML::InteractionFragment),
	inout fragmentElement:OclAny,serviceInterface:UML::Classifier,useDelegation:Boolean){
	if(fragments->includes(self))then{}else{return;}endif;
	return;
}	
////////////////////////////////////////////was GRAsoaml2wsdl

property wsdlNamespace:String='http://schemas.xmlsoap.org/wsdl/';
property soapNamespace:String='http://schemas.xmlsoap.org/wsdl/soap/';
property soapPrefix:String='soap';
property wsawsNamespace:String='http://www.w3.org/2006/05/addressing/wsdl';
property wsawsPrefix:String='wsaws';
property wspNamespace:String='http://schemas.xmlsoap.org/ws/2004/09/policy';
property wspPrefix:String='wsp';
property wsuNamespace:String='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd';
property wsuPrefix:String='wsu';
property wsrmNamespace:String='http://schemas.xmlsoap.org/ws/2005/02/rm/policy';
property wsrmPrefix:String='wsrm';
property spNamespace:String='http://schemas.xmlsoap.org/ws/2005/07/securitypolicy';
property spPrefix:String='sp';

property templateNamespace:String='http://gra.ijis.org/template';
property templatePrefix:String='template';
////////////////////abstract methods
///////////////////////////////queries and helpers
////////////////////////////extensions
//////////////////////////////////////////////////////////////////////////////////////////wsdl leaf mapping
property annotationModelNamespace:String='http://ijis.org/GRA/Annotations';
query UML::InstanceSpecification::isPolicy():Boolean=self.classifier->exists(c|c.name='Policy');
query UML::InstanceSpecification::isPolicyReference():Boolean=self.classifier->exists(c|c.name='PolicyReference');
query UML::InstanceSpecification::isEndpointReference():Boolean=self.classifier->exists(c|c.name='EndpointReference');
query UML::Slot::hasBeenMapped(hasBeenMappedSet:Set(UML::Slot)):Boolean=hasBeenMappedSet->includes(self);
query UML::NamedElement::findRealizingExtensions():Sequence(UML::InstanceSpecification)=
	self.getTargetDirectedRelationships()
		->select(r|r.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization).client
		->select(r|r.oclIsKindOf(UML::InstanceSpecification)).oclAsType(UML::InstanceSpecification)->asSequence();

query UML::Component::service():UML::Component=self;
query UML::Component::port():Set(UML::Port)=self.ownedPort;
query UML::Port::binding():UML::Classifier=self.type->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier)->asSequence()->first();
query UML::Classifier::portType(port:UML::Port):UML::Interface{
	if(self.oclIsKindOf(UML::Interface)and not(port.isConjugated))then {return self.oclAsType(UML::Interface);} endif;
	if(self.oclIsKindOf(UML::Class))then {
		if(port.isConjugated)
			then {return self.oclAsType(UML::Class).getAllUsedInterfaces()->asSequence()->first();} 
			else {return self.oclAsType(UML::Class).getRealizedInterfaces()->asSequence()->first();}
			endif;
		}endif;	
	return null;	
	}	
	/*
mapping UML::Package::NamespaceGRA():XSD::XSDSchema
	inherits UML::Package::XSDSchema
{
	var catalog:UML::Package:=sppCatalogUml.getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=self.qualifiedName;
	}else{
		relativePath:=self.qualifiedName.substringAfter(catalog.qualifiedName);
		if(relativePath.oclIsUndefined())then{
			var targetPath:String=self.qualifiedName.substringAfter(catalog.nestingPackage.qualifiedName);// TODO: should be relative to package above MPD
			relativePath:='artifacts::service model::information model::'+targetPath;
		}endif;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}else{relativePath:='.'+relativePath;}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	var relativePath:String=self.sspSchemaRelativePath(sppCatalogUml);	
	
	schemaLocation:=relativePath;
	log("added schema for uml package "+self.qualifiedName);
}
	*/
// overrides
query UML::Classifier::isObjectType():Boolean=
	self.oclIsKindOf(UML::Class);

mapping UML::Property::TopLevelElement_declarationGRA(inout psmClass:XSD::XSDSchema):XSD::XSDElementDeclaration
		inherits UML::Property::XSDElementDeclaration_topLevel
{
	typeDefinition:=self.type.oclAsType(UML::Classifier).toPsmClassifier();
}


/////////////////////////////////////////Annotations
// queries to extract various types of value(s) from an instanceSpecification, based on name of feature
query UML::InstanceSpecification::getStringValue(featureName:String):String=
	self.getStringValues(featureName)->first();
query UML::InstanceSpecification::getStringValues(featureName:String):Sequence(String)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralString).value->asSequence();
query UML::InstanceSpecification::getIntegerValue(featureName:String):Integer=
	self.getIntegerValues(featureName)->first();
query UML::InstanceSpecification::getIntegerValues(featureName:String):Sequence(Integer)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralInteger).value->asSequence();
query UML::InstanceSpecification::getBooleanValue(featureName:String):Boolean=
	self.getBooleanValues(featureName)->first();
query UML::InstanceSpecification::getBooleanValues(featureName:String):Sequence(Boolean)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralBoolean).value->asSequence();
query UML::InstanceSpecification::getInstanceValue(featureName:String):UML::InstanceSpecification=
	self.getInstanceValues(featureName)->first();
query UML::InstanceSpecification::getInstanceValues(featureName:String):Sequence(UML::InstanceSpecification)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::InstanceValue).instance->asSequence();
query UML::InstanceSpecification::getDefaultInstanceValues(featureName:String):Sequence(UML::InstanceSpecification)=
	self.getInstanceValues(featureName)
	//->select(v|v.realizedNamedElement()->isEmpty()) // back to including default whether or not it realizes anything
	;
query UML::InstanceSpecification::getRealValue(featureName:String):Real=
	self.getRealValues(featureName)->first();
query UML::InstanceSpecification::getRealValues(featureName:String):Sequence(Real)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralReal).value->asSequence();
mapping 	UML::InstanceSpecification::GRAServiceAnnotationBase():GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	template:=self.getStringValue('Template');
	flag+=self.getStringValues('Flag');
	//  derived
		name:=self.name;
		documentation:=self.ownedComment.body->asSequence()->first();
	var realizedElement:UML::NamedElement=self.realizedNamedElement()->asSequence()->first();
	if(result.name.oclIsUndefined()or(result.name=''))then{
		name:=realizedElement.name;
	}endif;
	if(result.documentation.oclIsUndefined())then{
		documentation:=realizedElement.ownedComment.body->asSequence()->first();
	}endif;
	
	modelReference:=realizedElement.map ModelReference(self,self)->asSequence()->first();
	requirement:=self.getInstanceValue('Requirement').map InteractionRequirements();
}
mapping 	UML::InstanceSpecification::GRAServiceAnnotationBaseDefault(modeledElement:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	template:=self.getStringValue('Template');
	flag+=self.getStringValues('Flag');
	//  derived
		name:=self.name;
		documentation:=self.ownedComment.body->asSequence()->first();
	var realizedElement:UML::NamedElement=modeledElement;
	if(realizedElement.oclIsUndefined())then{
		realizedElement:=self.realizedNamedElement()->asSequence()->first();
	}endif;
	
	if(result.name.oclIsUndefined() or(result.name=''))then{
		name:=realizedElement.name;
	}endif;
	if(result.documentation.oclIsUndefined())then{
		documentation:=realizedElement.ownedComment.body->asSequence()->first();
	}endif;
	
	modelReference:=realizedElement.map ModelReference(self,self)->asSequence()->first();
	requirement:=self.getInstanceValue('Requirement').map InteractionRequirements();
}
// cases which do not have sufficient uniqueness
mapping 	UML::InstanceSpecification::GRAServiceAnnotationBaseDefaultAnnotationContext(context:UML::NamedElement):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	template:=self.getStringValue('Template');
	flag+=self.getStringValues('Flag');
	//  derived
		name:=self.name;
		documentation:=self.ownedComment.body->asSequence()->first();
	var realizedElement:UML::NamedElement=self.realizedNamedElement()->asSequence()->first();
	if(result.name.oclIsUndefined() or(result.name=''))then{
		name:=realizedElement.name;
	}endif;
	if(result.documentation.oclIsUndefined())then{
		documentation:=realizedElement.ownedComment.body->asSequence()->first();
	}endif;
	
	modelReference:=realizedElement.map ModelReference(self,context)->asSequence()->first();
	requirement:=self.getInstanceValue('Requirement').map InteractionRequirements();
}
// cases which do not have sufficient uniqueness
mapping 	UML::InstanceSpecification::GRAServiceAnnotationBaseDefaultContext(modeledElement:UML::NamedElement,context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	template:=self.getStringValue('Template');
	flag+=self.getStringValues('Flag');
	//  derived
		name:=self.name;
		documentation:=self.ownedComment.body->asSequence()->first();
	var realizedElement:UML::NamedElement=modeledElement;
	if(realizedElement.oclIsUndefined())then{
		realizedElement:=self.realizedNamedElement()->asSequence()->first();
	}endif;
	
	if(result.name.oclIsUndefined() or(result.name=''))then{
		name:=realizedElement.name;
	}endif;
	if(result.documentation.oclIsUndefined())then{
		documentation:=realizedElement.ownedComment.body->asSequence()->first();
	}endif;
	
	modelReference:=realizedElement.map ModelReference(self,context)->asSequence()->first();
	requirement:=self.getInstanceValue('Requirement').map InteractionRequirements();
}
	
mapping 	UML::NamedElement::ModelReference(context:UML::NamedElement,uniqueMappingContext:UML::NamedElement):GRAA::ModelReference@graa 
{
	name:=self.name;
	documentation:=self.ownedComment.body->asSequence()->first();
	elementId:=self.getURIFragment();// via blackbox
	// TODO: diagramLink
	//diagramLink+=self.getStringValues('DiagramLink');
	model:=self.map Model(context,uniqueMappingContext);
}
	mapping 	UML::NamedElement::Model(context:UML::NamedElement,uniqueMappingContext:UML::NamedElement):GRAA::Model@graa 
{
	modelUri:=self.getRelativeURI();// via blackbox
	label:=self.emofContextURI();// via blackbox
}	
	
mapping 	UML::InstanceSpecification::InteractionRequirements():GRAA::InteractionRequirements@graa 
{

	serviceConsumerAuthentication:=self.getBooleanValue('ServiceConsumerAuthentication');
	serviceConsumerAuthorization:=self.getBooleanValue('ServiceConsumerAutorization');
	identityAndAttributeAssertionTransmission:=self.getBooleanValue('IdentityAndAttributeAssertionTransmission');
	serviceAuthentication:=self.getBooleanValue('ServiceAuthentication');
	messageNonrepudiation:=self.getBooleanValue('MessageNonrepudiation');
	messageIntegrity:=self.getBooleanValue('MessageIntegrity');
	messageConfidentiality:=self.getBooleanValue('MessageConfidentiality');
	messageAddressing:=self.getBooleanValue('MessageAddressing');
	reliability:=self.getBooleanValue('Reliability');
	transactionSupport:=self.getBooleanValue('TransactionSupport');
	serviceMetadataAvailability:=self.getBooleanValue('ServiceMetadataAvailability');
	interfaceDescriptionRequirements:=self.getBooleanValue('InterfaceDescriptionRequirements');
	logging:=self.getBooleanValue('Logging');
//	otherRequirement+=self.getStringValues('OtherRequirement');
	extendedRequirement+=self.getStringValues('ExtendedRequirement');
	serviceResponsiveness:=self.getBooleanValue('ServiceResponsiveness');
}	
mapping 	UML::InstanceSpecification::ServiceIdentification():GRAA::ServiceIdentification@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{

	serviceId:=self.getStringValue('ServiceID');
	serviceUri:=self.getStringValue('ServiceURI');
	serviceNameAbbreviationText:=self.getStringValue('ServiceNameAbbreviationText');
	if(result.serviceNameAbbreviationText.oclIsUndefined())then{
		serviceNameAbbreviationText:='UNK(ServiceIdentification.ServiceNameAbbreviationText undefined)';
	}endif;
	if(result.serviceUri.oclIsUndefined())then{
		serviceUri:='http://unknown(ServiceIdentification.ServiceURI undefined)';
	}endif;
}	
	
mapping 	UML::InstanceSpecification::GRA_WSDL():GRAA::ServiceDescription@graa
	inherits UML::InstanceSpecification::ServiceIdentification 
{
		var serviceMetadata:METADATA::ServiceMetadataType=metadataDocument.serviceMetadata->asSequence()->first();
	//serviceDescription:=self.getInstanceValue('ServiceDescription').map Description(self);// changed to documentation
	classification+=self.getStringValues('Classification');
	sponsor+=self.getStringValues('Sponsor');
	servicePurpose:=self.getInstanceValue('ServicePurpose').map Description(self);
	otherRequirement:=self.getInstanceValue('OtherRequirement').map Description(self);
	
	serviceDescriptionSummaryText:=self.getStringValue('ServiceDescriptionSummaryText');
	serviceDescriptionKeywordText+=self.getStringValues('ServiceDescriptionKeywordText');
	domainDescription:=self.getStringValue('DomainDescription');
	endorsements+=self.getStringValues('Endorsements');
	transformationUri:=self.getStringValue('TransformationURI');
	majorVersion:=self.getIntegerValue('MajorVersion');
	minorVersion:=self.getIntegerValue('MinorVersion');
	revisionVersion:=self.getIntegerValue('RevisionVersion');
	creationDate:=self.getStringValue('CreationDate');
	activationDate:=self.getStringValue('ActivationDate');
	lastRevisionDate:=self.getStringValue('LastRevisionDate');
	nextRevisionDate:=self.getStringValue('NextRevisionDate');
	expirationDate:=self.getStringValue('ExpirationDate');
	lifecycleStatus:=self.getStringValue('LifecycleStatus');
	alertAndNotificationUri:=self.getStringValue('AlertAndNotificationURI');
	serviceDescriptionUri:=serviceMetadata.SDDhref();
	
	serviceScopeDescription:=self.getInstanceValue('ServiceScopeDescription').map Description(self);
	dataProvenance:=self.getInstanceValue('DataProvenance').map Description(self);

	serviceDependency+=self.getInstanceValues('ServiceDependency').map ServiceIdentification();
	serviceSecurityClassification:=self.getInstanceValue('ServiceSecurityClassification').map SecurityClassification();
	serviceCapability+=self.getInstanceValues('ServiceCapability').map ServiceCapability();
	
	serviceAssumption:=self.getInstanceValue('ServiceAssumption').map Description(self);
	executionContext:=self.getInstanceValue('ExecutionContext').map Description(self);
	security:=self.getInstanceValue('Security').map Description(self);
	privacy:=self.getInstanceValue('Privacy').map Description(self);
	
	
	serviceLevelAgreement+=self.getInstanceValues('ServiceLevelAgreement').map ServiceLevelAgreement();
	serviceInterface+=self.getInstanceValues('ServiceInterface').map AbstractServiceInterfaceSpecification();
	relatedOrganization+=self.getInstanceValues('RelatedOrganization').map Organization();
	realWorldEffect+=self.getInstanceValues('RealWorldEffect').realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::UseCase)).oclAsType(UML::UseCase).map ImplicitUseCase(self);
	realWorldEffect+=self.getInstanceValues('RealWorldEffect')->select(i|i.realizedPackage()->isEmpty()).map UseCase();

	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).supplier->select(s|s.isStereotypeApplied(prompdStereotype)).oclAsType(UML::Component)->forEach(mpd){
		iepdReference+=mpd.map IEPDReference();
	};

	var exchangePartnerInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('ExchangePartner')->asSet();
	//exchangePartner+=exchangePartnerInstances.map Participant();
	
	exchangePartnerInstances.realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)
		->forEach(partner){exchangePartner+=partner.map Participant(partner);};
	exchangePartner+=exchangePartnerInstances->select(i|i.realizedPackage()->isEmpty()).map Participant();
	
	
	var collaboration:UML::Collaboration=self.realizedCollaboration()->first();
	var modeledExchangePartners:Set(UML::Actor)=collaboration.role.type->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSet();
	var exchangePartnerRealized:Set(UML::Actor)=self.realizedActor()->asSet();
	modeledExchangePartners
		->forEach(modeledProvider){
		exchangePartner+=modeledProvider.map Participant(modeledProvider);
	};
	var serviceInteractionInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('ServiceInteraction')->asSet();
//	serviceInteraction+=serviceInteractionInstances.map ServiceInteraction(collaboration)->asSequence()->first();
	serviceInteraction+=serviceInteractionInstances.map ServiceInteraction(collaboration)->asSequence();
	var modeledServiceInteractions:Set(UML::Interaction)=collaboration.ownedBehavior->select(t|t.oclIsKindOf(UML::Interaction)).oclAsType(UML::Interaction)->asSet();
	log('modeledServiceInteractions ');
	log('collaboration '+collaboration.repr());
	log('modeledServiceInteractions '+modeledServiceInteractions->size().repr());
	var serviceInteractionRealized:Set(UML::Interaction)=self.realizedInteraction()->asSet();
	if(result.serviceInteraction->isEmpty())then{
		modeledServiceInteractions->select(p|not(serviceInteractionRealized->includes(p)))->forEach(modeledProvider){
			serviceInteraction+=modeledProvider.map ServiceInteraction(collaboration);
		};
	}endif;
	
	additionalInformation:=self.getInstanceValues('AdditionalInformation').map Description(self);
	
}	
mapping 	UML::Component::IEPDReference():GRAA::IepdReference@graa 
{
	// derived
	var pimmpd:Stdlib::Element=self.GetStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
	var baseURI:String=pimmpd.getMpdBaseURI();
	var iEPDURL:String=baseURI;
	var iEPDName:String=baseURI.getLastSegmentGRA();
	name:=iEPDName;
	iepdurl:=iEPDURL;
	
}	
mapping 	UML::InstanceSpecification::SecurityClassification():GRAA::SecurityClassification@graa 
{
	// derived
		name:=self.name;
}	
mapping 	UML::InstanceSpecification::ServiceCapability():GRAA::ServiceCapability@graa 
{
	// derived
	documentation:=self.ownedComment.body->asSequence()->first();
}	
mapping 	UML::InstanceSpecification::Description(context:UML::NamedElement):GRAA::Description@graa 
{
	externalDocumentation:=self.getStringValue('ExternalDocumentation');

	// derived
	documentation:=self.ownedComment.body->asSequence()->first();
}	
mapping 	UML::InstanceSpecification::ServiceLevelAgreement():GRAA::ServiceLevelAgreement@graa 
{
	applicablePoliciesIndicator:=self.getBooleanValue('ApplicablePoliciesIndicator');
	applicableContractsIndicator:=self.getBooleanValue('ApplicableContractsIndicator');
	applicableAgreementsIndicator:=self.getBooleanValue('ApplicableAgreementsIndicator');
	applicableUmbrellaAgreementsIndicator:=self.getBooleanValue('ApplicableUmbrellaAgreementsIndicator');

	applicablePolicy+=self.getInstanceValues('ApplicablePolicy').map Description(self);
	approvalRequiredIndicator:=self.getBooleanValue('ApprovalRequiredIndicator');
	licensingRequiredIndicator:=self.getBooleanValue('LicensingRequiredIndicator');
	serviceResponseTime:=self.getStringValue('ServiceResponseTime');
	serviceAverageThroughput:=self.getStringValue('ServiceAverageThroughput');
	serviceMaximumThroughput:=self.getStringValue('ServiceMaximumThroughput');
	serviceAvailability:=self.getStringValue('ServiceAvailability');
	
	umbrellaAgreement+=self.getInstanceValues('UmbrellaAgreement').map Agreement();
	agreement+=self.getInstanceValues('Agreement').map Agreement();
	applicableContract+=self.getInstanceValues('ApplicableContract').map Agreement();
	licensingAgreement:=self.getInstanceValue('LicensingAgreement').map Agreement();
	
	usageUnitCostAmount:=self.getStringValue('UsageUnitCostAmount');
	creationCostAmount:=self.getStringValue('CreationCostAmount');
	usageCostAmount:=self.getStringValue('UsageCostAmount');
	if(usageCostAmount.oclIsUndefined()or(usageCostAmount=''))then{
		usageCostAmount:='0';
	}endif;
	if(usageUnitCostAmount.oclIsUndefined()or(usageUnitCostAmount=''))then{
		usageUnitCostAmount:='0';
	}endif;
	if(creationCostAmount.oclIsUndefined()or(creationCostAmount=''))then{
		creationCostAmount:='0';
	}endif;
	
}	
mapping 	UML::InstanceSpecification::AbstractServiceInterfaceSpecification():GRAA::ServiceInterfaceSpecification@graa 
	disjuncts UML::InstanceSpecification::WSDLServiceInterface,
		 UML::InstanceSpecification::ServiceInterfaceSpecification
		 {}
mapping 	UML::InstanceSpecification::ServiceInterfaceSpecification():GRAA::ServiceInterfaceSpecification@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	init{}
	securityImplementedIndicator:=self.getBooleanValue('SecurityImplementedIndicator');
	securityDescriptionText:=self.getStringValue('SecurityDescriptionText');
	serviceInterfaceNameAbbreviationText:=self.getStringValue('ServiceInterfaceNameAbbreviationText');
	messageDefinitionMechanism+=self.getInstanceValues('MessageDefinitionMechanism').map Description(self);
	serviceTesting:=self.getInstanceValue('ServiceTesting').map Description(self);
	serviceInteractionProfile:=self.getInstanceValue('ServiceInteractionProfile').map ServiceInteractionProfile();
	var portDefaults:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('PortDefault');
	var interfaceDefaults:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('InterfaceDefault');
	var operationDefaults:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('OperationDefault');
	var parameterDefaults:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('ParameterDefault');
	var messageDefaults:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('MessageDefault');
	service+=self.getInstanceValues('Service').map AbstractService(null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);

	targetNamespace:=self.getStringValue('TargetNamespace');
	prefix:=self.getStringValue('Prefix');
	if(result.prefix.oclIsUndefined()or (result.prefix=''))then{
		if(result.serviceInterfaceNameAbbreviationText.oclIsUndefined()or (result.serviceInterfaceNameAbbreviationText=''))then{
			prefix:='prefix';
		}else{
			prefix:=result.serviceInterfaceNameAbbreviationText;
		}	endif;
	}endif;
	// derived
	// the wsdlProperty is the property in the collaboration whose type is a component realized by provider instance
	var theServiceComponent:UML::Component=self.getInstanceValues('Service').realizedComponent()->asSequence()->first();
	var wsdlProperty:UML::Property=	theServiceCollaboration.ownedAttribute
		->select(a|a.type.isServiceIdentification()and(a.type=theServiceComponent))->asSequence()->first();
	
	var serviceMetadata:METADATA::ServiceMetadataType=metadataDocument.serviceMetadata->asSequence()->first();
	if(wsdlProperty.oclIsUndefined())then{
		uriAddress:='schema/SIP/unknown(service component unresolved from collaboration).wsdl';
		serviceInterfaceDescriptionUri:='artifacts/unknown(service component unresolved from collaboration)/abbrev_SIDD_ifcAbbrev_v_0.0.0.xhtml';
	}else{
		uriAddress:=wsdlProperty.wsdlLocation();
		/* should never be undefined
		if(result.uriAddress.oclIsUndefined())then{
			uriAddress:='schema/SIP/unknown.wsdl';
		}endif;
		*/
		serviceInterfaceDescriptionUri:=wsdlProperty.SIDDhref(serviceMetadata,result.serviceInterfaceNameAbbreviationText);
		/* should never be undefined
		if(result.serviceInterfaceDescriptionUri.oclIsUndefined())then{
	//		serviceInterfaceDescriptionUri:='artifacts/unknown/abbrev_SIDD_ifcAbbrev_v_0.0.0.docx';
			serviceInterfaceDescriptionUri:='artifacts/unknown/abbrev_SIDD_ifcAbbrev_v_0.0.0.xhtml';
			
		}endif;
		*/
		
	}endif;
	// get all referenced schemas, both type and element refs
	var schemas:Set(UML::Package)=Set{};
	theServiceComponent.ownedPort.provided.allBehavioralFeatures()->forEach(feature){
		var behavioralFeature:UML::BehavioralFeature=feature.oclAsType(UML::BehavioralFeature);
			//schemas+=feature.raisedException.getNearestPackage()->select(p|p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype));
		// collect both type and element references	
//		if(behavioralFeature.isDocumentStyle())then{
			// use an element (property whose type is messagetype): either 
//			schemas+=behavioralFeature.messagePartElement().getNearestPackage()->select(p|p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype));
			feature.raisedException.messagePartElements().getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
				->forEach(p){schemas+=p;};
			if(feature.oclIsKindOf(UML::Reception))then{
//				schemas+=feature.oclAsType(UML::Reception).signal.ownedAttribute.messagePartElement().getNearestPackage()->select(p|p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype));
				feature.oclAsType(UML::Reception).signal.ownedAttribute.messagePartElements().getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
					->forEach(p){schemas+=p;};
			}else{
//				schemas+=feature.ownedParameter.messagePartElement().getNearestPackage()
				feature.ownedParameter.messagePartElements().getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
					->forEach(p){schemas+=p;};
			}endif;
			
//		}else{
			feature.raisedException.getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
				->forEach(p){schemas+=p;};
			if(feature.oclIsKindOf(UML::Reception))then{
//				schemas+=feature.oclAsType(UML::Reception).signal.ownedAttribute.type.getNearestPackage()->select(p|p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype));
				feature.oclAsType(UML::Reception).signal.ownedAttribute.type.getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
					->forEach(p){schemas+=p;};
			}else{
//				schemas+=feature.ownedParameter.type.getNearestPackage()->select(p|p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype));
				feature.ownedParameter.type.getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
					->forEach(p){schemas+=p;};
			}endif;
//		}endif;
		
	};		
			
	
	schemas->forEach(schema){
		schemaReference+=schema.map SchemaReference(self);
	};
}	
query UML::Package::sspSchemaRelativePath(mpdcatalog:UML::Component):String{
	var catalog:UML::Package:=mpdcatalog.getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=self.qualifiedName;
	}else{
		// this form probably never occurs
		var targetPath:String=mpdcatalog.name+self.qualifiedName.substringAfter(catalog.qualifiedName);
		if(targetPath.oclIsUndefined())then{
			// probably best path is simply path with two top levels removed
			targetPath:=mpdcatalog.name+'::'+self.qualifiedName.substringAfter('::').substringAfter('::');
			/*
			targetPath:=mpdcatalog.name+self.qualifiedName.substringAfter(catalog.nestingPackage.qualifiedName);//  should be relative to package above MPD
			if(targetPath.oclIsUndefined())then{
				targetPath:=mpdcatalog.name+self.qualifiedName.substringAfter(catalog.nestingPackage.nestingPackage.qualifiedName);
			}endif;
			*/
		}endif;
		relativePath:='artifacts::service model::information model::'+targetPath;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	return relativePath;	
}
mapping 	UML::Package::SchemaReference(context:UML::NamedElement):GRAA::SchemaReference@graa 
{
	
	var pimStereotypeInstance:Stdlib::Element=self.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=self.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
	namespace:=pimStereotypeInstance.getSchemaTargetNamespace();
	if(namespace.oclIsUndefined())then{
		namespace:='NoSchemaTargetNamespaceInInformationModel';
	}endif;
	// set prefix to be used for Schema namespace
	prefix:=pimStereotypeInstance.getSsspSchemaDefaultPrefix();
	if(result.prefix.oclIsUndefined()or (result.prefix=''))then{
		prefix:='NoSchemaDefaultPrefixInInformationModel';
	}endif;

	// schemaLocation
	var mpdcatalog:UML::Component:=sppCatalogUml.clientDependency.supplier->select(c|c.oclIsKindOf(UML::Component)).oclAsType(UML::Component)->asSequence()->first();
	/*
	var catalog:UML::Package:=mpdcatalog.getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=self.qualifiedName;
	}else{
		var targetPath:String=mpdcatalog.name+self.qualifiedName.substringAfter(catalog.qualifiedName);
		if(targetPath.oclIsUndefined())then{
			targetPath:=mpdcatalog.name+self.qualifiedName.substringAfter(catalog.nestingPackage.qualifiedName);//  should be relative to package above MPD
			if(targetPath.oclIsUndefined())then{
				targetPath:=mpdcatalog.name+self.qualifiedName.substringAfter(catalog.nestingPackage.nestingPackage.qualifiedName);
			}endif;
		}endif;
		relativePath:='artifacts::service model::information model::'+targetPath;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	*/
	var relativePath:String=self.sspSchemaRelativePath(mpdcatalog);	
	schemaLocation:=relativePath;
	
}

query  Stdlib::Element::getSsspSchemaDefaultPrefix():String { 
	// if namespace has standard prefix defined, use it
    var prefix:String= self.getSchemaDefaultPrefix();
    if(prefix.oclIsUndefined())then{
		var targetNamespace:String=self.getSchemaTargetNamespace();
		prefixToNamespace->forEach(entry){
			if(entry.namespace=targetNamespace)then{
				prefix:=entry.prefix;
			}endif;
		};
    }endif;
    return prefix;
}


mapping 	UML::InstanceSpecification::WSDLServiceInterface():GRAW::WsdlServiceInterface@graa 
	inherits UML::InstanceSpecification::ServiceInterfaceSpecification
	when{self.classifier.name->asSet()->includes('WSDLServiceInterface')}
{
}

	mapping 	UML::InstanceSpecification::Organization():GRAA::Organization@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	organizationAcronym:=self.getStringValue('OrganizationAcronym');
	organizationFullAddressText:=self.getStringValue('OrganizationFullAddressText');
	organizationWebSiteUrl:=self.getStringValue('OrganizationWebSiteURL');
	organizationRoleDescriptionText:=self.getStringValue('OrganizationRoleDescriptionText');
	if(organizationRoleDescriptionText.oclIsUndefined())then{
		organizationRoleDescriptionText:='No Organization Role';
	}endif;
	organizationRoleDetailedDescriptionText:=self.getStringValue('OrganizationRoleDetailedDescriptionText');
	organizationPointOfContact:=self.getInstanceValue('OrganizationPointOfContact').map Person();
}	
	mapping 	UML::InstanceSpecification::OrganizationDefault(modeledElement:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Organization@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
	
{
	organizationAcronym:=self.getStringValue('OrganizationAcronym');
	organizationFullAddressText:=self.getStringValue('OrganizationFullAddressText');
	organizationWebSiteUrl:=self.getStringValue('OrganizationWebSiteURL');
	organizationRoleDescriptionText:=self.getStringValue('OrganizationRoleDescriptionText');
	organizationRoleDetailedDescriptionText:=self.getStringValue('OrganizationRoleDetailedDescriptionText');
	organizationPointOfContact:=self.getInstanceValue('OrganizationPointOfContact').map Person();
}	
	mapping 	UML::InstanceSpecification::Person():GRAA::Person@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	contactPersonEmailId:=self.getStringValue('ContactPersonEmailID');
	contactPersonPhoneNumberId:=self.getStringValue('ContactPersonPhoneNumberID');
	contactPersonAddress:=self.getStringValue('ContactPersonAddress');
}	
	mapping 	UML::InstanceSpecification::Participant():GRAA::Participant@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	participatingOrganization:=self.getInstanceValue('ParticipatingOrganization').map Organization();
	generalization:=self.getInstanceValues('Generalization').map Participant(self);
}
	mapping 	UML::InstanceSpecification::Participant(context:UML::NamedElement):GRAA::Participant@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefaultAnnotationContext
{
	participatingOrganization:=self.getInstanceValue('ParticipatingOrganization').map Organization();
	generalization:=self.getInstanceValues('Generalization').map Participant(self);
}
	mapping 	UML::Actor::Participant(context:UML::NamedElement):GRAA::Participant@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple
{
	// empty
	generalization:=self.general->select(g|g.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor).map Participant(self);
}
	mapping 	UML::Type::Participant(context:UML::NamedElement):GRAA::Participant@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple
{
	// empty
	if(self.oclIsKindOf(UML::Classifier))then{
		generalization:=self.oclAsType(UML::Classifier).general.map Participant(self);
	}endif;
}
/*
	mapping 	UML::InstanceSpecification::ParticipantDefault(modeledElement:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Participant@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
	
{
	// empty
}
*/
	mapping 	UML::UseCase::ImplicitUseCase(context:UML::NamedElement):GRAA::UseCase@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple
	
{
	//  derived

	var modeledProviders:Set(UML::Actor)= self.getProviderActors()->asSet();
	var modeledConsumers:Set(UML::Actor)= self.getConsumerActors()->asSet();
	//log('modeledProviders implicit');
	//log('modeledProviders implicit '+modeledProviders->size().repr());
	//log('modeledConsumers implicit '+modeledConsumers->size().repr());
	
	modeledProviders->forEach(modeledProvider){
		provider+=modeledProvider.map Participant(self);
	};
	modeledConsumers->forEach(modeledProvider){
		consumer+=modeledProvider.map Participant(self);
	};
	
}	
		
	mapping 	UML::InstanceSpecification::UseCase():GRAA::UseCase@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	var providerInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('Provider')->asSet();
	var consumerInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('Consumer')->asSet();
	//  derived
	var useCases:Set(UML::UseCase)=self.realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::UseCase)).oclAsType(UML::UseCase)->asSet();
	provider+=providerInstances.map Participant();
	consumer+=consumerInstances.map Participant();

	var realizedProviders:Set(UML::Actor)= providerInstances.realizedActor()->asSet();
	var realizedConsumers:Set(UML::Actor)= consumerInstances.realizedActor()->asSet();
	//log('realizedProviders ');
	//log('realizedProviders '+realizedProviders->size().repr());
	//log('realizedConsumers '+realizedConsumers->size().repr());
	var modeledProviders:Set(UML::Actor)= useCases.getProviderActors()->asSet();
	var modeledConsumers:Set(UML::Actor)= useCases.getConsumerActors()->asSet();
	//log('modeledProviders implicit');
	//log('modeledProviders implicit '+modeledProviders->size().repr());
	//log('modeledConsumers implicit '+modeledConsumers->size().repr());
	
	modeledProviders->select(p|not(realizedProviders->includes(p)))->forEach(modeledProvider){
		provider+=modeledProvider.map Participant(modeledProvider);
	};
	modeledConsumers->select(p|not(realizedConsumers->includes(p)))->forEach(modeledProvider){
		consumer+=modeledProvider.map Participant(modeledProvider);
	};
	
}	

query UML::Element::getProviderAssociation():Set(UML::Association){
	return self.getRelationships()
		->select(t|t.oclIsKindOf(UML::Association) and t.getAppliedStereotypes().name->exists(n|n='Provider')).oclAsType(UML::Association)->asSet();
}
query UML::Element::getConsumerAssociation():Set(UML::Association){
	return self.getRelationships()
		->select(t|t.oclIsKindOf(UML::Association) and t.getAppliedStereotypes().name->exists(n|n='Consumer')).oclAsType(UML::Association)->asSet();
}
	
query UML::UseCase::getProviderActors():Set(UML::Actor){
	return self.getProviderAssociation().ownedEnd.type->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSet();
}
query UML::UseCase::getConsumerActors():Set(UML::Actor){
	return self.getConsumerAssociation().ownedEnd.type->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSet();
}

	mapping 	UML::InstanceSpecification::ServiceInteraction():GRAA::ServiceInteraction@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
{
	participant+=self.getInstanceValues('Participant').map Participant();
}	
mapping 	UML::InstanceSpecification::ServiceInteraction(context:UML::Collaboration):GRAA::ServiceInteraction@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple 
{
	var modeledParticipants:Set(UML::Type)=context.ownedBehavior
		->select(t|t.oclIsKindOf(UML::Interaction)).oclAsType(UML::Interaction).lifeline.represents.type->asSet();
	var participants:Sequence(UML::InstanceSpecification)=self.getInstanceValues('Participant');
	participant+=participants.map Participant();
	var participantsRealized:Set(UML::Type)=participants.realizedType()->asSet();
	modeledParticipants->select(p|not(participantsRealized->includes(p)))->forEach(modeledParticipant){
		participant+=modeledParticipant.map Participant(modeledParticipant);
	};
	
}	
mapping 	UML::Interaction::ServiceInteraction(context:UML::NamedElement):GRAA::ServiceInteraction@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple 
{
//	participant+=self.getInstanceValues('participant').map Participant();
	var types:Set(UML::Type)=self.lifeline.represents.type->asSet();
	types->forEach(type){
		participant+=type.map Participant(type);
	};
}	


mapping 	UML::InstanceSpecification::AbstractService(modeledComponent:UML::Component,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Service@graa 
	disjuncts UML::InstanceSpecification::WSDLService,
		 UML::InstanceSpecification::Service
		 {}
mapping 	UML::InstanceSpecification::WSDLService(modeledComponent:UML::Component,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlService@graa 
	inherits UML::InstanceSpecification::Service
	when{self.classifier.name->asSet()->includes('WSDLService')}
{
}

	mapping 	UML::InstanceSpecification::Service(modeledComponent:UML::Component,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Service@graa 
	//inherits UML::InstanceSpecification::ParticipantDefault 
{

	var interfaceDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('InterfaceDefault');
	var operationDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('OperationDefault');
	var parameterDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('ParameterDefault');
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('MessageDefault');

	var interfaceDefaultsy:Sequence(UML::InstanceSpecification)=interfaceDefaults;
	var operationDefaultsy:Sequence(UML::InstanceSpecification)=operationDefaults;
	var parameterDefaultsy:Sequence(UML::InstanceSpecification)=parameterDefaults;
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(interfaceDefaultsx->notEmpty())then{interfaceDefaultsy:=interfaceDefaultsx;}endif;
	if(operationDefaultsx->notEmpty())then{operationDefaultsy:=operationDefaultsx;}endif;
	if(parameterDefaultsx->notEmpty())then{parameterDefaultsy:=parameterDefaultsx;}endif;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;

	
	// add explicitly modeled port instances; if not modeled, add implicit ports
	var portInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Port')->asSet();
	// uml Ports realized by the explicit port instances
	var portsRealized:Set(UML::Port)= portInstances.realizedPort()->asSet();
	var serviceComponent:UML::Component=self.realizedComponent()->first();
	if(not(modeledComponent.oclIsUndefined()))then{
		serviceComponent:=modeledComponent;
	}endif;
	// ports in uml model owned by the realized component
	var modeledPorts:Set(UML::Port)= serviceComponent.ownedPort;
	// each explicitly modeled port instance mapped to AbstractPort
	port+=portInstances.map AbstractPort(null,portDefaults,interfaceDefaultsy,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
	// each port owned by realized component is mapped, if it was not already included in ports realized by instances
	modeledPorts->select(p|not(portsRealized->includes(p)))->forEach(modeledPort){
		/*
		if(portDefaults->notEmpty())then{
			port+=portDefaults.map AbstractPort(modeledPort,portDefaults,interfaceDefaultsy,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
			//port+=portDefaults.map AbstractPort(modeledPort,portDefaults,interfaceDefaults,operationDefaults,messageDefaults);
		}else{
			// there were no instance port defaults; map the modeled port implicitly
			port+=modeledPort.mapImplicitPort(modeledPort,portDefaults,interfaceDefaultsy,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
		}endif;
		*/
		var targetPort:GRAA::Port=modeledPort.mapImplicitPort(modeledPort,portDefaults,interfaceDefaultsy,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
		if(not(targetPort.oclIsUndefined()))then{
			port+=targetPort;
		}endif;
	};
		//Plus SampleData, each with an optional Input and ExpectedOutput
	sampleData+=self.getInstanceValues('SampleData').map SampleData();
	serviceProvider:=self.getInstanceValue('ServiceProvider').map Participant(self);
	
	
}	
mapping 	UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple(context:UML::NamedElement):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	//  derived
	name:=self.name;
	documentation:=self.ownedComment.body->asSequence()->first();
	modelReference:=self.map ModelReference(context,context);
}	
mapping 	UML::NamedElement::ImplicitGRAServiceAnnotationBase(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	//  derived
	if(self.name.oclIsUndefined() or (self.name=''))then{
		name:='unNamed';
	}else{
		name:=self.name;
	}endif;
	documentation:=self.ownedComment.body->asSequence()->first();
	modelReference:=self.map ModelReference(self,self);
}	
helper 	UML::Port::mapImplicitPort(context:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port{
	// find instance which is WSDLPort or Port
	// if none, check defaults
	// if none, do implicitPorte
	var resultOperation:GRAA::Port=null;
	/* no general defaults
	// check for WSDLPort
	self.realizingInstance('WSDLPort')->forEach(wsdlPort){
		return wsdlPort.map AbstractPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check for Port
	self.realizingInstance('Port')->forEach(wsdlPort){
		return wsdlPort.map AbstractPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	*/
	// check portDefaults, if default realizes this port, map it
	portDefaults->select(p|p.realizedPort()->exists(rp|self=rp))->forEach(wsdlPort){
		return wsdlPort.map AbstractPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// otherwise, try to map an unrealized default
	portDefaults->select(p|p.realizedPort()->isEmpty())->forEach(wsdlPort){
		return wsdlPort.map AbstractPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// general defaults not supported --back track, need to have default here
	// if we get this far, model does not have qualifying port instance, so map implicitly
	return self.map ImplicitPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	//return null;// failed
} 
// general defaults not supported - backtrack,
//	implicit mapping for port when no qualying port instance defined
	mapping 	UML::Port::ImplicitPort(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
	interface+=self.provided.mapImplicitInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=self.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=self.type.name;
		}endif;
	}endif;
	addressUri:='http://'+result.name;
}	

mapping 	UML::InstanceSpecification::AbstractPort(modeledPort:UML::Port,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port@graa 
	disjuncts UML::InstanceSpecification::WSDLPort,
		 UML::InstanceSpecification::Port
		 {}
mapping 	UML::InstanceSpecification::WSDLPort(modeledPort:UML::Port,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlPort@graa 
	inherits UML::InstanceSpecification::Port
	when{self.classifier.name->asSet()->includes('WSDLPort')}
{
		certificate:=self.getStringValue('Certificate');

}
	mapping 	UML::InstanceSpecification::Port(modeledPort:UML::Port,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{
	
	var operationDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('OperationDefault');
	var parameterDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('ParameterDefault');
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('MessageDefault');
	
	var operationDefaultsy:Sequence(UML::InstanceSpecification)=operationDefaults;
	var parameterDefaultsy:Sequence(UML::InstanceSpecification)=parameterDefaults;
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(operationDefaultsx->notEmpty())then{operationDefaultsy:=operationDefaultsx;}endif;
	if(parameterDefaultsx->notEmpty())then{parameterDefaultsy:=parameterDefaultsx;}endif;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;
	
	
	addressUri:=self.getStringValue('AddressURI');
	if(result.addressUri.oclIsUndefined())then{
		addressUri:='http://'+result.name;
	}endif;
	
	// add explicitly modeled interfaces; if not modeled, add implicit interfaces
	var interfaceInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Interface')->asSet();
	var interfacesRealized:Set(UML::Interface)= interfaceInstances.realizedInterface()->asSet();
	var servicePorts:Set(UML::Port)=self.realizedPort()->asSet();
	if(not(modeledPort.oclIsUndefined()))then{
		servicePorts:=Set{modeledPort};
	}endif;
	
	var modeledInterfaces:Set(UML::Interface)= servicePorts.provided->asSet();
	interface+=interfaceInstances.map AbstractInterface(null,portDefaults,interfaceDefaults,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
	modeledInterfaces->select(p|not(interfacesRealized->includes(p)))->forEach(modeledInterface){
		/*
		if(interfaceDefaults->notEmpty())then{
			interface+=interfaceDefaults.map AbstractInterface(modeledInterface,portDefaults,interfaceDefaults,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
		}else{
			interface+=modeledInterface.mapImplicitInterface(modeledPort,portDefaults,interfaceDefaults,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
		}endif;
		*/
		var targetInterface:GRAA::Interface=modeledInterface.mapImplicitInterface(modeledPort,portDefaults,interfaceDefaults,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
		if(not(targetInterface.oclIsUndefined()))then{
			interface+=targetInterface;
		}endif;
	};
	
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=servicePorts.name->asSequence()->first();
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=servicePorts.type.name->asSequence()->first();
		}endif;
	}endif;
}	
helper 	UML::Interface::mapImplicitInterface(context:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface{
	// find instance which is WSDLInterface or Interface
	// if none, check defaults
	// if none, do implicitInterface
	var resultOperation:GRAA::Interface=null;
	/*
	// check for WSDLOperation
	self.realizingInstance('WSDLInterface')->forEach(wsdlInterface){
		return wsdlInterface.map AbstractInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check for Operation
	self.realizingInstance('Interface')->forEach(wsdlInterface){
		return wsdlInterface.map AbstractInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	*/
	// check InterfaceDefaults
	/*
	interfaceDefaults->forEach(operationDefault){
		return operationDefault.map AbstractInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	return self.map ImplicitInterface(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	*/
	// check InterfaceDefaults, if default realizes this port, map it
	interfaceDefaults->select(p|p.realizedInterface()->exists(rp|self=rp))->forEach(operationDefault){
		return operationDefault.map AbstractInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// otherwise, try to map an unrealized default
	interfaceDefaults->select(p|p.realizedInterface()->isEmpty())->forEach(operationDefault){
		return operationDefault.map AbstractInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// general defaults not supported - backtrack
	// if we get this far, then no qualifying interface instance, so we must make implicit interface
	return self.map ImplicitInterface(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	//return null;// failed
	
} 

	mapping 	UML::Interface::ImplicitInterface(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
	self.allBehavioralFeatures()->forEach(behavioralFeature){
		operation+=behavioralFeature.mapImplicitOperation(behavioralFeature,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
}	
mapping 	UML::InstanceSpecification::AbstractInterface(modeledInterface:UML::Interface,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface@graa 
	disjuncts UML::InstanceSpecification::WSDLInterface,
		 UML::InstanceSpecification::Interface
		 {}
mapping 	UML::InstanceSpecification::WSDLInterface(modeledInterface:UML::Interface,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlInterface@graa 
	inherits UML::InstanceSpecification::Interface
	when{self.classifier.name->asSet()->includes('WSDLInterface')}
{
		var bindingName:String=self.getInstanceValue('BindingCode').name;
		switch{
			case(bindingName='soap'){
				bindingCode:=GRAW::BindingType::soap;
			};	
			case(bindingName='soap12'){
				bindingCode:=GRAW::BindingType::soap12;
			};	
			case(bindingName='http_get'){
				bindingCode:=GRAW::BindingType::httpGet;
			};	
			case(bindingName='http_put'){
				bindingCode:=GRAW::BindingType::httpPut;
			};	
		};
	
}
	mapping 	UML::InstanceSpecification::Interface(modeledInterface:UML::Interface,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{

	var parameterDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('ParameterDefault');
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('MessageDefault');
	//messageDefault+=messageDefaultsx.map AbstractMessage(null,Sequence{},Sequence{},Sequence{},Sequence{});
	var parameterDefaultsy:Sequence(UML::InstanceSpecification)=parameterDefaults;
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(parameterDefaultsx->notEmpty())then{parameterDefaultsy:=parameterDefaultsx;}endif;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;
	
	
	
	// add explicitly modeled operations; if not modeled, add implicit operations
	var operationInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Operation')->asSet();
	var operationsRealized:Set(UML::BehavioralFeature)= operationInstances.realizedBehavioralFeature()->asSet();
	var serviceInterfaces:Set(UML::Interface)=self.realizedInterface()->asSet();
	if(not(modeledInterface.oclIsUndefined()))then{
		serviceInterfaces:=Set{modeledInterface};
	}endif;
	var modeledOperations:Set(UML::BehavioralFeature)= serviceInterfaces.allBehavioralFeatures()->asSet();
	operation+=operationInstances.map AbstractOperation(null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaultsy,messageDefaultsy);
	modeledOperations->select(p|not(operationsRealized->includes(p)))->forEach(modeledOperation){
		/*
		if(operationDefaults->notEmpty())then{
			operation+=operationDefaults.map AbstractOperation(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaultsy,messageDefaultsy);
		}else{
			operation+=modeledOperation.mapImplicitOperation(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
		}endif;
		*/
		var targetOperation:GRAA::Operation=modeledOperation.mapImplicitOperation(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
		if(not(targetOperation.oclIsUndefined()))then{
			operation+=targetOperation;
		}endif;
	};
	
}	
// determine if implicit, a default, explicit realization for a modeled behavioral feature
helper 	UML::BehavioralFeature::mapImplicitOperation(context:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation{
	// find instance which is WSDLOperation or Operation
	// if none, check defaults
	// if none, do implicitOperation
	var resultOperation:GRAA::Operation=null;
	/*
	// check for WSDLOperation
	self.realizingInstance('WSDLOperation')->forEach(wsdlOperation){
		return wsdlOperation.map AbstractOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check for Operation
	self.realizingInstance('Operation')->forEach(wsdlOperation){
		return wsdlOperation.map AbstractOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	*/
	/*
	// check operationDefaults
	operationDefaults->forEach(operationDefault){
		return operationDefault.map AbstractOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	return self.map ImplicitOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	*/
	
	// check InterfaceDefaults, if default realizes this port, map it
	operationDefaults->select(p|p.realizedBehavioralFeature()->exists(rp|self=rp))->forEach(operationDefault){
		return operationDefault.map AbstractOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// otherwise, try to map an unrealized default
	operationDefaults->select(p|p.realizedBehavioralFeature()->isEmpty())->forEach(operationDefault){
		return operationDefault.map AbstractOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// general defaults not supported - backtract
	// if we get this far, no qualifying operation instance so we must implicitly create the operation instance
	return self.map ImplicitOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	//return null;// failed
	
} 

	mapping 	UML::BehavioralFeature::ImplicitOperation(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
	actionName:=self.name;
	parameter+=self.raisedException.mapImplicitParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	if(self.oclIsKindOf(UML::Reception))then{
		parameter+=self.oclAsType(UML::Reception).signal.ownedAttribute.mapImplicitParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
		if(result.name.oclIsUndefined()or (result.name=''))then{
			name:=self.oclAsType(UML::Reception).signal.name;
		}endif;
		if(result.actionName.oclIsUndefined()or (result.actionName=''))then{
			actionName:=self.oclAsType(UML::Reception).signal.name;
		}endif;
	}else{
		parameter+=self.ownedParameter.mapImplicitParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
/* only one message per parameter, must handle multiple in/out via xslt
		var inParameter:UML::Parameter=self.ownedParameter->select(p|(p.direction=UML::ParameterDirectionKind::_in)or(p.direction=UML::ParameterDirectionKind::_inout))->asSequence()->first();
		var outParameter:UML::Parameter=self.ownedParameter->select(p|p.direction<>UML::ParameterDirectionKind::_in)->asSequence()->first();
		if(not(inParameter.oclIsUndefined()))then{parameter+=inParameter.mapImplicitParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);}endif;
		if(not(outParameter.oclIsUndefined()))then{parameter+=outParameter.mapImplicitParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);}endif;
*/		
	}endif;
	isAsynchronous:=self.oclIsKindOf(UML::Reception);
	actionPurpose:=self.ownedComment.body->asSequence()->first();
}

mapping 	UML::InstanceSpecification::AbstractOperation(modeledOperation:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation@graa 
	disjuncts UML::InstanceSpecification::WSDLOperation,
		 UML::InstanceSpecification::Operation
		 {}
mapping 	UML::InstanceSpecification::WSDLOperation(modeledOperation:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlOperation@graa 
	inherits UML::InstanceSpecification::Operation
	when{self.classifier.name->asSet()->includes('WSDLOperation')}
{
		var kindName:String=self.getInstanceValue('OperationKindCode').name;
		switch{
			case(kindName='doc'){
				operationKindCode:=GRAW::OperationKind::doc;
			};	
			case(kindName='rpc'){
				operationKindCode:=GRAW::OperationKind::rpc;
			};	
		};
}

	
	mapping 	UML::InstanceSpecification::Operation(modeledOperation:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('MessageDefault');
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;
	// add explicitly modeled messages; if not modeled, add implicit messages
	var messageInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Parameter')->asSet();
	var messagesRealized:Set(UML::TypedElement)= messageInstances.realizedTypedElement()->asSet();
	var serviceOperations:Set(UML::BehavioralFeature)=self.realizedBehavioralFeature()->asSet();
	if(not(modeledOperation.oclIsUndefined()))then{
		serviceOperations:=Set{modeledOperation};
	}endif;
		actionName:=serviceOperations.name->asSequence()->first();
	var modeledMessages:Set(UML::TypedElement)= Set{};
	
	if(modeledOperation.oclIsKindOf(UML::Reception))then{
		modeledMessages+=modeledOperation.oclAsType(UML::Reception).signal.ownedAttribute;
		if(result.name.oclIsUndefined()or (result.name=''))then{
			name:=modeledOperation.oclAsType(UML::Reception).signal.name;
		}endif;
		if(result.actionName.oclIsUndefined()or (result.actionName=''))then{
			actionName:=modeledOperation.oclAsType(UML::Reception).signal.name;
		}endif;
	}else{
		modeledMessages+=modeledOperation.ownedParameter;
	}endif;
	parameter+=messageInstances.map AbstractParameter(null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
	
	modeledMessages->select(p|not(messagesRealized->includes(p)))->forEach(modeledMessage){
		/*
		if(parameterDefaults->notEmpty())then{
			parameter+=parameterDefaults.map AbstractParameter(modeledMessage,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
		}else{
			parameter+=modeledMessage.mapImplicitParameter(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
		}endif;
		*/
		var targetParameter:GRAA::Parameter=modeledMessage.mapImplicitParameter(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
		if(not(targetParameter.oclIsUndefined()))then{
			parameter+=targetParameter;
		}endif;
	};
	
	/* can not do multile message per part, so let phase 2 handle
		var inParameter:UML::TypedElement=modeledMessages->select(p|not(messagesRealized->includes(p)))
			->select(p|p.oclIsKindOf(UML::Parameter) or (p.oclIsKindOf(UML::Parameter) and (p.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_in)or(p.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_inout)))
				->asSequence()->first();
		var outParameter:UML::TypedElement=modeledMessages->select(p|p.oclIsKindOf(UML::Parameter) and not(messagesRealized->includes(p))).oclAsType(UML::Parameter)
			->select(p|p.direction<>UML::ParameterDirectionKind::_in)->asSequence()->first();
		if(not(inParameter.oclIsUndefined()))then{parameter+=inParameter.mapImplicitParameter(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);}endif;
		if(not(outParameter.oclIsUndefined()))then{parameter+=outParameter.mapImplicitParameter(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);}endif;
	*/
	// exceptions
	var messagesExceptionRealized:Set(UML::Type)= messageInstances.realizedType()->asSet();
//	parameter+=messagesExceptionRealized.map AbstractParameter(null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
	parameter+=messagesExceptionRealized.mapImplicitParameter(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
//	parameter+=messageInstances.map AbstractParameter(null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
	//modeledOperation.raisedException->select(p|not(messagesExceptionRealized->includes(p)))->forEach(modeledMessage){
	serviceOperations.raisedException->select(p|not(messagesExceptionRealized->includes(p)))->forEach(modeledMessage){
		/*
		if(parameterDefaults->notEmpty())then{
			parameter+=parameterDefaults.map AbstractParameter(modeledMessage,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
		}else{
			parameter+=modeledMessage.mapImplicitParameter(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
		}endif;
		*/
		var targetParameter:GRAA::Parameter=modeledMessage.mapImplicitParameter(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaultsy);
		if(not(targetParameter.oclIsUndefined()))then{
			parameter+=targetParameter;
		}endif;
		
	};

	
	
		var messageExchangePatternName:String=self.getInstanceValue('MessageExchangePattern').name;
		switch{
			case(messageExchangePatternName='enquiry'){
				messageExchangePattern:=GRAA::ExchangePattern::enquiry;
			};	
			case(messageExchangePatternName='subscription'){
				messageExchangePattern:=GRAA::ExchangePattern::subscription;
			};	
			case(messageExchangePatternName='notification'){
				messageExchangePattern:=GRAA::ExchangePattern::notification;
			};	
			case(messageExchangePatternName='update'){
				messageExchangePattern:=GRAA::ExchangePattern::update;
			};	
			case(messageExchangePatternName='message'){
				messageExchangePattern:=GRAA::ExchangePattern::message;
			};	
		};
	actionProvenance:=self.getStringValue('ActionProvenance');
	
	// derived
		isAsynchronous:=serviceOperations->exists(p|p.oclIsKindOf(UML::Reception));
		actionPurpose:=serviceOperations.ownedComment.body->asSequence()->first();
}
	mapping 	UML::InstanceSpecification::SampleData():GRAA::SampleData@graa 
{
	// Input, ExpectedOutput
	input+=self.getStringValues('Input');
	expectedOutput:=self.getStringValue('ExpectedOutput');
}	
helper 	UML::NamedElement::mapImplicitParameter(context:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter{
	// find instance which is WSDLParameter or Parameter
	// if none, check defaults
	// if none, do implicitOperation
	var resultOperation:GRAA::Parameter=null;
	/*
	// check for WSDLParameter
	self.realizingInstance('WSDLParameter')->forEach(wsdlParameter){
		return wsdlParameter.map AbstractParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check for Parameter
	self.realizingInstance('Parameter')->forEach(wsdlParameter){
		return wsdlParameter.map AbstractParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	*/
	/*
	// check operationDefaults
	parameterDefaults->forEach(operationDefault){
		return operationDefault.map AbstractParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	return self.map ImplicitParameter(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	*/
	// check parameterDefaults, if default realizes this parameter, map it
	parameterDefaults->select(p|p.realizedNamedElement()->exists(rp|self=rp))->forEach(operationDefault){
		return operationDefault.map AbstractParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// otherwise, try to map an unrealized default
	parameterDefaults->select(p|p.realizedNamedElement()->isEmpty())->forEach(operationDefault){
		return operationDefault.map AbstractParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// general defaults not supported - backtract
	// if we get this far, then there are no qualifying parameter instances, so we must create one implicitly
	return self.map ImplicitParameter(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	//return null;// failed
	
} 

	mapping 	UML::NamedElement::ImplicitParameter(context:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
//	var messagetype:UML::Type=null;
	var messagetype:UML::NamedElement=null;
	if(self.oclIsKindOf(UML::TypedElement))then{
		messagetype:=self.oclAsType(UML::TypedElement).type;		
	}endif;
	// either a type or an element, depending upon whether style is document or rpc
	if(context.isDocumentStyle())then{
		// use an element (property whose type is messagetype): either 
		var messagetypetest:UML::NamedElement=self.messagePartElement();
		if(not(messagetypetest.oclIsUndefined()))then{
			messagetype:=messagetypetest;
		}endif;
	}endif;
	if(self.oclIsKindOf(UML::Parameter))then{	
		//  derived
		switch{
			case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_out){
				use:=graAnnotationModel::ParameterUse::_out;
			};
			case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_inout){
				use:=graAnnotationModel::ParameterUse::_out;
			};
			case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_return){
				use:=graAnnotationModel::ParameterUse::_out;
			};
			else{
				use:=graAnnotationModel::ParameterUse::_in;
			};
		};
	}else{
		if(self.oclIsKindOf(UML::Type))then{	
			if(not(context.isDocumentStyle()))then{
				messagetype:=self.oclAsType(UML::Type);
			}endif;
			//  derived
			use:=graAnnotationModel::ParameterUse::_exception;
		}else{
			use:=graAnnotationModel::ParameterUse::_in;
		}endif;
	}endif;

	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=self.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=messagetype.name;
		}endif;
	}endif;
	message:=messagetype.mapImplicitMessage(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
}
query UML::BehavioralFeature::isDocumentStyle():Boolean{	
	// default is document style; check if override iva modeled instance Operation
	var isDocument:Boolean=true;
	self.realizingInstance('WSDLOperation')->forEach(operation){
		var operationKindCode:UML::InstanceSpecification=operation.getInstanceValue('OperationKindCode');
		if(not(operationKindCode.oclIsUndefined()))then{
			var kindName:String=operationKindCode.name;
			switch{
				case(kindName='rpc'){
					return false;
				};	
			};
		}endif;
	};
	return true;
}
query UML::NamedElement::messagePartElement():UML::Property{
	/*
	// context is a typedElement (or a Type in case of Exception)
		if(self.oclIsKindOf(UML::Type))then{	
			// exception; for now can not be resolved
		}else{
			// typedElement: resolve via realization or some exchange property holder
			if(self.oclIsKindOf(UML::TypedElement))then{	
				var modeledType:UML::Type=self.oclAsType(UML::TypedElement).type;
				modeledType.realizedTypedElement()
					->select(t|t.oclIsKindOf(UML::Property)).oclAsType(UML::Property)->forEach(typedElement){
						return typedElement;
					};
				// no realization, check if there is an exchange which defines such a property
				modeledType.getReferencingTypedElements()
					->select(t|t.oclIsKindOf(UML::Property)).oclAsType(UML::Property)->forEach(typedElement){
						return typedElement;
					};
				// otherwise just find any informationModel defining such a property	
			}else{
				// could not resolve
			}endif;
		}endif;
	return null;// could not resolve property
	*/
	return self.messagePartElements()->asSequence()->first();
}
query UML::NamedElement::messagePartElements():Set(UML::Property){
	// context is a typedElement (or a Type in case of Exception)
	var properties:Set(UML::Property)=Set{};
		if(self.oclIsKindOf(UML::Type))then{	
			// exception, find referencing property
				var modeledType:UML::Type=self.oclAsType(UML::Type);
				modeledType.realizedTypedElement()
					->select(t|t.oclIsKindOf(UML::Property)).oclAsType(UML::Property)->forEach(typedElement){
						properties+= typedElement;
					};
				// no realization, check if there is an exchange which defines such a property
				modeledType.getReferencingTypedElements()
					->select(t|t.oclIsKindOf(UML::Property)).oclAsType(UML::Property)->forEach(typedElement){
						properties+= typedElement;
					};
				// otherwise just find any informationModel defining such a property	
		}else{
			// typedElement: resolve via realization or some exchange property holder
			if(self.oclIsKindOf(UML::TypedElement))then{	
				var modeledType:UML::Type=self.oclAsType(UML::TypedElement).type;
				modeledType.realizedTypedElement()
					->select(t|t.oclIsKindOf(UML::Property)).oclAsType(UML::Property)->forEach(typedElement){
						properties+= typedElement;
					};
				// no realization, check if there is an exchange which defines such a property
				modeledType.getReferencingTypedElements()
					->select(t|t.oclIsKindOf(UML::Property)).oclAsType(UML::Property)->forEach(typedElement){
						properties+= typedElement;
					};
				// otherwise just find any informationModel defining such a property	
			}else{
				// could not resolve
			}endif;
		}endif;
	return properties;// could not resolve property
}

query UML::Type::getReferencingTypedElements():Set(UML::TypedElement)=
	gatherAllGraSchemas.ownedType->select(e|e.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier).attribute
		->select(a|a.type=self)->asSet();
		
		
mapping 	UML::InstanceSpecification::AbstractParameter(modeledMessage:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter@graa 
	disjuncts UML::InstanceSpecification::WSDLParameter,
		 UML::InstanceSpecification::Parameter
		 {}
mapping 	UML::InstanceSpecification::WSDLParameter(modeledMessage:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlParameter@graa 
	inherits UML::InstanceSpecification::Parameter
	when{self.classifier.name->asSet()->includes('WSDLParameter')}
{
	mimeType:=self.getStringValue('mimeType');

}
	mapping 	UML::InstanceSpecification::Parameter(modeledMessage:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{
	var messageRealized:UML::TypedElement= self.realizedTypedElement()->asSequence()->first();
	if(modeledMessage.oclIsUndefined())then{
		
	}else{
		if(modeledMessage.oclIsKindOf(UML::TypedElement))then{
			messageRealized:=modeledMessage.oclAsType(UML::TypedElement);
		}endif;
	}endif;
	messageRealized->forEach(parameter){
		//  derived
		if(parameter.oclIsKindOf(UML::Parameter))then{	
			switch{
				case(parameter.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_out){
					use:=graAnnotationModel::ParameterUse::_out;
				};
				case(parameter.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_inout){
					use:=graAnnotationModel::ParameterUse::_inout;
				};
				case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_return){
					use:=graAnnotationModel::ParameterUse::_out;
				};
				else{
					use:=graAnnotationModel::ParameterUse::_in;
				};
			};
		}else{
					use:=graAnnotationModel::ParameterUse::_in;
		}	endif;
	};
//	var messagetype:UML::Type=messageRealized.type;
	var messagetype:UML::NamedElement=messageRealized.type;
	// either a type or an element, depending upon whether style is document or rpc
	var test:UML::Element=modeledMessage.owner;
	if(test.oclIsKindOf(UML::BehavioralFeature))then{
		var behavioralFeature:UML::BehavioralFeature=test.oclAsType(UML::BehavioralFeature);
		if(behavioralFeature.isDocumentStyle())then{
			// use an element (property whose type is messagetype): either 
			messagetype:=behavioralFeature.messagePartElement();
		}endif;
	}endif;
	// exceptions
	var typeRealized:UML::Type= self.realizedType()->asSequence()->first();
	if(not(typeRealized.oclIsUndefined()))then{
		messagetype:=typeRealized;
		if(modeledMessage.oclIsUndefined())then{
			
		}else{
			if(modeledMessage.oclIsKindOf(UML::Type))then{
				messagetype:=modeledMessage.oclAsType(UML::Type);
			}endif;
		}endif;
		use:=graAnnotationModel::ParameterUse::_exception;
	}endif;
//	dataProvenance:=self.getStringValue('DataProvenance');
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=messageRealized.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=messagetype.name;
		}endif;
	}endif;
	var messageInstances:UML::InstanceSpecification= self.getInstanceValue('Message');
	if(messageInstances.oclIsUndefined())then{
		/*
		if(messageDefaults->notEmpty())then{
			message:=messageDefaults.map AbstractMessage(messagetype,messageRealized,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults)->first();
		}else{
			message:=messagetype.mapImplicitMessage(messageRealized,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
		}endif;
		*/
		var targetMessage:GRAA::Message=messagetype.mapImplicitMessage(messageRealized,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
		if(not(targetMessage.oclIsUndefined()))then{
			message:=targetMessage;
		}endif;
		
	}else{
		message:=messageInstances.map AbstractMessage(messagetype,messageRealized,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	}endif;
	
	
	
}	

///////////////////////////////////////////////////////////////////////////////////////////////////	
//helper 	UML::Type::mapImplicitMessage(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
helper 	UML::NamedElement::mapImplicitMessage(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message{
	// find instance which is WSDLOperation or Operation
	// if none, check defaults
	// if none, do implicitOperation
	var resultOperation:GRAA::Message=null;
	/*
	// check for WSDLOperation
	self.realizingInstance('WSDLMessage')->forEach(wsdlMessage){
		return wsdlMessage.map AbstractMessage(self,context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// check for Operation
	self.realizingInstance('Message')->forEach(wsdlMessage){
		return wsdlMessage.map AbstractMessage(self,context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	*/
	/*
	// check operationDefaults
	messageDefaults->forEach(wsdlMessage){
		return wsdlMessage.map AbstractMessage(self,context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	return self.map ImplicitMessage(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	*/
	// check InterfaceDefaults, if default realizes this port, map it
//	messageDefaults->select(p|p.realizedType()->exists(rp|self=rp))->forEach(wsdlMessage){
	messageDefaults->select(p|p.realizedNamedElement()->exists(rp|self=rp))->forEach(wsdlMessage){
		return wsdlMessage.map AbstractMessage(self,context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// otherwise, try to map an unrealized default
//	messageDefaults->select(p|p.realizedType()->isEmpty())->forEach(wsdlMessage){
	messageDefaults->select(p|p.realizedNamedElement()->isEmpty())->forEach(wsdlMessage){
		return wsdlMessage.map AbstractMessage(self,context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// general defaults not supported - backtrack
	// if we get this far, then no qualifying message instance in model, so we must implicitly create one

	// we either use type or element, depending upon context;  if we need element backtrack via context

	return self.map ImplicitMessage(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	//return null;// failed
	
} 

//	mapping 	UML::Type::ImplicitMessage(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
mapping 	UML::NamedElement::ImplicitMessage(context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
//	var messagetype:UML::Type=self;
	var messagetype:UML::NamedElement=self;
	var typePackage:UML::Package=messagetype.getNearestPackage();
	var pimStereotypeInstance:Stdlib::Element=typePackage.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=typePackage.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
	// set prefix to be used for Schema namespace
	prefix:=pimStereotypeInstance.getSsspSchemaDefaultPrefix();
	if(result.prefix.oclIsUndefined()or (result.prefix=''))then{
		prefix:='prefix';
	}endif;
//	name:=messagetype.name;
		name:=messagetype.toNiemName();
}
	
//mapping 	UML::InstanceSpecification::AbstractMessage(modeledMessage:UML::Type,context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
mapping 	UML::InstanceSpecification::AbstractMessage(modeledMessage:UML::NamedElement,context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message@graa 
	disjuncts UML::InstanceSpecification::WSDLMessage,
		 UML::InstanceSpecification::Message
		 {}
//mapping 	UML::InstanceSpecification::WSDLMessage(modeledMessage:UML::Type,context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
mapping 	UML::InstanceSpecification::WSDLMessage(modeledMessage:UML::NamedElement,context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlMessage@graa 
	inherits UML::InstanceSpecification::Message
	when{self.classifier.name->asSet()->includes('WSDLMessage')}
{
		var locationCodeName:String=self.getInstanceValue('MessageLocationCode').name;
		switch{
			case(locationCodeName='body'){
				messageLocationCode:=GRAW::MessageLocation::body;
			};	
			case(locationCodeName='header'){
				messageLocationCode:=GRAW::MessageLocation::header;
			};	
			case(locationCodeName='url'){
				messageLocationCode:=GRAW::MessageLocation::url;
			};	
		};
	encoding:=self.getStringValue('Encoding');
	soapAction:=self.getStringValue('SoapAction');

}
//mapping 	UML::InstanceSpecification::Message(modeledMessage:UML::Type,context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
mapping 	UML::InstanceSpecification::Message(modeledMessage:UML::NamedElement,context:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefaultContext 
{
//	var messageRealized:UML::Type= self.realizedType()->asSequence()->first();
	var messageRealized:UML::NamedElement= self.realizedNamedElement()->asSequence()->first();
	if(modeledMessage.oclIsUndefined())then{
		
	}else{
		messageRealized:=modeledMessage;
	}endif;
//	var messagetype:UML::Type=messageRealized;
	var messagetype:UML::NamedElement=messageRealized;
	var typePackage:UML::Package=messagetype.getNearestPackage();
	var pimStereotypeInstance:Stdlib::Element=typePackage.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=typePackage.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
	// set prefix to be used for Schema namespace
	prefix:=pimStereotypeInstance.getSsspSchemaDefaultPrefix();
	if(result.prefix.oclIsUndefined()or (result.prefix=''))then{
		prefix:='prefix';
	}endif;
//		name:=messageRealized.name;
		name:=messageRealized.toNiemName();
}	

query UML::NamedElement::toNiemName():String{
	var resultName:String=self.name;
	if(resultName.oclIsUndefined())then{
		resultName:='unNamed';
	}endif;
	return resultName;
}
	
query UML::Type::toNiemName():String{
	var resultName:String=self.name;
	if(self.isMetadataType() and not(resultName.endsWith('MetadataType')or resultName.endsWith('Metadata')))then{
		resultName:=resultName+'MetadataType';
	}endif;
	if(self.isNiemType() and not(resultName.endsWith('Type')))then{
		resultName:=resultName+'Type';
	}endif;
	return resultName;
}
query UML::Type::isNiemType():Boolean{
	var typePackage:UML::Package=self.getNearestPackage();
	return not(typePackage.GetStereotypeApplication(NIEMSchemaStereotype).oclIsUndefined())
		or not(typePackage.GetStereotypeApplication(NIEMInformationModelStereotype).oclIsUndefined());
}
query UML::Type::isMetadataType():Boolean{
	return not(self.GetStereotypeApplication(NIEMMetadataStereotype).oclIsUndefined())
		or (self.name.endsWith('MetadataType')or self.name.endsWith('Metadata'));
}
	mapping 	UML::InstanceSpecification::ServiceInteractionProfile():GRAA::ServiceInteractionProfile@graa 
{
	sipName:=self.getStringValue('SIPName');
	sipVersion:=self.getStringValue('SIPVersion');
}	
	mapping 	UML::InstanceSpecification::Agreement():GRAA::Agreement@graa 
{
	agreementUri:=self.getStringValue('AgreementURI');
	automatedAgreementIndicator:=self.getBooleanValue('AutomatedAgreementIndicator');
	documentation:=self.ownedComment.body->asSequence()->first();
}	
	