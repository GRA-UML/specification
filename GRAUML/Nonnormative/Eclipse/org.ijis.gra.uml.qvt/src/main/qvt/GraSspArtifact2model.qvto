// TODO: import from org.search.niem.uml.qvt.NIEMplatformBinding; remove local copy
//  but it was not exported, may need an OSGi fragment to recover it
//	but it also was changed from omg version and does not work so well
//import org.search.niem.uml.qvt.NIEMplatformBinding;
import GRAcommon;
import NIEMmpdartifact2model;
import GraWsdl2soaml;
//modeltype UML uses 'http://www.omg.org/spec/UML/20110701';
modeltype UML uses 'http://www.eclipse.org/uml2/4.0.0/UML';
modeltype XSD  uses 'http://www.eclipse.org/xsd/2002/XSD';
modeltype SPPCAT  uses 'http://gra.ijis.org/catalog/1.0.0';
modeltype METADATA  uses 'http://it.ojp.gov/gsp/services/1.0.0';

modeltype EBXML uses 'http://www.ebxml.org/BusinessProcess';// no current models use this
modeltype XMLDSIG uses 'http://www.w3.org/2000/09/xmldsig#';// this is used
modeltype WSDL uses 'http://www.eclipse.org/wsdl/2003/WSDL';// TODO: change to http://schemas.xmlsoap.org/wsdl/
modeltype BPMN2 uses 'http://www.omg.org/spec/BPMN/20100524/MODEL-XMI';// no current models use this

modeltype CMOF  uses 'http://www.eclipse.org/emf/2002/Ecore';

modeltype CAT  uses 'http://reference.niem.gov/niem/resource/mpd/catalog/1.0/';

// TODO:
//modeltype CHANGELOG  uses '???????????????';
/*
modeltype WSDL_HTTP uses 'http://schemas.xmlsoap.org/wsdl/http/';// used in wsdl
modeltype WSDL_MIME uses 'http://schemas.xmlsoap.org/wsdl/mime/';// used in policy wsdl
modeltype WSDL_SOAP uses 'http://schemas.xmlsoap.org/wsdl/soap/';// used in wsdl
modeltype SOAP12 uses 'http://schemas.xmlsoap.org/wsdl/soap12/';// used in wsdl

modeltype SOAP_ENV uses 'http://schemas.xmlsoap.org/soap/envelope/';// this is used in SOAP instance documents and xsd
modeltype SOAP_ENC uses 'http://schemas.xmlsoap.org/soap/encoding/';// this is used in SOAP instance documents and wsdl
modeltype WSRM uses 'http://docs.oasis-open.org/ws-rx/wsrm/200608';// this is used in SOAP instance documents
modeltype WSRM2 uses 'http://schemas.xmlsoap.org/ws/2005/02/rm/policy';// this is used in SOAP instance documents
modeltype WSA uses 'http://www.w3.org/2005/08/addressing';// used in SOAP instance docs, wsdl
modeltype WSAW uses 'http://www.w3.org/2006/05/addressing/wsdl';// used in SOAP instance docs, wsdl
modeltype WSAM uses 'http://www.w3.org/2007/05/addressing/metadata';// used in SOAP instance docs, wsdl
modeltype WSU uses 'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd';// used in SOAP instance docs, wsdl
modeltype WSP uses 'http://schemas.xmlsoap.org/ws/2004/09/policy';// used in SOAP instance docs, wsdl
modeltype SP uses 'http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702';// used in SOAP instance docs, wsdl
modeltype WSX uses 'http://schemas.xmlsoap.org/ws/2004/09/mex';// used in wsdl


//modeltype EBXML uses 'http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/'; // used in xsd, instance docs
//modeltype EBXML uses 'http://www.oasis-open.org/committees/ebxml-msg/schema/msg-header-2_0.xsd';// used in xsd
//modeltype EBXML uses 'http://www.ebxml.org/namespaces/tradePartner';// not used

modeltype BPMN uses 'http://stp.eclipse.org/bpmn';// some ssp references this?
*/
//vii.	WSDL (Added per questions)
//viii.	BPM XMI (Added per questions)
//ix.	Service Change Log (Added per questions) ????????
//x.	ebXML XSD (Added per questions)

// start with gra catalog, a possibly empty uml model with a root model element 
// the gra catalog may need to be externally fabricated;  some ssp do not have any catalog
// some ssp do not have Metadata.xml
// the iepds often do not have a catalog, that may need to be fabricated
// are the schemas under schema an exact duplicate of those under artifacts?
// it may be better to drive collection of schemas from the wsdls
transformation GraSspArtifact2model (in cat:SPPCAT, inout pimUml:UML)
	//extends transformation NIEMmpdartifact2model(inout UML)
	extends transformation GraWsdl2soaml(inout UML)
	;
main() {
	GraSspArtifact2model_run();
}	
property sppCatalog:SPPCAT::CatalogType1=null;
//property sppDocumentRoot:SPPCAT::DocumentRoot=null;
property graRoot:UML::Model=null;
property serviceSpecificationInstancePackage:UML::Package=null;
	
helper GraSspArtifact2model_run() {
	
	var documentRoot:SPPCAT::DocumentRoot = cat.rootObjects()
            ->select(r|r.oclIsKindOf(SPPCAT::DocumentRoot)).oclAsType(SPPCAT::DocumentRoot)
            ->asSequence()->first();
    log('GRA Document root '+documentRoot.repr());    
	sppCatalog:=documentRoot.catalog->asSequence()->first();
    log('GRA catalog '+sppCatalog.repr());    
	
	graRoot:=
			pimUml.rootObjects()
			->select(r|r.oclIsKindOf(UML::Model)).oclAsType(UML::Model)
			->asSequence()->first();
    log('GRA uml model root '+graRoot.repr());    

	graRoot.initializeProfileGlobals();	
	graRoot.initializeSppProfileGlobals();
	var annotationModel:UML::Package=graRoot.getGRAAnnotationPackage();
    log('GRA annotationModel '+annotationModel.repr());    
	
//	graProfile.nestingPackage.initializeGraClassifiers();
	annotationModel.initializeGraClassifiers();
	sppCatalog.map CatalogType1();
	//  get metadata and other artifacts during Catalog processing
	//  fully expand wsdl content
	//  in the process, pick up the iepd schemas
	return;
	}
helper UML::Package::initializeGraClassifiers(){
	self.nestedPackage->select(p|p.name='GRA_WSDL').initializeGraWsdlClassifiers();
	self.nestedPackage->select(p|p.name='GRAAnnotationModel').initializeGraAnnotationModelClassifiers();
	return;
}
property WSDLInterfaceClassifier:UML::Class=null;
property WSDLMessageClassifier:UML::Class=null;
property WSDLOperationClassifier:UML::Class=null;
property WSDLPortClassifier:UML::Class=null;
property WSDLServiceClassifier:UML::Class=null;
property WSDLServiceInterfaceClassifier:UML::Class=null;
property BindingTypeClassifier:UML::Enumeration=null;
property MessageLocationClassifier:UML::Enumeration=null;
property OperationKindClassifier:UML::Enumeration=null;

property AgreementClassifier:UML::Class=null;
property AmountTypeClassifier:UML::Class=null;
property DescriptionClassifier:UML::Class=null;
property EntityTypeClassifier:UML::Class=null;
property IEPDReferenceClassifier:UML::Class=null;
property InteractionRequirementsClassifier:UML::Class=null;

property InterfaceClassifier:UML::Class=null;
property MessageClassifier:UML::Class=null;
property ModelClassifier:UML::Class=null;
property ModelReferenceClassifier:UML::Class=null;
property OperationClassifier:UML::Class=null;
property OrganizationClassifier:UML::Class=null;
property ParticipantClassifier:UML::Class=null;
property PersonClassifier:UML::Class=null;
property PortClassifier:UML::Class=null;
property SecurityClassificationClassifier:UML::Class=null;
property ServiceClassifier:UML::Class=null;
property ServiceCapabilityClassifier:UML::Class=null;
property ServiceDescriptionClassifier:UML::Class=null;
property ServiceIdentificationClassifier:UML::Class=null;
property ServiceInteractionClassifier:UML::Class=null;
property ServiceInteractionProfileClassifier:UML::Class=null;
property ServiceInterfaceSpecificationClassifier:UML::Class=null;
property ServiceLevelAgreementClassifier:UML::Class=null;
//property URIDetailClassifier:UML::Class=null;
property UseCaseClassifier:UML::Class=null;
//property VersionInformationClassifier:UML::Class=null;
property ExchangePatternClassifier:UML::Enumeration=null;
property MessageUseClassifier:UML::Enumeration=null;
property SummaryTextTypeClassifier:UML::PrimitiveType=null;


helper UML::Package::initializeGraWsdlClassifiers(){
	self.ownedType.oclAsType(UML::Classifier)->forEach(classifier){
		switch{
			case(classifier.name='WSDLInterface'){
				WSDLInterfaceClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='WSDLMessage'){
				WSDLMessageClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='WSDLOperation'){
				WSDLOperationClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='WSDLPort'){
				WSDLPortClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='WSDLService'){
				WSDLServiceClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='WSDLServiceInterface'){
				WSDLServiceInterfaceClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='BindingType'){
				BindingTypeClassifier:=classifier.oclAsType(UML::Enumeration);
			};
			case(classifier.name='MessageLocation'){
				MessageLocationClassifier:=classifier.oclAsType(UML::Enumeration);
			};
			case(classifier.name='OperationKind'){
				OperationKindClassifier:=classifier.oclAsType(UML::Enumeration);
			};
		};
	};
	return;
}
helper UML::Package::initializeGraAnnotationModelClassifiers(){
	self.ownedType.oclAsType(UML::Classifier)->forEach(classifier){
		switch{
			case(classifier.name='Agreement'){
				AgreementClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='AmountType'){
				AmountTypeClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='Description'){
				DescriptionClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='EntityType'){
				EntityTypeClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='IEPDReference'){
				IEPDReferenceClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='InteractionRequirements'){
				InteractionRequirementsClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='Interface'){
				InterfaceClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='Message'){
				MessageClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='Model'){
				ModelClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='ModelReference'){
				ModelReferenceClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='Operation'){
				OperationClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='Organization'){
				OrganizationClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='Participant'){
				ParticipantClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='Person'){
				PersonClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='Port'){
				PortClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='SecurityClassification'){
				SecurityClassificationClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='Service'){
				ServiceClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='ServiceCapability'){
				ServiceCapabilityClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='ServiceDescription'){
				ServiceDescriptionClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='ServiceIdentification'){
				ServiceIdentificationClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='ServiceInteraction'){
				ServiceInteractionClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='ServiceInteractionProfile'){
				ServiceInteractionProfileClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='ServiceInterfaceSpecification'){
				ServiceInterfaceSpecificationClassifier:=classifier.oclAsType(UML::Class);
			};
			case(classifier.name='ServiceLevelAgreement'){
				ServiceLevelAgreementClassifier:=classifier.oclAsType(UML::Class);
			};
			/*
			case(classifier.name='URIDetail'){
				URIDetailClassifier:=classifier.oclAsType(UML::Class);
			};
			*/
			case(classifier.name='UseCase'){
				UseCaseClassifier:=classifier.oclAsType(UML::Class);
			};
			/*
			case(classifier.name='VersionInformation'){
				VersionInformationClassifier:=classifier.oclAsType(UML::Class);
			};
			*/
			case(classifier.name='ExchangePattern'){
				ExchangePatternClassifier:=classifier.oclAsType(UML::Enumeration);
			};
			case(classifier.name='MessageUse'){
				MessageUseClassifier:=classifier.oclAsType(UML::Enumeration);
			};
			case(classifier.name='SummaryTextType'){
				SummaryTextTypeClassifier:=classifier.oclAsType(UML::PrimitiveType);
			};
		};
	};
	return;
}
/////////////////////////////////////////////////catalog mappings
// represents the ssp model as a whole, all elements will be contained in the model
// within the model, it is also a servicesArchitecture
mapping 	SPPCAT::CatalogType1::CatalogType1():UML::Model@pimUml
{
	graRoot.packagedElement+=result;
	sppRootPackage:=result;
	// name this according to containing folder; i.e., the next to last segment of extent
	name:=self.oclAsType(Stdlib::Element).extentParentSegment();
	result.applyProfile(logicalProfile);
	result.applyProfile(provisioningProfile);
	result.applyProfile(structureProfile);
	result.applyProfile(niemXsdProfile);
	//  add the GRA profiles, including SoaML, etc.
	//log("soamlProfile "+soamlProfile.qualifiedName);
	//log("wsdlProfile "+wsdlProfile.qualifiedName);
	//log("graProfile "+graProfile.qualifiedName);
	//result.applyProfile(soamlProfile);
	//result.applyProfile(wsdlProfile);
	result.applyProfile(graProfile);

	self.map SppCatalog_ProvisioningComponent(result);
	
}
property suppressGRA:Boolean=false;// catalog schemas are different?
mapping 	SPPCAT::CatalogType1::SppCatalog_ProvisioningComponent(
	inout newPackage:UML::Package):UML::Collaboration@pimUml{
	
	
	newPackage.packagedElement+=result;
	sppArchitecture:=result;
	name:=newPackage.name;
	// process all content
	// create the items, establish containment, set stereotypes and apply tags discretely
	//log('soamlServicesArchitectureStereotype '+soamlServicesArchitectureStereotype.repr());
	//result.applyStereotype(soamlServicesArchitectureStereotype);
	// catalog implicit
	// metadata : combine-in
	// service-description implicit
	// 	service-interface-description implicit from wsdl-schema
	//  wsdl-schema : similar to NIEM FileType
	//  soap-sample : similar to NIEM FileType
	// iepd-catalog : similar to NIEM FileType
//	self.wsdlSchema.map WsdlSchemaType(sppArchitecture);// switch order for debug
	// do metadata now to possible create some of the elements used during wsdl artifact creation
	self.map ServiceSpecificationPackage(newPackage);
}
mapping 	SPPCAT::CatalogType1::ServiceSpecificationPackage(
	inout newPackage:UML::Package):UML::Package@pimUml{
	
	serviceSpecificationInstancePackage:=result;
	newPackage.packagedElement+=result;
	name:='Service Specification';
	// do metadata now to possible create some of the elements used during wsdl artifact creation
	self.ServiceSpecificationInstance(result);
}
mapping 	SPPCAT::CatalogType1::ServiceSpecificationInstance(
	inout serviceSpecificationPackage:UML::Package):UML::InstanceSpecification@pimUml{
	
	serviceSpecificationPackage.packagedElement+=result;
	result.map Realization(sppArchitecture);
	name:='ServiceDescription';
	classifier+=ServiceDescriptionClassifier;
	// do metadata now to possible create some of the elements used during wsdl artifact creation
//	self.metadata.metadata(result,sppArchitecture);// moved down
	log('start SoapSample');
	self.soapSample.map SoapSampleType(sppArchitecture);
	log('start IEPD catalog');
	self.iepdCatalog.map IepdCatalogType(sppArchitecture);
	var saveMpdRootPackage:UML::Package=mpdRootPackage;
	mpdRootPackage:=sppRootPackage;
	self.metadata.metadata(result,sppArchitecture);
	// picked up during metadata
//	log('start WSDL');
	// wsdlschemaType no longer used
//	self.wsdlSchema.map WsdlSchemaType(sppArchitecture);// switch order for debug
	mpdRootPackage:=saveMpdRootPackage;
	log('SPP catalog complete');
}

// adjust href, if necessary, to be relative to spp package
query String::toRelativeSppLocation():String{
	var location:String=self;
	if(location.startsWith('./'))then {location:=location.substringAfter('./');} else {} endif;
	if(location.endsWith('/'))then {location:=location.substring(1,location.size()-1);} else {} endif;
	// path may have forward or back slashes, change these to '::'
	location:=location.replaceAll('/','::').replaceAll('\\\\','::');
	return location;
};
helper String::getSppOwnerPackage(inout topPackage:UML::Package):UML::Package{
	var topPackageName:String=self.substringBefore('::');
	//log('getSppOwnerPackage '+self+', '+topPackage.repr());
	if(topPackageName.oclIsUndefined())then{return topPackage;}endif;
	topPackage.nestedPackage->select(p|p.name=topPackageName)->forEach(existingPackage){
		return self.substringAfter('::').getSppOwnerPackage(existingPackage);
	};
	var newPackage:UML::Package=new UML::Package@pimUml();
	newPackage.name:=topPackageName;
	topPackage.packagedElement+=newPackage;
	return self.substringAfter('::').getSppOwnerPackage(newPackage);
}


query String::toSppBaseName():String{
	var index:Integer=self.rfind('::');
	if(index>0)then{return self.substring(index+2,self.size());}else{}endif;
	return self;
};

////////////////////////////////////////////metadata

//helper 	SPPCAT::MetadataType::metadata(inout spp:Stdlib::Element,inout serviceSubject:UML::Collaboration)
helper 	SPPCAT::MetadataType::metadata(inout spp:UML::InstanceSpecification,inout serviceSubject:UML::Collaboration)
{
	// get the metadata and put into component
		var metadata:METADATA::DocumentRoot=self.oclAsType(Stdlib::Element).getMetadataAtRelativeURI(self.href).oclAsType(METADATA::DocumentRoot);
		//log('getMetadataAt '+self.href+' = '+metadata.repr());
		if(not(metadata.oclIsUndefined()))then{
			// and map it as metadata into the component
			var serviceMetadata:METADATA::ServiceMetadataType=metadata.serviceMetadata->asSequence()->first();
			// serviceIdentification becomes a participant component and a role of the services architecture 
			// but there is only one, and it is more like a services architecture, so why not fold those properties into the Collaboration
			//  but the serviceInterface should be a soaml serviceInterface, and should be type of some port
			//  so where would the participants be in that case?
			//  we do not know how many participants there are from metadata, nor the direction of actions??
			//  nor relationship with wsdl
			
			// or should all of this service metadata be a serviceInterface?
			//  then the GRA serviceInterface is one of the interfaces provided by/used by the GRA service
			//  serviceDependencies? they should also be a serviceInterface, but how to relate?
			//     ?????
			 
			// or should all of this service metadata be a participant?
			//  then the GRA serviceInterface could be one of the port->serviceInterfaces of the GRA service
			//     or there may be a single port, and a GRA serviceInterface is an interface of the SoaML ServiceInterface
			//  serviceDependencies? these are more like the architecture realizing a participant,
			//   in which case a ServiceIdentificationType is a participant
			
			////////////////////try this:
			// or this is a servicesArchitecture which has a special participant with a special port typed by a serviceInterface
			//  there is implicitly a partner participant and a contract between them
			//  serviceDependencies are additional participants (shared aggregation)
			//  capabilities are realized by the participant and in turn realize the respective serviceInterface
			//  serviceLevelAgreement are part of serviceContract between this participant and its partner 
 
			
//			var primaryServiceParticipant:UML::Component=serviceMetadata.serviceIdentification.map ServiceIdentificationType(serviceSubject,true);
//			var primaryServiceParticipant:UML::Component=serviceMetadata.serviceIdentification.map ServiceIdentificationType(spp,serviceSubject,true);
//			var primaryServiceInterface:UML::Class=primaryServiceParticipant.primaryServiceInterface();
			
			serviceMetadata.serviceDescription->forEach(serviceDescription){
			/*
				serviceDescription.servicePurposeText.setTagValue(spp,'servicePurposeText');
				serviceDescription.serviceScopeDescriptionText.setTagValue(spp,'serviceScopeDescriptionText');
				serviceDescription.serviceDescriptionSummaryText.repr().setTagValue(spp,'serviceDescriptionSummaryText');
				serviceDescription.serviceDescriptionText.setTagValue(spp,'serviceDescriptionText');
				serviceDescription.serviceDescriptionKeywordText.addTagValue(spp,'serviceDescriptionKeywordText');
				
				serviceDescription.serviceCapabilities.capabilityDescriptionText.map CapabilityDescriptionText(primaryServiceParticipant,
					primaryServiceInterface);
				serviceDescription.serviceRealWorldEffects.realWorldEffectDescriptionText.addTagValue(spp,'realWorldEffectDescriptionText');
				serviceDescription.securityClassificationText.setTagValue(spp,'securityClassificationText');
				serviceDescription.serviceDependencies.serviceDependency.map ServiceIdentificationType(serviceSubject,false);
				// assume indexes align and no significance to grouping
				serviceDescription.iEPDReferences.iEPDReference->forEach(iEPDReference){
					iEPDReference.iEPDName.addTagValue(spp,'iEPDName');
					iEPDReference.iEPDURL.addTagValue(spp,'iEPDURL');
				};	
				*/
				serviceDescription.servicePurposeText.setDescriptionValue(spp,'ServicePurpose');
				serviceDescription.serviceScopeDescriptionText.setDescriptionValue(spp,'ServiceScopeDescription');
				serviceDescription.serviceDescriptionSummaryText.repr().setFeatureValue(spp,'ServiceDescriptionSummaryText');
				serviceDescription.serviceDescriptionText.setDescriptionValue(spp,'ServiceDescription');
				serviceDescription.serviceDescriptionKeywordText.setFeatureValue(spp,'ServiceDescriptionKeywordText');
				
//				serviceDescription.serviceCapabilities.capabilityDescriptionText.map CapabilityDescriptionText(spp,primaryServiceParticipant,
//					primaryServiceInterface);
				serviceDescription.serviceCapabilities.capabilityDescriptionText.map CapabilityDescriptionText(spp);
				serviceDescription.serviceRealWorldEffects.realWorldEffectDescriptionText.addRealWorldEffectValue(spp,'RealWorldEffect');
//				serviceDescription.securityClassificationText.setFeatureValue(spp,'SecurityClassification');
				serviceDescription.securityClassificationText.map SecurityClassification(spp);
	//			serviceDescription.serviceDependencies.serviceDependency.map ServiceIdentificationType(serviceSubject,false);
//				serviceDescription.serviceDependencies.serviceDependency.map ServiceIdentificationType(spp,serviceSubject,false);
				serviceDescription.serviceDependencies.serviceDependency.map ServiceIdentificationType(spp,serviceSubject);
				
				// assume indexes align and no significance to grouping
				serviceDescription.iEPDReferences.iEPDReference->forEach(iEPDReference){
//					iEPDReference.iEPDName.addFeatureValue(spp,'iEPDName');
//					iEPDReference.iEPDURL.addFeatureValue(spp,'iEPDURL');
					addIEPDReferenceValue(spp,iEPDReference.iEPDName,iEPDReference.iEPDURL);
				};	
			};	
			serviceMetadata.versionInformation->forEach(versionInformation){
				versionInformation.majorVersion.setFeatureValue(spp,'MajorVersion');
				versionInformation.minorVersion.setFeatureValue(spp,'MinorVersion');
				versionInformation.revisionVersion.setFeatureValue(spp,'RevisionVersion');
				versionInformation.creationDate.repr().setFeatureValue(spp,'CreationDate');
				versionInformation.activationDate.repr().setFeatureValue(spp,'ActivationDate');
				versionInformation.lastRevisionDate.repr().setFeatureValue(spp,'LastRevisionDate');
				versionInformation.nextRevisionDate.repr().setFeatureValue(spp,'NextRevisionDate');
				versionInformation.expirationDate.repr().setFeatureValue(spp,'ExpirationDate');
				versionInformation.lifecycleStatus.setFeatureValue(spp,'LifecycleStatus');
				versionInformation.alertsAndNotifications.repr().addFeatureValue(spp,'AlertsAndNotification');
				/*
				var versionInformationInstance:UML::InstanceSpecification='Version'.addVersionInformation(spp);			
				versionInformation.majorVersion.setFeatureValue(versionInformationInstance,'majorVersion');
				versionInformation.minorVersion.setFeatureValue(versionInformationInstance,'minorVersion');
				versionInformation.revisionVersion.setFeatureValue(versionInformationInstance,'revisionVersion');
				versionInformation.creationDate.repr().setFeatureValue(versionInformationInstance,'creationDate');
				versionInformation.activationDate.repr().setFeatureValue(versionInformationInstance,'activationDate');
				versionInformation.lastRevisionDate.repr().setFeatureValue(versionInformationInstance,'lastRevisionDate');
				versionInformation.nextRevisionDate.repr().setFeatureValue(versionInformationInstance,'nextRevisionDate');
				versionInformation.expirationDate.repr().setFeatureValue(versionInformationInstance,'expirationDate');
				versionInformation.lifecycleStatus.setFeatureValue(versionInformationInstance,'lifecycleStatus');
				versionInformation.alertsAndNotifications.repr().addFeatureValue(versionInformationInstance,'alertsAndNotification');
				*/
			};	
//			var partnerServiceParticipant:UML::Component=serviceMetadata.businessContext.map BusinessContextType(serviceSubject);
			var partnerServiceParticipant:UML::InstanceSpecification=serviceMetadata.businessContext.map BusinessContextType(spp);
//			serviceMetadata.serviceInterface.map ServiceInterfaceSpecificationType(spp,primaryServiceParticipant,primaryServiceInterface);
			serviceMetadata.serviceInterface.map ServiceInterfaceSpecificationType(spp);
			serviceMetadata.serviceLevelAgreements.map ServiceLevelAgreementsType(spp,
				serviceSubject
//				,primaryServiceParticipant,partnerServiceParticipant
				);
//			serviceMetadata.relatedOrganizationInformation.map RelatedOrganizationInformationType(serviceSubject);
//			serviceMetadata.relatedOrganizationInformation.map RelatedOrganizationInformationType(spp);
			serviceMetadata.relatedOrganizationInformation.organization.map RelatedOrganizationInformationType(spp);
		}endif;
		log('metadata complete ');
	return;
}
/*
helper String::addVersionInformation(inout spp:UML::InstanceSpecification):UML::InstanceSpecification{
	var slot:UML::Slot=self.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	var description:UML::InstanceSpecification=new UML::InstanceSpecification(spp,VersionInformationClassifier);
	spp.getNearestPackage().packagedElement+=description;
	instanceValue.instance:=description;
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance(self,spp,description);
		};
	return description;		
	
}
*/
helper String::addInstanceAssociation(inout spp:UML::InstanceSpecification,classifier:UML::Classifier):UML::InstanceSpecification{
	var slot:UML::Slot=self.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	var description:UML::InstanceSpecification=new UML::InstanceSpecification(spp,classifier);
	spp.getNearestPackage().packagedElement+=description;
	instanceValue.instance:=description;
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance(self,spp,description);
		};
	return description;		
	
}
mapping UML::Association::AssociationInstance(featureName:String,inout source:UML::InstanceSpecification,inout target:UML::InstanceSpecification):UML::InstanceSpecification@pimUml
{
	source.getNearestPackage().packagedElement+=result;
	classifier+=self;
	var featureslot:UML::Slot=featureName.getSlot(result);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	featureslot.value+=instanceValue;
	instanceValue.instance:=target;
	// hidden inverse
	self.ownedEnd->forEach(ownedEnd){
		var inverseslot:UML::Slot=new UML::Slot();
		slot+=inverseslot;
		inverseslot.definingFeature:=ownedEnd;
		var inverseinstanceValue:UML::InstanceValue=new UML::InstanceValue();
		inverseslot.value+=inverseinstanceValue;
		inverseinstanceValue.instance:=source;
		
	};
}
helper String::addFeatureValue(inout spp:UML::InstanceSpecification,featureName:String){
	self.setFeatureValue(spp,featureName);
	return;
}
helper String::setFeatureValue(inout spp:UML::InstanceSpecification,featureName:String){
	var slot:UML::Slot=featureName.getSlot(spp);
	var instanceValue:UML::LiteralString=new UML::LiteralString();
	instanceValue.value:=self;
	slot.value+=instanceValue;
	return;
}
helper Integer::setFeatureValue(inout spp:UML::InstanceSpecification,featureName:String){
	var slot:UML::Slot=featureName.getSlot(spp);
	var instanceValue:UML::LiteralInteger=new UML::LiteralInteger();
	instanceValue.value:=self;
	slot.value+=instanceValue;
	return;
}
helper Real::setFeatureValue(inout spp:UML::InstanceSpecification,featureName:String){
	var slot:UML::Slot=featureName.getSlot(spp);
	var instanceValue:UML::LiteralReal=new UML::LiteralReal();
	instanceValue.value:=self;
	slot.value+=instanceValue;
	return;
}
helper Boolean::setFeatureValue(inout spp:UML::InstanceSpecification,featureName:String){
	var slot:UML::Slot=featureName.getSlot(spp);
	var instanceValue:UML::LiteralBoolean=new UML::LiteralBoolean();
	instanceValue.value:=self;
	slot.value+=instanceValue;
	return;
}
helper String::addRealWorldEffectValue(inout spp:UML::InstanceSpecification,featureName:String){
	// TODO change from implicit to realized
	var slot:UML::Slot=featureName.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	var description:UML::InstanceSpecification=new UML::InstanceSpecification(spp,UseCaseClassifier);
	spp.getNearestPackage().packagedElement+=description;
	instanceValue.instance:=description;
	self.setFeatureValue(description,'RealWorldEffectDescriptionText');
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance(featureName,spp,description);
		};
	return;
}
helper addIEPDReferenceValue(inout spp:UML::InstanceSpecification,names:Sequence(String),urls:Sequence(String)){

	var slot:UML::Slot='IEPDReference'.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	var description:UML::InstanceSpecification=new UML::InstanceSpecification(spp,IEPDReferenceClassifier);
	spp.getNearestPackage().packagedElement+=description;
	instanceValue.instance:=description;
	names.addFeatureValue(description,'IEPDName');
	urls.addFeatureValue(description,'IEPDURL');
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('IEPDReference',spp,description);
		};
	return;
}
constructor UML::InstanceSpecification::InstanceSpecification(inout spp:UML::InstanceSpecification,classifierIn:UML::Classifier){
	//var description:UML::InstanceSpecification=new UML::InstanceSpecification();
	classifier+=classifierIn;
//	spp.getNearestPackage().packagedElement+=description;
	spp.getNearestPackage().packagedElement+=result;
	
}
helper String::getSlot(inout spp:UML::InstanceSpecification):UML::Slot{
	spp.slot->forEach(slot){
		if(slot.definingFeature.name=self)then{return slot;}endif;
	};
	var slot:UML::Slot=new UML::Slot();
	slot.definingFeature:=self.getDefiningFeature(spp);
	spp.slot+=slot;
	return slot;
}
helper String::getDefiningFeature(inout spp:UML::InstanceSpecification):UML::StructuralFeature{
	spp.classifier.getAllAttributes()->forEach(attribute){
		if(attribute.name=self)then{return attribute;}endif;
	};
	return null;
}
helper String::setDescriptionValue(inout spp:UML::InstanceSpecification,featureName:String){
	var slot:UML::Slot=featureName.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	var description:UML::InstanceSpecification=new UML::InstanceSpecification(spp,DescriptionClassifier);
	spp.getNearestPackage().packagedElement+=description;
	instanceValue.instance:=description;
	self.setFeatureValue(description,'Description');
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance(featureName,spp,description);
		};
		
	
}
query UML::EncapsulatedClassifier::primaryServiceInterface():UML::Class=
	self.primaryPort().type.oclAsType(UML::Class);
query UML::EncapsulatedClassifier::primaryPort():UML::Port=
	self.ownedPort->select(p|p.aggregation=UML::AggregationKind::composite)->asSequence()->first();

//mapping String::CapabilityDescriptionText(inout spp:UML::InstanceSpecification,primaryServiceParticipant:UML::Component,
//	primaryServiceInterface:UML::Class):UML::InstanceSpecification@pimUml
mapping String::CapabilityDescriptionText(inout spp:UML::InstanceSpecification):UML::InstanceSpecification@pimUml
{
	name:=self;
	/*
	primaryServiceParticipant.getNearestPackage().packagedElement+=result;
	primaryServiceParticipant.map ComponentRealization(result);
	result.map ComponentRealization(primaryServiceInterface);
	var spp:Stdlib::Element=result.applyStereotype(graServiceCapabilityStereotype);
	result.applyStereotype(soamlCapabilityStereotype);
//	self.addTagValue(spp,'capabilityDescriptionText');
	self.setTagValue(spp,'capabilityDescriptionText');
	*/
	spp.getNearestPackage().packagedElement+=result;

	var slot:UML::Slot='ServiceCapabilities'.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	classifier+=ServiceCapabilityClassifier;
	instanceValue.instance:=result;
	self.addFeatureValue(result,'CapabilityDescriptionText');
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance(self,spp,result);
		};
}
/*
mapping inout	UML::Component::ComponentRealization(classifier:UML::Classifier):UML::ComponentRealization@pimUml
{
	abstraction:=self;
	realizingClassifier:=classifier;
}
*/
/*
mapping inout	UML::Collaboration::CollaborationUse(inout serviceContract:UML::Collaboration,primaryServiceParticipant:UML::Component,
	partnerServiceParticipant:UML::InstanceSpecification):UML::CollaborationUse@pimUml
{
	self.collaborationUse+=result;
	type:=serviceContract;
	var serviceClassifierProperty:UML::Property=self.partTypedAs(primaryServiceParticipant);
	var partnerClassifierProperty:UML::Property=self.partTypedAs(partnerServiceParticipant);
//	var serviceCollaborationProperty:Set(UML::Property)=serviceContract.roleTypedAs(primaryServiceParticipant.());
//	var partnerCollaborationProperty:Set(UML::Property)=serviceContract.roleTypedAs(partnerServiceParticipant.primaryUsedInterface());

	primaryServiceParticipant.primaryImplementedInterface()->forEach(ifc){
log('CollaborationUse implemented '+ifc.toString());
		var role:UML::Property=new UML::Property();
		role.type:=ifc;
		role.name:=ifc.name;
		serviceContract.ownedAttribute+=role;
//		serviceContract.roleTypedAs(ifc).map RoleBinding(result,serviceClassifierProperty);
		role.map RoleBinding(result,serviceClassifierProperty);
log('CollaborationUse implemented roleBinding '+role.toString());
		};
log('CollaborationUse y ');
	partnerServiceParticipant.primaryUsedInterface()->forEach(ifc){
log('CollaborationUse used '+ifc.toString());
		var role:UML::Property=new UML::Property();
		role.type:=ifc;
		role.name:=ifc.name;
		serviceContract.ownedAttribute+=role;
//		serviceContract.roleTypedAs(ifc).map RoleBinding(result,serviceClassifierProperty);
		role.map RoleBinding(result,serviceClassifierProperty);
//		serviceContract.roleTypedAs(ifc).map RoleBinding(result,serviceClassifierProperty);
log('CollaborationUse used roleBinding');
		};
	//result.map RoleBinding(serviceCollaborationProperty,serviceClassifierProperty);
	//result.map RoleBinding(partnerCollaborationProperty,partnerClassifierProperty);
	//serviceCollaborationProperty.map RoleBinding(result,serviceClassifierProperty);
	//partnerCollaborationProperty.map RoleBinding(result,serviceClassifierProperty);
}
*/
query UML::EncapsulatedClassifier::primaryUsedInterface():Set(UML::Interface)=
//	self.primaryServiceInterface().getAllUsedInterfaces()->asSet();
	self.primaryServiceInterface().clientDependency
	->select(d|d.oclIsKindOf(UML::Usage)).supplier->select(s|s.oclIsKindOf(UML::Interface)).oclAsType(UML::Interface)->asSet();
query UML::EncapsulatedClassifier::primaryImplementedInterface():Set(UML::Interface)=
//	self.primaryServiceInterface().getAllImplementedInterfaces()->asSet();
//	self.primaryServiceInterface().getImplementedInterfaces()->asSet();
	self.primaryServiceInterface().interfaceRealization.contract->asSet();
//	self.primaryServiceInterface().clientDependency.supplier->select(s|s.oclIsKindOf(UML::Interface)).oclAsType(UML::Interface)->asSet();
query UML::StructuredClassifier::partTypedAs(type:UML::Type):UML::Property=
	self.part->select(p|p.type=type)->asSequence()->first();
query UML::StructuredClassifier::roleTypedAs(type:UML::Type):Set(UML::Property)=
	self.part->select(p|p.type=type);
	/*
mapping inout	UML::Property::RoleBinding(inout collaborationUse:UML::CollaborationUse,classifierProperty:UML::Property
	):UML::Dependency@pimUml
{
	collaborationUse.roleBinding+=result;
	supplier+=self;
	client+=classifierProperty;
}
*/
mapping 	METADATA::ServiceLevelAgreementsType::ServiceLevelAgreementsType(inout spp:UML::InstanceSpecification,
	inout servicesArchitecture:UML::Collaboration
//	,primaryServiceParticipant:UML::Component,	partnerServiceParticipant:UML::InstanceSpecification
	):UML::InstanceSpecification@pimUml
//	partnerServiceParticipant:UML::Component):UML::Collaboration@pimUml
{
	name:=servicesArchitecture.name+'.ServiceLevelAgreements';
	/*
	servicesArchitecture.getNearestPackage().packagedElement+=result;
	var spp:Stdlib::Element=result.applyStereotype(graServiceLevelAgreementsStereotype);
	result.applyStereotype(soamlServiceContractStereotype);
	// establish parts using interfaces
	servicesArchitecture.map CollaborationUse(result,primaryServiceParticipant,partnerServiceParticipant);
	var serviceLevelAgreements:METADATA::ServiceLevelAgreementsType=self;
				serviceLevelAgreements.servicePolicyAndContracts->forEach(servicePolicyAndContracts){
				
					servicePolicyAndContracts.applicablePoliciesIndicator.setTagValue(spp,'applicablePoliciesIndicator');
					servicePolicyAndContracts.applicablePolicies.policyText.setTagValue(spp,'policyText');
					servicePolicyAndContracts.applicableContractsIndicator.setTagValue(spp,'applicableContractsIndicator');
					// assume indexes match
					servicePolicyAndContracts.applicableContracts.contract->forEach(contract){
						contract.agreementDescriptionText.addTagValue(spp,'contractAgreementDescriptionText');
						contract.agreementURI.repr().addTagValue(spp,'contractAgreementURI');
					};	
					servicePolicyAndContracts.applicableAgreementsIndicator.setTagValue(spp,'applicableAgreementsIndicator');
					servicePolicyAndContracts.applicableAgreements.agreement->forEach(agreement){
						agreement.agreementDescriptionText.addTagValue(spp,'agreementAgreementDescriptionText');
						agreement.agreementURI.repr().addTagValue(spp,'agreementAgreementURI');
					};	
					servicePolicyAndContracts.applicableUmbrellaAgreementsIndicator.setTagValue(spp,'applicableUmbrellaAgreementsIndicator');
					servicePolicyAndContracts.applicableUmbrellaAgreements.umbrellaAgreement->forEach(umbrellaAgreement){
						umbrellaAgreement.agreementDescriptionText.addTagValue(spp,'umbrellaAgreementAgreementDescriptionText');
						umbrellaAgreement.agreementURI.repr().addTagValue(spp,'umbrellaAgreementAgreementURI');
					};	
				};
				serviceLevelAgreements.performanceMetrics->forEach(performanceMetrics){
//					performanceMetrics.performanceResponseDuration.setTagValue(spp,'performanceResponseDuration');
					performanceMetrics.serviceResponseTime.repr().setTagValue(spp,'performanceResponseDuration');
					performanceMetrics.serviceAverageThroughput.setTagValue(spp,'serviceAverageThroughput');
					performanceMetrics.serviceMaximumThroughput.setTagValue(spp,'serviceMaximumThroughput');
					performanceMetrics.serviceAvailability.setTagValue(spp,'serviceAvailability');
				};	
				
				serviceLevelAgreements.serviceUsageDetails->forEach(serviceUsageDetails){
//					serviceUsageDetails.approvalRequired.setTagValue(spp,'approvalRequired');
					serviceUsageDetails.approvalRequiredIndicator.setTagValue(spp,'approvalRequired');
//					serviceUsageDetails.licensingRequired.setTagValue(spp,'licensingRequired');
					serviceUsageDetails.licensingRequiredIndicator.setTagValue(spp,'licensingRequired');
					serviceUsageDetails.licensingAgreement->forEach(licensingAgreement){
						licensingAgreement.agreementDescriptionText.setTagValue(spp,'licensingAgreementDescriptionText');
						licensingAgreement.agreementURI.repr().setTagValue(spp,'licensingAgreementURI');
					};	
					serviceUsageDetails.serviceCost->forEach(serviceCost){
						serviceCost.usageCostAmount->forEach(usageCostAmount){
							usageCostAmount.value.setTagValue(spp,'usageCostAmountValue');
							usageCostAmount.currencyText.setTagValue(spp,'usageCostAmountCurrencyText');
						};	
						serviceCost.usageUnitCostAmount->forEach(usageUnitCostAmount){
							usageUnitCostAmount.value.setTagValue(spp,'usageUnitCostAmountValue');
							usageUnitCostAmount.currencyText.setTagValue(spp,'usageUnitCostAmountCurrencyText');
						};	
						serviceCost.creationCostAmount->forEach(creationCostAmount){
							creationCostAmount.value.setTagValue(spp,'creationCostAmountValue');
							creationCostAmount.currencyText.setTagValue(spp,'creationCostAmountCurrencyText');
						};	
					};	
				};
				*/	
	spp.getNearestPackage().packagedElement+=result;
	classifier+=ServiceLevelAgreementClassifier;
	
	var slot:UML::Slot='ServiceLevelAgreement'.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('ServiceLevelAgreement',spp,result);
		};
	// establish parts using interfaces
	//servicesArchitecture.map CollaborationUse(result,primaryServiceParticipant,partnerServiceParticipant);
	var serviceLevelAgreements:METADATA::ServiceLevelAgreementsType=self;
				serviceLevelAgreements.servicePolicyAndContracts->forEach(servicePolicyAndContracts){
				
					servicePolicyAndContracts.applicablePoliciesIndicator.setFeatureValue(result,'ApplicablePoliciesIndicator');
					servicePolicyAndContracts.applicablePolicies.policyText.setFeatureValue(result,'ApplicablePolicies');
					servicePolicyAndContracts.applicableContractsIndicator.setFeatureValue(result,'ApplicableContractsIndicator');
					// assume indexes match
					servicePolicyAndContracts.applicableContracts.contract->forEach(contract){
						var agreement:UML::InstanceSpecification=new UML::InstanceSpecification(result,AgreementClassifier);
						spp.getNearestPackage().packagedElement+=agreement;
						var agreementslot:UML::Slot='ApplicableContract'.getSlot(result);
						var agreementinstanceValue:UML::InstanceValue=new UML::InstanceValue();
						agreementslot.value+=agreementinstanceValue;
						agreementinstanceValue.instance:=agreement;
					
						contract.agreementDescriptionText.setFeatureValue(agreement,'AgreementDescriptionText');
						contract.agreementURI.repr().setFeatureValue(agreement,'AgreementURI');
						// check for association
						agreementslot.definingFeature
							->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
								association.map AssociationInstance('ApplicableContract',result,agreement);
							};
					};	
					servicePolicyAndContracts.applicableAgreementsIndicator.setFeatureValue(result,'ApplicableAgreementsIndicator');
					servicePolicyAndContracts.applicableAgreements.agreement->forEach(agreement){
						var agreementInstance:UML::InstanceSpecification=new UML::InstanceSpecification(result,AgreementClassifier);
						spp.getNearestPackage().packagedElement+=agreementInstance;
						var agreementslot:UML::Slot='Agreement'.getSlot(result);
						var agreementinstanceValue:UML::InstanceValue=new UML::InstanceValue();
						agreementslot.value+=agreementinstanceValue;
						agreementinstanceValue.instance:=agreementInstance;
						agreement.agreementDescriptionText.setFeatureValue(agreementInstance,'AgreementDescriptionText');
						agreement.agreementURI.repr().setFeatureValue(agreementInstance,'AgreementURI');
						// check for association
						agreementslot.definingFeature
							->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
								association.map AssociationInstance('Agreement',result,agreementInstance);
							};
						
					};	
					servicePolicyAndContracts.applicableUmbrellaAgreementsIndicator.setFeatureValue(result,'ApplicableUmbrellaAgreementsIndicator');
					servicePolicyAndContracts.applicableUmbrellaAgreements.umbrellaAgreement->forEach(umbrellaAgreement){
						var agreement:UML::InstanceSpecification=new UML::InstanceSpecification(result,AgreementClassifier);
						spp.getNearestPackage().packagedElement+=agreement;
						var agreementslot:UML::Slot='UmbrellaAgreement'.getSlot(result);
						var agreementinstanceValue:UML::InstanceValue=new UML::InstanceValue();
						agreementslot.value+=agreementinstanceValue;
						agreementinstanceValue.instance:=agreement;

						umbrellaAgreement.agreementDescriptionText.setFeatureValue(agreement,'AgreementDescriptionText');
						umbrellaAgreement.agreementURI.repr().setFeatureValue(agreement,'AgreementURI');
						// check for association
						agreementslot.definingFeature
							->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
								association.map AssociationInstance('UmbrellaAgreement',result,agreement);
							};
						
					};	
				};
				serviceLevelAgreements.performanceMetrics->forEach(performanceMetrics){
//					performanceMetrics.performanceResponseDuration.setTagValue(spp,'performanceResponseDuration');
					performanceMetrics.serviceResponseTime.repr().setFeatureValue(result,'ServiceResponseTime');
					performanceMetrics.serviceAverageThroughput.setFeatureValue(result,'ServiceAverageThroughput');
					performanceMetrics.serviceMaximumThroughput.setFeatureValue(result,'ServiceMaximumThroughput');
					performanceMetrics.serviceAvailability.setFeatureValue(result,'ServiceAvailability');
				};	
				
				serviceLevelAgreements.serviceUsageDetails->forEach(serviceUsageDetails){
//					serviceUsageDetails.approvalRequired.setTagValue(spp,'approvalRequired');
					serviceUsageDetails.approvalRequiredIndicator.setFeatureValue(result,'ApprovalRequiredIndicator');
//					serviceUsageDetails.licensingRequired.setTagValue(spp,'licensingRequired');
					serviceUsageDetails.licensingRequiredIndicator.setFeatureValue(result,'LicensingRequiredIndicator');
					serviceUsageDetails.licensingAgreement->forEach(licensingAgreement){
						var agreement:UML::InstanceSpecification=new UML::InstanceSpecification(result,AgreementClassifier);
						spp.getNearestPackage().packagedElement+=agreement;
						var agreementslot:UML::Slot='LicensingAgreement'.getSlot(result);
						var agreementinstanceValue:UML::InstanceValue=new UML::InstanceValue();
						agreementslot.value+=agreementinstanceValue;
						agreementinstanceValue.instance:=agreement;
						licensingAgreement.agreementDescriptionText.setFeatureValue(agreement,'AgreementDescriptionText');
						licensingAgreement.agreementURI.repr().setFeatureValue(agreement,'AgreementURI');
						// check for association
						agreementslot.definingFeature
							->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
								association.map AssociationInstance('LicensingAgreement',result,agreement);
							};
					};	
					serviceUsageDetails.serviceCost->forEach(serviceCost){
						serviceCost.usageCostAmount->forEach(usageCostAmount){
							var amount:UML::InstanceSpecification=new UML::InstanceSpecification(result,AmountTypeClassifier);
							spp.getNearestPackage().packagedElement+=amount;
							var amountslot:UML::Slot='UsageCostAmount'.getSlot(result);
							var amountinstanceValue:UML::InstanceValue=new UML::InstanceValue();
							amountslot.value+=amountinstanceValue;
							amountinstanceValue.instance:=amount;
							usageCostAmount.value.setFeatureValue(amount,'value');
							usageCostAmount.currencyText.setFeatureValue(amount,'currencyText');
							// check for association
							amountslot.definingFeature
								->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
									association.map AssociationInstance('UsageCostAmount',result,amount);
								};
						};	
						serviceCost.usageUnitCostAmount->forEach(usageUnitCostAmount){
							var amount:UML::InstanceSpecification=new UML::InstanceSpecification(result,AmountTypeClassifier);
							spp.getNearestPackage().packagedElement+=amount;
							var amountslot:UML::Slot='UsageUnitCostAmount'.getSlot(result);
							var amountinstanceValue:UML::InstanceValue=new UML::InstanceValue();
							amountslot.value+=amountinstanceValue;
							amountinstanceValue.instance:=amount;
							usageUnitCostAmount.value.setFeatureValue(amount,'value');
							usageUnitCostAmount.currencyText.setFeatureValue(amount,'currencyText');
							// check for association
							amountslot.definingFeature
								->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
									association.map AssociationInstance('UsageUnitCostAmount',result,amount);
								};
							
						};	
						serviceCost.creationCostAmount->forEach(creationCostAmount){
							var amount:UML::InstanceSpecification=new UML::InstanceSpecification(result,AmountTypeClassifier);
							spp.getNearestPackage().packagedElement+=amount;
							var amountslot:UML::Slot='CreationCostAmount'.getSlot(result);
							var amountinstanceValue:UML::InstanceValue=new UML::InstanceValue();
							amountslot.value+=amountinstanceValue;
							amountinstanceValue.instance:=amount;
							creationCostAmount.value.setFeatureValue(amount,'value');
							creationCostAmount.currencyText.setFeatureValue(amount,'currencyText');
							// check for association
							amountslot.definingFeature
								->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
									association.map AssociationInstance('CreationCostAmount',result,amount);
								};
							
						};	
					};	
				};
}

// seems like this should also be in ServiceInterface via wsdl, possibly bpmn
// for now, map to ServiceInterface class
// TODO: we should be doing port on spp participant whose type is serviceInterface
//mapping 	METADATA::ServiceInterfaceSpecificationType::ServiceInterfaceSpecificationType(inout spp:UML::InstanceSpecification,
//	inout participant:UML::Component,inout serviceInterface:UML::Class):UML::Interface@pimUml
mapping 	METADATA::ServiceInterfaceSpecificationType::ServiceInterfaceSpecificationType(
	inout spp:UML::InstanceSpecification):UML::Component@pimUml
{
	//participant.nestedClassifier+=result;
	
	var participantsPackage:UML::Package=sppArchitecture.map ParticipantsPackage();
	participantsPackage.packagedElement+=result;
	
	//sppCatalog.wsdlSchema->select(s|).map WsdlSchemaType(sppArchitecture);// switch order for debug
	var uriAddress:String=self.uRIDetails.uRIDetail.uRIAddress.repr()->first();
	name:=uriAddress;
	

	
	
//	serviceInterface.map InterfaceRealization(result);
	self.WSDLServiceInterface(spp,result);
	// add to collaboration
	var role:UML::Property=new UML::Property();
	sppArchitecture.ownedAttribute+=role;
	role.type:=result;
	role.name:=result.name;
	role.lower:=1;
	role.upper:=1;
	role.aggregation:=UML::AggregationKind::composite;
	role.visibility:=UML::VisibilityKind::public;
	
	/*
	var spp:Stdlib::Element=result.applyStereotype(graServiceInterfaceSpecificationStereotype);
	// assume these align by index
	self.uRIDetails.uRIDetail->forEach(uriDetail){
		uriDetail.uRIAddress.repr().addTagValue(spp,'uRIAddress');
		uriDetail.uRIDescription.addTagValue(spp,'uRIDescription');
	};
	self.serviceActions.serviceAction.map ServiceActionType(result);
	// assume these align by index; assume no significance to grouping
	self.serviceInteractionProfiles.serviceInteractionProfile->forEach(serviceInteractionProfile){
		serviceInteractionProfile.sIPName.setTagValue(spp,'sIPName');
		serviceInteractionProfile.sIPVersion.setTagValue(spp,'sIPVersion');
	};
	self.securityImplementedIndicator.setTagValue(spp,'securityImplementedIndicator');
	self.securityDescriptionText.setTagValue(spp,'securityDescriptionText');
	*/
}
mapping 	METADATA::ServiceInterfaceSpecificationType::WSDLServiceInterface(inout spp:UML::InstanceSpecification,
//	inout interface:UML::Interface):UML::InstanceSpecification@pimUml
	inout interface:UML::Component):UML::InstanceSpecification@pimUml
{
	spp.getNearestPackage().packagedElement+=result;
	classifier+=WSDLServiceInterfaceClassifier;
	
	var slot:UML::Slot='ServiceInterface'.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('ServiceInterface',spp,result);
		};
	
	name:=self.uRIDetails.uRIDetail.uRIAddress.repr()->first();
	result.map Realization(interface);
	
	//var spp:Stdlib::Element=result.applyStereotype(graServiceInterfaceSpecificationStereotype);
	// assume these align by index
	self.uRIDetails.uRIDetail->forEach(uriDetail){
		uriDetail.uRIAddress.repr().setFeatureValue(result,'URIAddress');
		uriDetail.uRIDescription.setFeatureValue(result,'URIDescription');
		/*
		var uriDetailInstance:UML::InstanceSpecification=new UML::InstanceSpecification(result,URIDetailClassifier);
		spp.getNearestPackage().packagedElement+=uriDetailInstance;
		var uriDetailslot:UML::Slot='ServiceURI'.getSlot(result);
		var uriDetailinstanceValue:UML::InstanceValue=new UML::InstanceValue();
		uriDetailslot.value+=uriDetailinstanceValue;
		uriDetailinstanceValue.instance:=uriDetailInstance;
		uriDetail.uRIAddress.repr().setFeatureValue(uriDetailInstance,'URIAddress');
		uriDetail.uRIDescription.setFeatureValue(uriDetailInstance,'URIDescription');
		// check for association
		uriDetailslot.definingFeature
			->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
				association.map AssociationInstance('ServiceURI',result,uriDetailInstance);
			};
		*/
	};
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
	var didService:Boolean=false;
	var uriAddress:String=self.uRIDetails.uRIDetail.uRIAddress.repr()->first();
	sppCatalog.wsdlSchema->forEach(wsdlSchema){
		var wsdl:WSDL::Definition=wsdlSchema.oclAsType(Stdlib::Element).getWsdlAtRelativeURI(wsdlSchema.href).oclAsType(WSDL::Definition);
		if(wsdl.targetNamespace=uriAddress)then{
			// do instance target from wsdl
			interface.name:=wsdl.eServices.getServiceQNameLocalPart()->first();
			didService:=true;
			wsdl.eServices.map WSDLService(self,result,interface);
		}endif;
	};
	if(not(didService))then{
		self.map WSDLService(result,interface);
	}endif;
	// assume these align by index; assume no significance to grouping
	self.serviceInteractionProfiles.serviceInteractionProfile->forEach(serviceInteractionProfile){
		var serviceInteractionProfileInstance:UML::InstanceSpecification=new UML::InstanceSpecification(result,ServiceInteractionProfileClassifier);
		spp.getNearestPackage().packagedElement+=serviceInteractionProfileInstance;
		var serviceInteractionProfileslot:UML::Slot='ServiceInteractionProfile'.getSlot(result);
		var serviceInteractionProfileinstanceValue:UML::InstanceValue=new UML::InstanceValue();
		serviceInteractionProfileslot.value+=serviceInteractionProfileinstanceValue;
		serviceInteractionProfileinstanceValue.instance:=serviceInteractionProfileInstance;
		serviceInteractionProfile.sIPName.setFeatureValue(serviceInteractionProfileInstance,'SIPName');
		serviceInteractionProfile.sIPVersion.setFeatureValue(serviceInteractionProfileInstance,'SIPVersion');
		// check for association
		serviceInteractionProfileslot.definingFeature
			->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
				association.map AssociationInstance('ServiceInteractionProfile',result,serviceInteractionProfileInstance);
			};
		
	};
	self.securityImplementedIndicator.setFeatureValue(result,'SecurityImplementationIndicator');
	self.securityDescriptionText.setFeatureValue(result,'SecurityDescriptionText');
}
mapping 	WSDL::Service::WSDLService(inout wsdlService:METADATA::ServiceInterfaceSpecificationType,
	inout wsdlServiceInterface:UML::InstanceSpecification,
	inout interface:UML::Component):UML::InstanceSpecification@pimUml
{
	wsdlServiceInterface.getNearestPackage().packagedElement+=result;
	classifier+=WSDLServiceClassifier;
	name:=self.getServiceQNameLocalPart();
	
	var slot:UML::Slot='provider'.getSlot(wsdlServiceInterface);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('provider',wsdlServiceInterface,result);
		};
	
	self.ePorts.map WSDLPortPort(wsdlService,result,interface);
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
}
mapping 	WSDL::Port::WSDLPortPort(
	inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType,inout wsdlService:UML::InstanceSpecification,
	inout interface:UML::Component):UML::Port@pimUml
{
	interface.ownedAttribute+=result;
	name:=self.name;
	self.map WSDLPort(serviceInterfaceSpecification,wsdlService,result);
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
}
mapping 	WSDL::Port::WSDLPort(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType,
	inout wsdlService:UML::InstanceSpecification,
	inout port:UML::Port):UML::InstanceSpecification@pimUml
{
	wsdlService.getNearestPackage().packagedElement+=result;
	classifier+=WSDLPortClassifier;
	name:=self.name;
	var slot:UML::Slot='port'.getSlot(wsdlService);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	result.map Realization(port);
//	self.eBinding.map WSDLInterfaceInterface(serviceInterfaceSpecification,result,port);
	self.eBinding.ePortType.map WSDLInterfaceInterface(serviceInterfaceSpecification,result,port);
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('port',wsdlService,result);
		};
}
//mapping 	WSDL::Binding::WSDLInterfaceInterface(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType,
mapping 	WSDL::PortType::WSDLInterfaceInterface(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType,
	inout wsdlPort:UML::InstanceSpecification,
	inout port:UML::Port):UML::Interface@pimUml
{
	var interfacesPackage:UML::Package=sppArchitecture.map InterfacesPackage();
	interfacesPackage.packagedElement+=result;
	name:=self.getPortTypeQNameLocalPart();
	port.type:=result;
	
	self.map WSDLInterface(serviceInterfaceSpecification,wsdlPort,result);
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
}
//mapping 	WSDL::Binding::WSDLInterface(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType,
mapping 	WSDL::PortType::WSDLInterface(inout serviceInterfaceSpecification:METADATA::ServiceInterfaceSpecificationType,
	inout wsdlPort:UML::InstanceSpecification,
	inout interface:UML::Interface):UML::InstanceSpecification@pimUml
{
	wsdlPort.getNearestPackage().packagedElement+=result;
	classifier+=WSDLInterfaceClassifier;
	
	var slot:UML::Slot='interface'.getSlot(wsdlPort);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	result.map Realization(interface);
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('interface',wsdlPort,result);
		};
	
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
	// match up the actions with operations
//	self.eBindingOperations->forEach(bindingOperation){
	self.eOperations->forEach(bindingOperation){
		serviceInterfaceSpecification.serviceActions.serviceAction
			->select(a|a.actionName=bindingOperation.name)->forEach(serviceAction){
			
			bindingOperation.map ServiceActionType(serviceAction,result,interface);
		};
	};
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
}
//mapping 	WSDL::BindingOperation::ServiceActionType(inout serviceAction:METADATA::ServiceActionType,inout serviceInterface:UML::InstanceSpecification,
mapping 	WSDL::Operation::ServiceActionType(inout serviceAction:METADATA::ServiceActionType,
		inout serviceInterface:UML::InstanceSpecification,
		inout context:UML::Interface):UML::Operation@pimUml
{
	context.ownedOperation+=result;
	name:=self.name;
	/*
	var spp:Stdlib::Element=result.applyStereotype(graServiceActionStereotype);
	self.actionPurpose.setTagValue(spp,'actionPurpose');
	self.messageExchangePattern.setTagValue(spp,'messageExchangePattern');
	*/
		var action:UML::InstanceSpecification=new UML::InstanceSpecification(serviceInterface,WSDLOperationClassifier);
		serviceInterface.getNearestPackage().packagedElement+=action;
	action.map Realization(result);	
	
	var slot:UML::Slot='operation'.getSlot(serviceInterface);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=action;
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('operation',serviceInterface,action);
		};
	
	
	serviceAction.actionPurpose.setFeatureValue(action,'ActionPurpose');
	serviceAction.messageExchangePattern.setFeatureValue(action,'MessageExchangePattern');
	
//	self.eBindingInput.map BindingInput(action,result);
//	self.eBindingOutput.map BindingOutput(action,result);
	self.eInput.map BindingInput(action,result);
	self.eOutput.map BindingOutput(action,result);
}
//mapping 	WSDL::BindingInput::BindingInput(
mapping 	WSDL::Input::BindingInput(
	inout wsdlOperation:UML::InstanceSpecification,
	inout operation:UML::Operation):UML::Parameter@pimUml
{
	operation.ownedParameter+=result;
	name:=self.name;
	direction:=UML::ParameterDirectionKind::_in;
//	self.eInput.eMessage->forEach(message){
		// get type, add message instance, hook from wsdlOperation, realization
	var message:WSDL::Message=self.eMessage;
	var interfacesPackage:UML::Package=sppArchitecture.map InterfacesPackage();
	if(not(interfacesPackage.oclIsUndefined()))then{
		type:=message.map Message(interfacesPackage);
	
			var action:UML::InstanceSpecification=message.map WsdlMessage();
			wsdlOperation.getNearestPackage().packagedElement+=action;
		action.map Realization(result);	
		
		var slot:UML::Slot='message'.getSlot(wsdlOperation);
		var instanceValue:UML::InstanceValue=new UML::InstanceValue();
		slot.value+=instanceValue;
		instanceValue.instance:=action;
		
		// check for association
		slot.definingFeature
			->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
				association.map AssociationInstance('message',wsdlOperation,action);
			};
		
	}endif;
}
mapping 	WSDL::Message::WsdlMessage():UML::InstanceSpecification@pimUml
{
	// caller maps for containment, connection with operation, etc.
	classifier+=WSDLMessageClassifier;
}
//mapping 	WSDL::BindingOutput::BindingOutput(
mapping 	WSDL::Output::BindingOutput(
	inout wsdlOperation:UML::InstanceSpecification,
	inout operation:UML::Operation):UML::Parameter@pimUml
{
	operation.ownedParameter+=result;
	name:=self.name;
	direction:=UML::ParameterDirectionKind::_return;
//	self.eOutput.eMessage->forEach(message){
		//  get type, add message instance, hook from wsdlOperation, realization
	var message:WSDL::Message=self.eMessage;
	type:=message.map Message(sppArchitecture.map InterfacesPackage());
	
		var action:UML::InstanceSpecification=message.map WsdlMessage();
		wsdlOperation.getNearestPackage().packagedElement+=action;
	action.map Realization(result);	
	
	var slot:UML::Slot='message'.getSlot(wsdlOperation);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=action;
	
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('message',wsdlOperation,action);
		};
	
}

////////////////////////////////////////////////////////////////////////
mapping 	METADATA::ServiceInterfaceSpecificationType::WSDLService(inout wsdlServiceInterface:UML::InstanceSpecification,
	inout interface:UML::Component):UML::InstanceSpecification@pimUml
{
	wsdlServiceInterface.getNearestPackage().packagedElement+=result;
	classifier+=WSDLServiceClassifier;
	
	var slot:UML::Slot='provider'.getSlot(wsdlServiceInterface);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	
	self.map WSDLPortPort(result,interface);
	
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('provider',wsdlServiceInterface,result);
		};
	
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
}
mapping 	METADATA::ServiceInterfaceSpecificationType::WSDLPortPort(
	inout wsdlService:UML::InstanceSpecification,
	inout interface:UML::Component):UML::Port@pimUml
{
	interface.ownedAttribute+=result;
	//name:=self.name;
	self.map WSDLPort(wsdlService,result);
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
}

mapping 	METADATA::ServiceInterfaceSpecificationType::WSDLPort(inout wsdlService:UML::InstanceSpecification,
	inout port:UML::Port):UML::InstanceSpecification@pimUml
{
	wsdlService.getNearestPackage().packagedElement+=result;
	classifier+=WSDLPortClassifier;
	
	var slot:UML::Slot='port'.getSlot(wsdlService);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	result.map Realization(port);
	self.map WSDLInterfaceInterface(result,port);
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('port',wsdlService,result);
		};
	
}
mapping 	METADATA::ServiceInterfaceSpecificationType::WSDLInterfaceInterface(inout wsdlPort:UML::InstanceSpecification,
	inout port:UML::Port):UML::Interface@pimUml
{
	var interfacesPackage:UML::Package=sppArchitecture.map InterfacesPackage();
	interfacesPackage.packagedElement+=result;
	port.type:=result;
	
	self.map WSDLInterface(wsdlPort,result);
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
}
mapping 	METADATA::ServiceInterfaceSpecificationType::WSDLInterface(inout wsdlPort:UML::InstanceSpecification,
	inout interface:UML::Interface):UML::InstanceSpecification@pimUml
{
	wsdlPort.getNearestPackage().packagedElement+=result;
	classifier+=WSDLInterfaceClassifier;
	
	var slot:UML::Slot='interface'.getSlot(wsdlPort);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	result.map Realization(interface);
	//self.serviceActions.serviceAction.map ServiceActionType(result,interface);
	self.serviceActions.serviceAction.map ServiceActionType(result,interface);
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('interface',wsdlPort,result);
		};
	
}
mapping 	METADATA::ServiceActionType::ServiceActionType(inout serviceInterface:UML::InstanceSpecification,
		inout context:UML::Interface):UML::Operation@pimUml
{
	context.ownedOperation+=result;
	name:=self.actionName;
	/*
	var spp:Stdlib::Element=result.applyStereotype(graServiceActionStereotype);
	self.actionPurpose.setTagValue(spp,'actionPurpose');
	self.messageExchangePattern.setTagValue(spp,'messageExchangePattern');
	*/
		var action:UML::InstanceSpecification=new UML::InstanceSpecification(serviceInterface,WSDLOperationClassifier);
		serviceInterface.getNearestPackage().packagedElement+=action;
	action.map Realization(result);	
	self.actionPurpose.setFeatureValue(action,'ActionPurpose');
	self.messageExchangePattern.setFeatureValue(action,'MessageExchangePattern');
}
mapping 	UML::BehavioredClassifier::InterfaceRealization(inout interfaceRealized:UML::Interface):UML::InterfaceRealization@pimUml
{
	implementingClassifier:=self;
	contract:=interfaceRealized;
}
mapping 	UML::NamedElement::Realization(inout supplierIn:UML::NamedElement):UML::Realization@pimUml
{
	self.getNearestPackage().packagedElement+=result;
	client+=self;
	supplier+=supplierIn;
}
/*
mapping 	METADATA::RelatedOrganizationInformationType::RelatedOrganizationInformationType(inout serviceSubject:UML::Collaboration):UML::UseCase@pimUml
{
	subject+=serviceSubject;
	name:=serviceSubject.name+'RelatedOrganization';// TODO: needs to be unique name
	serviceSubject.getNearestPackage().packagedElement+=result;
	self.organization.map OrganizationType(result);
	
}
*/
//mapping 	METADATA::RelatedOrganizationInformationType::RelatedOrganizationInformationType(inout spp:UML::InstanceSpecification):UML::InstanceSpecification@pimUml
mapping 	METADATA::OrganizationType::RelatedOrganizationInformationType(inout spp:UML::InstanceSpecification):UML::InstanceSpecification@pimUml
{
	//subject+=serviceSubject;
	//name:=serviceSubject.name+'RelatedOrganization';// TODO: needs to be unique name
	//serviceSubject.getNearestPackage().packagedElement+=result;
	//self.organization.map OrganizationType(result);
	spp.getNearestPackage().packagedElement+=result;
	classifier+=OrganizationClassifier;
	var slot:UML::Slot='RelatedOrganization'.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
//	self.organization.map OrganizationType(result);
	name:=self.organizationName;
	
	//self.organizationName.setTagValue(spp,'organizationName');
	self.organizationName.setFeatureValue(result,'OrganizationName');
	self.organizationAcronym.setFeatureValue(result,'OrganizationAcronym');
	self.organizationFullAddressText.setFeatureValue(result,'OrganizationFullAddressText');
	self.organizationWebSiteURL.repr().setFeatureValue(result,'OrganizationWebSiteURL');
	self.organizationRoleDescriptionText.setFeatureValue(result,'OrganizationRoleDescriptionText');
	self.organizationRoleDetailedDescriptionText.setFeatureValue(result,'OrganizationRoleDetailedDescriptionText');
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('RelatedOrganization',spp,result);
		};
	
	self.organizationPointOfContact->forEach(organizationPointOfContact){
		var poc:UML::InstanceSpecification=new UML::InstanceSpecification(result,PersonClassifier);
		spp.getNearestPackage().packagedElement+=		poc;
		var pocslot:UML::Slot='OrganizationPointOfContact'.getSlot(result);
		var pocinstanceValue:UML::InstanceValue=new UML::InstanceValue();
		pocslot.value+=pocinstanceValue;
		pocinstanceValue.instance:=poc;
		organizationPointOfContact.contactPersonName.setFeatureValue(poc,'ContactPersonName');
		organizationPointOfContact.contactPersonEmailID.setFeatureValue(poc,'ContactPersonEmailID');
		organizationPointOfContact.contactPersonPhoneNumberID.setFeatureValue(poc,'ContactPersonPhoneNumberID');
		organizationPointOfContact.contactPersonAddress.setFeatureValue(poc,'ContactPersonAddress');
		// check for association
		pocslot.definingFeature
			->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
				association.map AssociationInstance('OrganizationPointOfContact',result,poc);
			};
		
	};	

	
}
/*
mapping 	METADATA::OrganizationType::OrganizationType(inout relatedOrganization:UML::UseCase):UML::Actor@pimUml
{
	relatedOrganization.getNearestPackage().packagedElement+=result;
	name:=self.organizationName;
	// association to relatedOrganization
	var assoc:UML::Association=new UML::Association();
	var prop:UML::Property=new UML::Property();
	var otherprop:UML::Property=new UML::Property();
	prop.type:=relatedOrganization;
	otherprop.type:=result;
	assoc.ownedEnd+=otherprop;
	assoc.ownedEnd+=prop;
	assoc.navigableOwnedEnd+=prop;
	prop.lower:=1;
	prop.upper:=1;
	otherprop.lower:=1;
	otherprop.upper:=1;
	assoc.memberEnd+=otherprop;
	assoc.memberEnd+=prop;
	relatedOrganization.getNearestPackage().packagedElement+=assoc;
	
	var spp:Stdlib::Element=result.applyStereotype(graOrganizationStereotype);
	//self.organizationName.setTagValue(spp,'organizationName');
	self.organizationAcronym.setTagValue(spp,'organizationAcronym');
	self.organizationFullAddressText.setTagValue(spp,'organizationFullAddressText');
	self.organizationWebSiteURL.repr().setTagValue(spp,'organizationWebSiteURL');
	self.organizationRoleDescriptionText.setTagValue(spp,'organizationRoleDescriptionText');
	self.organizationRoleDetailedDescriptionText.setTagValue(spp,'organizationRoleDetailedDescriptionText');
	self.organizationPointOfContact->forEach(organizationPointOfContact){
		organizationPointOfContact.contactPersonName.setTagValue(spp,'contactPersonName');
		organizationPointOfContact.contactPersonEmailID.setTagValue(spp,'contactPersonEmailID');
		organizationPointOfContact.contactPersonPhoneNumberID.setTagValue(spp,'contactPersonPhoneNumberID');
		organizationPointOfContact.contactPersonAddress.setTagValue(spp,'contactPersonAddress');
	};	
}
*/
/*
mapping 	METADATA::BusinessContextType::BusinessContextType(inout serviceSubject:UML::Collaboration):UML::Component@pimUml
{
	// get the serviceIdentification and put into stereotype tags
	name:=self.domainDescription.domainNameText;
	serviceSubject.getNearestPackage().packagedElement+=result;
	var role:UML::Property=new UML::Property();
	role.name:=result.name+".Role";
	role.type:=result;
	role.lower:=1;
	role.upper:=1;
	role.aggregation:=UML::AggregationKind::composite;
	role.visibility:=UML::VisibilityKind::public;
	serviceSubject.ownedAttribute+=role;
	var spp:Stdlib::Element=result.applyStereotype(graBusinessContextStereotype);
	// it is also a soaML participant
	result.applyStereotype(soamlParticipantStereotype);
	
	self.classifications.classification.setTagValue(spp,'classification');
	self.exchangePartnerTypes.exchangePartnerTypeDescriptionText.setTagValue(spp,'exchangePartnerTypeDescriptionText');
	self.endorsements.endorser.addTagValue(spp,'endorser');
	self.sponsors.sponsor.addTagValue(spp,'sponsor');
}
*/

mapping 	String::SecurityClassification(inout spp:UML::InstanceSpecification):UML::InstanceSpecification@pimUml
{
	spp.getNearestPackage().packagedElement+=result;
	name:=self;
	classifier+=SecurityClassificationClassifier;

	var slot:UML::Slot='ServiceSecurityClassification'.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('ServiceSecurityClassification',spp,result);
		};
	
	
}
mapping 	METADATA::BusinessContextType::BusinessContextType(inout spp:UML::InstanceSpecification):UML::InstanceSpecification@pimUml
{
	// get the serviceIdentification and put into stereotype tags
	spp.getNearestPackage().packagedElement+=result;
	name:=self.domainDescription.domainNameText;
	self.classifications.classification.setFeatureValue(spp,'Classification');
	classifier+=ParticipantClassifier;

	var slot:UML::Slot='ExchangePartner'.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	
	self.exchangePartnerTypes.exchangePartnerTypeDescriptionText.setFeatureValue(result,'OrganizationRoleDescriptionText');
	self.endorsements.endorser.addFeatureValue(spp,'Endoresements');
	self.sponsors.sponsor.addFeatureValue(spp,'Sponsors');
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('ExchangePartner',spp,result);
		};
	
}
/*
mapping 	METADATA::ServiceIdentificationType::ServiceIdentificationType(inout serviceSubject:UML::Collaboration,isPrimaryService:Boolean):UML::Component@pimUml
{
	// get the serviceIdentification and put into stereotype tags
	name:=self.serviceFullNameText->first();
	serviceSubject.getNearestPackage().packagedElement+=result;
	var role:UML::Property=new UML::Property();
	role.name:=result.name+".Role";
	role.type:=result;
	role.lower:=1;
	role.upper:=1;
//	role.aggregation:=if(isPrimaryService)then{UML::AggregationKind::composite}else{UML::AggregationKind::shared}endif;
	if(isPrimaryService)then{role.aggregation:=UML::AggregationKind::composite}else{role.aggregation:=UML::AggregationKind::shared}endif;
	role.visibility:=UML::VisibilityKind::public;
	serviceSubject.ownedAttribute+=role;
	var spp:Stdlib::Element=result.applyStereotype(graServiceIdentificationStereotype);
	// it is also a soaML participant
	result.applyStereotype(soamlParticipantStereotype);
	
	self.serviceFullNameText.addTagValue(spp,'serviceFullNameText');
	self.serviceID.addTagValue(spp,'serviceID');
	self.serviceURI.repr().addTagValue(spp,'serviceURI');
	self.serviceNameAbbreviationText.addTagValue(spp,'serviceNameAbbreviationText');
	// fixup names
	// for primary service, add port and serviceInterface
	if(isPrimaryService)then{result.map Port(isPrimaryService);}endif;
}
*/
mapping 	UML::Collaboration::ParticipantsPackage():UML::Package@pimUml
{
	self.getNearestPackage().packagedElement+=result;
	name:='Participants';
}
mapping 	UML::Collaboration::InterfacesPackage():UML::Package@pimUml
{
	self.getNearestPackage().packagedElement+=result;
	name:='Interfaces';
}
/*
mapping 	METADATA::ServiceIdentificationType::ServiceIdentificationType(inout spp:UML::InstanceSpecification,inout serviceSubject:UML::Collaboration,
	isPrimaryService:Boolean):UML::Component@pimUml
{
	// get the serviceIdentification and put into stereotype tags
	name:=self.serviceFullNameText->first();
	var participantsPackage:UML::Package=serviceSubject.map ParticipantsPackage();
//	serviceSubject.getNearestPackage().packagedElement+=result;
	participantsPackage.packagedElement+=result;
	var role:UML::Property=new UML::Property();
	role.name:=result.name+".Role";
	role.type:=result;
	role.lower:=1;
	role.upper:=1;
//	role.aggregation:=if(isPrimaryService)then{UML::AggregationKind::composite}else{UML::AggregationKind::shared}endif;
	if(isPrimaryService)then{role.aggregation:=UML::AggregationKind::composite;}else{role.aggregation:=UML::AggregationKind::shared;}endif;
	role.visibility:=UML::VisibilityKind::public;
	serviceSubject.ownedAttribute+=role;
	if(isPrimaryService)then{
		self.ServiceIdentificationTypePopulate(spp);
		result.map Port(isPrimaryService);
	}else{
		self.map ServiceIdentificationType(spp,result);
	}endif;
}
*/
helper 	METADATA::ServiceIdentificationType::ServiceIdentificationTypePopulate(inout spp:UML::InstanceSpecification)
{
	// get the serviceIdentification and put into stereotype tags
	spp.name:=self.serviceFullNameText->first();
	
	self.serviceFullNameText.addFeatureValue(spp,'ServiceFullNameText');
	self.serviceID.addFeatureValue(spp,'ServiceID');
	self.serviceURI.repr().addFeatureValue(spp,'ServiceURI');
	self.serviceNameAbbreviationText.addFeatureValue(spp,'ServiceNameAbbreviationText');
	return;
}
mapping 	METADATA::ServiceIdentificationType::ServiceIdentificationType(inout spp:UML::InstanceSpecification,
//		inout serviceSubject:UML::Component):UML::InstanceSpecification@pimUml
		inout serviceSubject:UML::Collaboration):UML::InstanceSpecification@pimUml
{
	// get the serviceIdentification and put into stereotype tags
	name:=self.serviceFullNameText->first();
	spp.getNearestPackage().packagedElement+=result;
	classifier+=ServiceIdentificationClassifier;

	var slot:UML::Slot='ServiceDependency'.getSlot(spp);
	var instanceValue:UML::InstanceValue=new UML::InstanceValue();
	slot.value+=instanceValue;
	instanceValue.instance:=result;
	self.ServiceIdentificationTypePopulate(result);
	// check for association
	slot.definingFeature
		->select(f|f.oclIsKindOf(UML::Property)).oclAsType(UML::Property).association->forEach(association){
			association.map AssociationInstance('ServiceDependency',spp,result);
		};
	
}

mapping 	inout UML::Component::Port(isPrimaryService:Boolean):UML::Port@pimUml
{
	// get the serviceIdentification and put into stereotype tags
	name:=self.name+".Port";
	self.ownedAttribute+=result;
	lower:=1;
	upper:=1;
//	aggregation:=if(isPrimaryService)then{UML::AggregationKind::composite}else{UML::AggregationKind::shared}endif;
	if(isPrimaryService)then{aggregation:=UML::AggregationKind::composite;}else{aggregation:=UML::AggregationKind::shared;}endif;
	visibility:=UML::VisibilityKind::public;
	type:=self.map ServiceInterface();
}
mapping 	inout UML::Component::ServiceInterface():UML::Class@pimUml
{
	// get the serviceIdentification and put into stereotype tags
	name:=self.name+".ServiceInterface";
	self.nestedClassifier+=result;
	//result.applyStereotype(soamlServiceInterfaceStereotype);
}

///////////////////////////////////////////iepd
mapping 	SPPCAT::IepdCatalogType::IepdCatalogType(inout pimComponent:UML::Collaboration):UML::Usage@pimUml
{
 //           <iepd-catalog href="artifacts/service model/information model/SAR/catalog.html">Suspicious Activity Report IEPD Catalog</iepd-catalog>
	// create a package/component for the iepd; create Usage to it and include name; use NIEM-UML to expand?
	//  however, we may want to do this via wsdl instead
	//  but: some of the wsdls reference schemas (ebxml, etc.) not in iepd
	var umlPackagePath:String=self.href.toRelativeSppLocation();
	var ownerPackage:UML::Package=umlPackagePath.getSppOwnerPackage(sppRootPackage);
	var fileTypePackage:UML::Component=null;
	
		var catalog:CAT::DocumentRoot=self.oclAsType(Stdlib::Element).getCatalogAtRelativeURI(self.href.replaceAll('\\\\','/')).oclAsType(CAT::DocumentRoot);
		log('getCatalogAt '+self.href+' = '+catalog.repr());
//if(false)then{		
		if(not(catalog.oclIsUndefined()))then{
			// and map it as catalog
			fileTypePackage:=catalog.mapAbstractCatalog(ownerPackage);
			if(not(fileTypePackage.oclIsUndefined()))then{
				ownerPackage.packagedElement+=fileTypePackage;
			}endif;
		}endif;
//}endif;		
	//  package should be parent of href item
	if((fileTypePackage=null))then{
		fileTypePackage:=new UML::Component();
		ownerPackage.packagedElement+=fileTypePackage;
		fileTypePackage.name:=umlPackagePath.toSppBaseName();
	}endif;
	supplier+=fileTypePackage;
	client+=pimComponent;
	name:=self.value;
	pimComponent.getNearestPackage().packagedElement+=result;
}
// reproduce logic in NIEMmpd2pim_run
helper CAT::DocumentRoot::mapAbstractCatalog(inout ownerPackage:UML::Package):UML::Component {
	documentRoot:= self;
    // set NIEM catalog        
	catalog:=documentRoot.catalog->asSequence()->first();
	// set pimRoot for NIEM; 
	// this
	pimRoot:=ownerPackage;
	mpdRootPackage:=pimRoot;
	//pimRoot.initializeProfileGlobals();// already done	
		gatherCatalogedSchemas(mpdRootPackage);
		// now fully expand schema content
		expandSchemaContent:=true;
		var schemaPackages:Set(UML::Package)=
			mpdRootPackage.allSubobjectsOfType(UML::Package).oclAsType(UML::Package)
			->select(p|p.isEditable() and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
			->asSet();
		log('expandSchemaContent from '+mpdRootPackage.qualifiedName+', schema count='+schemaPackages->size().repr());
		schemaPackages->sortedBy(p|p.name).expandSchemaContent();
		// schemaPackages may have changed during expandSchemaContent
		schemaPackages:=
			mpdRootPackage.allSubobjectsOfType(UML::Package).oclAsType(UML::Package)
			->select(p|p.isEditable() and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
			->asSet();
	// weed out property holders

		log('propertyHolder adjust');
		schemaPackages.ownedType
			->select(t|t.IsStereotypeApplied(NIEMPropertyHolderStereotype) or t.IsStereotypeApplied(NIEMInformationModelStereotype))
			.oclAsType(UML::Class).adjustPropertyHolders();
		
		log('remove propertyHolder temporary realizations');
		schemaPackages.ownedType
			->select(t|t.IsStereotypeApplied(NIEMPropertyHolderStereotype))
			.oclAsType(UML::Class).adjustPropertyHolderRealizations();
		return mpdComponent;
	}

//////////////////////////////////soap sample
mapping 	SPPCAT::SoapSampleType::SoapSampleType(inout pimComponent:UML::Collaboration):UML::Usage@pimUml
{
 //           <soap-sample href="sample/SIP/Service Interface 1/SSA-SARInformationMessage-SOAP.xml">SSA-SAR Information Message SOAP Sample</soap-sample>
	// create a package/instance for the xml; create Usage to it and include name
	var umlPackagePath:String=self.href.toRelativeSppLocation();
	var ownerPackage:UML::Package=umlPackagePath.getSppOwnerPackage(sppRootPackage);
	var fileTypePackage:UML::InstanceSpecification=null;
	/* no place for soap anymore
		var soap:SOAP::Soap=self.oclAsType(Stdlib::Element).getSoapAtRelativeURI(self.href).oclAsType(SOAP::Soap);
		log('getSoapAt '+self.href+' = '+soap.repr());
		if(not(soap.oclIsUndefined()))then{
			// and map it as soap
			fileTypePackage:=wsdl.mapAbstractSoap();
			if(fileTypePackage.oclIsUndefined())then{return null;}endif;
			ownerPackage.packagedElement+=fileTypePackage;
		}endif;
	*/	
	if((fileTypePackage=null))then{
		fileTypePackage:=new UML::InstanceSpecification();
		ownerPackage.packagedElement+=fileTypePackage;
		fileTypePackage.name:=umlPackagePath.toSppBaseName();
	}endif;
	supplier+=fileTypePackage;
	client+=pimComponent;
	name:=self.value;
	pimComponent.getNearestPackage().packagedElement+=result;
}

////////////////////////////////////////////wsdl
mapping 	SPPCAT::WsdlSchemaType::WsdlSchemaType(inout pimComponent:UML::Collaboration):UML::Usage@pimUml
{
	pimComponent.getNearestPackage().packagedElement+=result;
 //       <wsdl-schema href="schema\SIP\NotificationServiceInterface.wsdl">Notification Service Schema</wsdl-schema>
	// create a package/component Participant for the wsdl; create Usage to it and include name
	var umlPackagePath:String=self.href.toRelativeSppLocation();
	//log('WsdlSchemaType '+self.href);
	//log('WsdlSchemaType '+umlPackagePath+', '+self.href);
	var ownerPackage:UML::Package=umlPackagePath.getSppOwnerPackage(sppRootPackage);
//	var fileTypePackage:UML::Component=null;
	var fileTypePackage:UML::Artifact=null;
		var wsdl:WSDL::Definition=self.oclAsType(Stdlib::Element).getWsdlAtRelativeURI(self.href).oclAsType(WSDL::Definition);
		log('getWsdlAt '+self.href+' = '+wsdl.repr());
		if(not(wsdl.oclIsUndefined()))then{
			// and map it as wsdl
			fileTypePackage:=wsdl.map Definition(ownerPackage);
		}endif;
	if((fileTypePackage=null))then{
		//fileTypePackage:=self.map FileTypePackage(ownerPackage);
		fileTypePackage:=new UML::Artifact();
		ownerPackage.packagedElement+=fileTypePackage;
		fileTypePackage.name:=umlPackagePath.toSppBaseName();
	}endif;
	supplier+=fileTypePackage;
	client+=pimComponent;
	name:=self.value;
}

/*
query XSD::XSDSchema::XSDSchema():UML::Package{
	return self.map SppXSDSchema();
}
mapping 	XSD::XSDSchema::SppXSDSchema_init():UML::Package@pimUml 
	inherits XSD::XSDSchema::XSDSchema
{
	init{
	var ownerPackage:UML::Package=self.relativeSppLocation().getOwnerPackage(mpdRootPackage);
	ownerPackage.packagedElement+=result;
	}
}
mapping 	XSD::XSDSchema::SppXSDSchema():UML::Package@pimUml 
	inherits XSD::XSDSchema::SppXSDSchema_init
	when{self.isMapped()}
{
	///////////////////
		var pimNdrSchemaInstance:Stdlib::Element=result.applyNIEMSchemaStereotype();
		log("informationModel "+pimNdrSchemaInstance.repr());
		// set version, conformant, purpose
		pimNdrSchemaInstance.setSchemaAppinfoConformantIndicator(self.appinfoConformantIndicator());
		// version is required; if undefined from source, then force a default value; part of Issue 18361: PSM Representation for XSD Complex Type 
		//pimNdrSchemaInstance.setSchemaVersion(self.version);
		var version:String=self.version;
		if(version.oclIsUndefined())then{version:="1";}endif;
		pimNdrSchemaInstance.setSchemaVersion(version);
		
		pimNdrSchemaInstance.setSchemaNamespace(self.targetNamespace);
	
		self.setModelInformationDefaultPurpose(null,pimNdrSchemaInstance);
		//////////////
	}
*/
////////////////////////////////////////////bpmn  - no hooks from catalog
////////////////////////////////////////////ebxml  - how are these referenced?
