import GRAcommon;// common GRA operations
import NIEMmpdmodel2artifact;// NIEM 2.1 UML QVT
import NIEMpsm2xsd;// NIEM 2.1 UML QVT
import NIEMpim2psm;// NIEM 2.1 UML QVT
modeltype UML uses 'http://www.omg.org/spec/UML/20110701';// UML metamodel

modeltype XSD  uses 'http://www.eclipse.org/xsd/2002/XSD';// implicit metamodel for Schemas, namespace ala MOF XMI Specification

modeltype GRAA uses 'http://ijis.org/GRA/Annotations';// GRA Annotation metamodel
modeltype GRAW uses 'http://ijis.org/GRA/WSDLAnnotations';// GRA WSDL Annotation metamodel

transformation GraSspModel2artifact (in uml:UML,in schemaForProxy:XSD,
	out graa:GRAA)
	;
main() {
	GraSspModel2artifact_run();// run the transformation: initialize globals and start mapping uml to annotations.xmi
}	
property graRoot:UML::Model=null;// the root of the UML Model
property sppCatalogUml:UML::InstanceSpecification=null;// the UML InstanceSpecification representing instantiation of the SSP Catalog
property theServiceCollaboration:UML::Collaboration=null;// the UML Collaboration representing the service collaboration
property gatherAllGraSchemas:Set(UML::Package)=Set{};// collection of all <<InformationModel>>Packages referenced by this SSP

property gatherAllPimSchemas:Set(UML::Package)=Set{};// collection of all IEPD-contained UML <<InformationModel>>Packages referenced by this SSP
	
helper GraSspModel2artifact_run() {
	// initialize global containing schema for proxy
	umlSchemaForProxy:=schemaForProxy.objectsOfType(XSD::XSDSchema)->asSequence()->first();
	// initialize the Schema for Schemas
	umlSchemaForSchema:=umlSchemaForProxy.schemaForSchema;
	// graRoot is the root UML Model within the model resource
	graRoot:=
			uml.rootObjects()
			->select(r|r.oclIsKindOf(UML::Model)).oclAsType(UML::Model)
			->asSequence()->first();
    log('GRA uml model root '+graRoot.repr());    

	graRoot.initializeProfileGlobals();	// initialize global values for all profiles
	// locate the uml spp catalog and map it to target catalog
	graRoot.allSubobjectsOfKind(UML::Package).oclAsType(UML::Package).packagedElement
		->select(e|e.isGraCatalog()).oclAsType(UML::InstanceSpecification) // select InstanceSpecification which represents the GRA Catalog
		->forEach(sppCatalog){
			sppCatalogUml:=sppCatalog;// save the InstanceSpecification as a global during this transformation
			sppCatalog.iepdCatalog().IepdCatalogType();// gather and record all schemas references by NIEM IEPD Catalogs
			
			var serviceDescription:GRAA::ServiceDescription=sppCatalog.map GRA_WSDL();// create annotation xmi based on sppCatalog
			sppCatalog.GRA_WSDL(serviceDescription);// populate content of annotation xmi
		};	 
	return;
	}
// the UML Element represents a GRA Classifier if it is an InstanceSpecification instantiation of a ServiceDescription Classifier	
query UML::Element::isGraCatalog():Boolean=
	self.oclIsKindOf(UML::InstanceSpecification) 
	and 
	self.oclAsType(UML::InstanceSpecification).classifier->exists(c|c.name='ServiceDescription');
	 
// various specialized navigations across realizations from client to supplier, specialized by type of supplier	
// Realizations for which the context is a client 
query UML::NamedElement::clientRealization():Sequence(UML::Realization)=
	self.clientDependency->select(s|s.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization)->asSequence();
// Collaborations which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedCollaboration():Sequence(UML::Collaboration)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Collaboration)).oclAsType(UML::Collaboration)->asSequence();
// NamedElements which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedNamedElement():Sequence(UML::NamedElement)=
	self.clientRealization().supplier->select(s|s.oclIsKindOf(UML::NamedElement)).oclAsType(UML::NamedElement)->asSequence();
// Packages which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedPackage():Sequence(UML::Package)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Package)).oclAsType(UML::Package)->asSequence();
// UseCases which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedUseCase():Sequence(UML::UseCase)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::UseCase)).oclAsType(UML::UseCase)->asSequence();
// Components which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedComponent():Sequence(UML::Component)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Component)).oclAsType(UML::Component)->asSequence();
// Ports which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedPort():Sequence(UML::Port)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Port)).oclAsType(UML::Port)->asSequence();
// Parameters which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedParameter():Sequence(UML::Parameter)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Parameter)).oclAsType(UML::Parameter)->asSequence();
// TypedElements which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedTypedElement():Sequence(UML::TypedElement)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::TypedElement)).oclAsType(UML::TypedElement)->asSequence();
// BehavioralFeatures which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedBehavioralFeature():Sequence(UML::BehavioralFeature)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::BehavioralFeature)).oclAsType(UML::BehavioralFeature)->asSequence();
// Interfaces which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedInterface():Sequence(UML::Interface)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Interface)).oclAsType(UML::Interface)->asSequence();
// Actors which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedActor():Sequence(UML::Actor)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSequence();
// Interactions which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedInteraction():Sequence(UML::Interaction)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Interaction)).oclAsType(UML::Interaction)->asSequence();
// Types which are the supplier of a Realization   for which the context is a client  
query UML::NamedElement::realizedType():Sequence(UML::Type)=
	self.realizedNamedElement()->select(s|s.oclIsKindOf(UML::Type)).oclAsType(UML::Type)->asSequence();
// is a wsdl component if it matches the pattern of owning ports with provided interfaces	
query UML::Type::isWsdlComponent():Boolean=
	self.oclIsKindOf(UML::Component)
	and
	self.oclAsType(UML::Component).ownedPort->exists(p|p.provided->notEmpty());
// navigate from a ServiceDescription Instance, to its realized Collaboration, to owned attributes whose types are wsdl components	
query UML::InstanceSpecification::wsdlInterfaceSchema():Sequence(UML::Property)=
	self.realizedCollaboration().ownedAttribute->select(a|a.type.isWsdlComponent())
	->asSequence();
// same as wsdlInterfaceSchema	
query UML::InstanceSpecification::wsdlSchema():Sequence(UML::Property)=
	self.wsdlInterfaceSchema();
// navigate from a 	ServiceDescription Instance to the Usage whose supplier is an MPD Catalog
query UML::InstanceSpecification::iepdCatalog():Sequence(UML::Usage)=
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).oclAsType(UML::Usage)
		->select(d|d.supplier->forAll(s|s.isStereotypeApplied(prompdStereotype)))->asSequence();
// get Realizations for which this context is the supplier		
query UML::NamedElement::supplierRealization():Sequence(UML::Realization)=
	self.getTargetDirectedRelationships()->select(d|d.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization)->asSequence();
// get InstanceSpecification which instantiates a Classifier named "artifactName" 
// and which is the client of a Realization for which this context is the supplier 	
query UML::NamedElement::realizingInstance(artifactName:String):Sequence(InstanceSpecification)=
	self.supplierRealization().client
		->select(d|d.oclIsKindOf(UML::InstanceSpecification) 
			and d.oclAsType(UML::InstanceSpecification).classifier->exists(c|c.name=artifactName))
			.oclAsType(UML::InstanceSpecification)->asSequence();
// get InstanceSpecification which is the client of a Realization for which this context is the supplier 	
query UML::NamedElement::realizingInstance():Sequence(InstanceSpecification)=
	self.supplierRealization().client
		->select(d|d.oclIsKindOf(UML::InstanceSpecification)).oclAsType(UML::InstanceSpecification);
// for given <<ModelPackageDescription>> Component, initialize global variable 'gatherAllPinSchemas' to transitive closure of all <<InformationModel>>s directly or indirectly referenced by this MPD
helper  UML::Component::gatherAllPimSchemas():Set(UML::Package){
	gatherAllPimSchemas:=Set{};
	self.getPimInformationModels().gatherAllPimSchemas();	
	return 	gatherAllPimSchemas;
	}
// for given <<ModelPackageDescription>> component, return set of all <<InformationModel>>s (logically) referenced via <<ModelPackageDescriptionFile>> 	
query UML::Component::getPimInformationModels():Set(UML::Package)=
		self.elementImport.importedElement.oclAsType(UML::NamedElement)->asSet()
		->union(self.clientDependency.supplier->select(p|p.oclIsKindOf(UML::Package))
		// tjd added nested filesets
		->union(self.packagedElement.clientDependency.supplier->select(p|p.oclIsKindOf(UML::Package)))
		->select(c|c.IsStereotypeApplied(NIEMInformationModelStereotype))
		->asSet())
		.oclAsType(UML::Package)
		->asSet();
// for given <<InformationModel>> Package, accumulate transitive closure of all referenced <<InformationModel>>s into 'gatherAllPimSchemas' global variable	
helper  UML::Package::gatherAllPimSchemas(){
	if(gatherAllPimSchemas->includes(self))then{return;}endif;
        if(self.name=XMLPrimitiveTypesPackageName)then{return ;}endif;
        if(self.name=UMLPrimitiveTypesPackageName)then{return ;}endif;
	
		gatherAllPimSchemas+=self;
		self.ownedType
			->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier)
			->forEach(c){
				// pick up general, property types
               c.general.getPimClassifier(self).getNearestNIEMSchemaPackage().gatherAllPimSchemas();
               c.attribute
               	->select(a|
               		not(a.type.oclIsUndefined()) 
               		and a.type.oclIsKindOf(UML::Classifier)
               		).type.oclAsType(UML::Classifier)
               	.getPimClassifier(self).getNearestNIEMSchemaPackage().gatherAllPimSchemas();
                                
			};
	return;
	}
// for given context, get nearest owner in containment hierarchy that is a <<InformationModel>>, <<Namespace>>, the XML Primitive Type library, or UML Primitive Type library	
query UML::Element::getNearestNIEMSchemaPackage():UML::Package{
    var schemaPackage:UML::Package=self.getNearestPackage();
    if(schemaPackage.IsStereotypeApplied(NIEMSchemaStereotype) or schemaPackage.IsStereotypeApplied(NIEMInformationModelStereotype)) then {return schemaPackage;} endif;
        if(schemaPackage.name=XMLPrimitiveTypesPackageName)then{return schemaPackage;}endif;
        if(schemaPackage.name=UMLPrimitiveTypesPackageName)then{return schemaPackage;}endif;

    var nestingPackage:UML::Package=schemaPackage.nestingPackage;
    if(nestingPackage.oclIsUndefined())then{return null;}endif;
    return nestingPackage.getNearestNIEMSchemaPackage();
}
// is ServiceIdentification if context is a Component which provides some interface via owned ports
query UML::Element::isServiceIdentification():Boolean=
	self.oclIsKindOf(UML::Component) and self.oclAsType(UML::Component).ownedPort->exists(p|p.provided->notEmpty())
	;

/////////////////////////////////////////Annotations
// queries to extract various types of value(s) from an instanceSpecification, based on name of feature
// get first string value for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getStringValue(featureName:String):String=
	self.getStringValues(featureName)->first();
// get all string values for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getStringValues(featureName:String):Sequence(String)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralString).value->asSequence();
// get first integer value for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getIntegerValue(featureName:String):Integer=
	self.getIntegerValues(featureName)->first();
// get all integer values for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getIntegerValues(featureName:String):Sequence(Integer)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralInteger).value->asSequence();
// get first boolean value for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getBooleanValue(featureName:String):Boolean=
	self.getBooleanValues(featureName)->first();
// get all boolean values for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getBooleanValues(featureName:String):Sequence(Boolean)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralBoolean).value->asSequence();
// get first instance value for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getInstanceValue(featureName:String):UML::InstanceSpecification=
	self.getInstanceValues(featureName)->first();
// get all instance values for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getInstanceValues(featureName:String):Sequence(UML::InstanceSpecification)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::InstanceValue).instance->asSequence();
// get default instance values for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getDefaultInstanceValues(featureName:String):Sequence(UML::InstanceSpecification)=
	self.getInstanceValues(featureName)// include default whether or not it realizes anything
	;
// get first real value for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getRealValue(featureName:String):Real=
	self.getRealValues(featureName)->first();
// get all real values for feature 'featureName' in context of IstanceSpecification
query UML::InstanceSpecification::getRealValues(featureName:String):Sequence(Real)=
	self.slot->select(s|s.definingFeature.name=featureName).value.oclAsType(UML::LiteralReal).value->asSequence();
// set properties of GraServiceAnnotationBase; common logic for various mappings inheriting from GraServiceAnnotationBase	
helper 	UML::InstanceSpecification::GRAServiceAnnotationBase(modeledElement:UML::NamedElement,inout base:GRAA::GraServiceAnnotationBase){
	base.template:=self.getStringValue('Template');
	base.flag+=self.getStringValues('Flag');
	//  derived
		base.name:=self.name;
		base.documentation:=self.ownedComment.body->asSequence()->first();
	var realizedElement:UML::NamedElement=modeledElement;
	if(realizedElement.oclIsUndefined())then{
		realizedElement:=self.realizedNamedElement()->asSequence()->first();
	}endif;
	if(base.name.oclIsUndefined()or(base.name=''))then{
		base.name:=realizedElement.name;
	}endif;
	if(base.documentation.oclIsUndefined())then{
		base.documentation:=realizedElement.ownedComment.body->asSequence()->first();
	}endif;
	
	base.modelReference:=realizedElement.mapModelReference()->asSequence()->first();
	base.requirement:=self.getInstanceValue('Requirement').map InteractionRequirements();
	return;
}
// common mapping logic for GraServiceAnnotationBase	
mapping 	UML::InstanceSpecification::GRAServiceAnnotationBase():GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	self.GRAServiceAnnotationBase(null,result);
}
// common mapping logic for GraServiceAnnotationBase when subtype defines defaults
mapping 	UML::InstanceSpecification::GRAServiceAnnotationBaseDefault(modeledElement:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	self.GRAServiceAnnotationBase(modeledElement,result);
}
// common mapping logic for GraServiceAnnotationBase when subtype needs uniqueness context
mapping 	UML::InstanceSpecification::GRAServiceAnnotationBaseDefaultAnnotationContext(context:UML::NamedElement):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	self.GRAServiceAnnotationBase(null,result);
}
// common mapping logic for GraServiceAnnotationBase when subtype defines defaults and needs uniqueness context
mapping 	UML::InstanceSpecification::GRAServiceAnnotationBaseDefaultContext(modeledElement:UML::NamedElement,context:UML::NamedElement,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	self.GRAServiceAnnotationBase(modeledElement,result);
}
// create a ModelReference for given UML NamedElement context
helper 	UML::NamedElement::mapModelReference():GRAA::ModelReference 
{
	var modelReference:GRAA::ModelReference=new GRAA::ModelReference@graa();
	modelReference.name:=self.name;
	modelReference.documentation:=self.ownedComment.body->asSequence()->first();
	modelReference.elementId:=self.getURIFragment();// via blackbox
	// TODO: diagramLink
	//diagramLink+=self.getStringValues('DiagramLink');
	modelReference.model:=self.mapModel();
	return modelReference;
}

// create a GRA Model for given UML NamedElement context
	helper 	UML::NamedElement::mapModel():GRAA::Model 
{
	var model:GRAA::Model=new GRAA::Model@graa();
	model.modelUri:=self.getRelativeURI();// via blackbox
	model.label:=self.emofContextURI();// via blackbox
	return model;
}	
// map a InstanceSpecification of a 'Requirement' to InteractionRequirements and populate its content
mapping 	UML::InstanceSpecification::InteractionRequirements():GRAA::InteractionRequirements@graa 
{

	serviceConsumerAuthentication:=self.getBooleanValue('ServiceConsumerAuthentication');
	serviceConsumerAuthorization:=self.getBooleanValue('ServiceConsumerAutorization');
	identityAndAttributeAssertionTransmission:=self.getBooleanValue('IdentityAndAttributeAssertionTransmission');
	serviceAuthentication:=self.getBooleanValue('ServiceAuthentication');
	messageNonrepudiation:=self.getBooleanValue('MessageNonrepudiation');
	messageIntegrity:=self.getBooleanValue('MessageIntegrity');
	messageConfidentiality:=self.getBooleanValue('MessageConfidentiality');
	messageAddressing:=self.getBooleanValue('MessageAddressing');
	reliability:=self.getBooleanValue('Reliability');
	transactionSupport:=self.getBooleanValue('TransactionSupport');
	serviceMetadataAvailability:=self.getBooleanValue('ServiceMetadataAvailability');
	interfaceDescriptionRequirements:=self.getBooleanValue('InterfaceDescriptionRequirements');
	logging:=self.getBooleanValue('Logging');
//	otherRequirement+=self.getStringValues('OtherRequirement');
	extendedRequirement+=self.getStringValues('ExtendedRequirement');
	serviceResponsiveness:=self.getBooleanValue('ServiceResponsiveness');
}	
// map a subtype of ServiceIdentification mapping, or an InstanceSpecification of a 'ServiceDependency', to ServiceIdentification and populate its content
mapping 	UML::InstanceSpecification::ServiceIdentification():GRAA::ServiceIdentification@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{

	serviceId:=self.getStringValue('ServiceID');
	serviceUri:=self.getStringValue('ServiceURI');
	serviceNameAbbreviationText:=self.getStringValue('ServiceNameAbbreviationText');
	if(result.serviceNameAbbreviationText.oclIsUndefined())then{
			diagnostics+='ERROR: no ServiceNameAbbreviationText';
		serviceNameAbbreviationText:='UNK(ServiceIdentification.ServiceNameAbbreviationText undefined)';
	}endif;
	if(result.serviceUri.oclIsUndefined())then{
			diagnostics+='ERROR: no ServiceURI';
		serviceUri:='http://unknown(ServiceIdentification.ServiceURI undefined)';
	}endif;
}	
// map a InstanceSpecification corresponding to SSP Catalog to InteractionRequirements 
mapping 	UML::InstanceSpecification::GRA_WSDL():GRAA::ServiceDescription@graa
	inherits UML::InstanceSpecification::ServiceIdentification 
{
}	
// populate the content of a previously created ServiceDescription
helper 	UML::InstanceSpecification::GRA_WSDL(inout serviceDescription:GRAA::ServiceDescription):GRAA::ServiceDescription
{
	serviceDescription.classification+=self.getStringValues('Classification');
	serviceDescription.sponsor+=self.getStringValues('Sponsor');
	serviceDescription.serviceDescriptionSummaryText:=self.getStringValue('ServiceDescriptionSummaryText');
	serviceDescription.serviceDescriptionKeywordText+=self.getStringValues('ServiceDescriptionKeywordText');
	serviceDescription.domainDescription:=self.getStringValue('DomainDescription');
	serviceDescription.endorsements+=self.getStringValues('Endorsements');
	serviceDescription.transformationUri:=self.getStringValue('TransformationURI');
	serviceDescription.majorVersion:=self.getIntegerValue('MajorVersion');
	serviceDescription.minorVersion:=self.getIntegerValue('MinorVersion');
	serviceDescription.revisionVersion:=self.getIntegerValue('RevisionVersion');
	serviceDescription.creationDate:=self.getStringValue('CreationDate');
	serviceDescription.activationDate:=self.getStringValue('ActivationDate');
	serviceDescription.lastRevisionDate:=self.getStringValue('LastRevisionDate');
	serviceDescription.nextRevisionDate:=self.getStringValue('NextRevisionDate');
	serviceDescription.expirationDate:=self.getStringValue('ExpirationDate');
	serviceDescription.lifecycleStatus:=self.getStringValue('LifecycleStatus');
	serviceDescription.alertAndNotificationUri:=self.getStringValue('AlertAndNotificationURI');

	// exchangePartner	
	var exchangePartnerInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('ExchangePartner')->asSet();
	
	var collaboration:UML::Collaboration=self.realizedCollaboration()->first();
	var partners:Set(UML::Actor)=exchangePartnerInstances.realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSet();
	exchangePartnerInstances->select(i|i.realizedPackage()->isEmpty()).realizedActor()->forEach(partner){partners+=partner;};
	collaboration.role.type->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->forEach(partner){partners+=partner;};
	partners->forEach(partner){
		serviceDescription.exchangePartner+=partner.mapParticipant(partner);
	};
	serviceDescription.servicePurpose:=self.getInstanceValue('ServicePurpose').map Description(self);
	serviceDescription.serviceScopeDescription:=self.getInstanceValue('ServiceScopeDescription').map Description(self);
	serviceDescription.serviceCapability+=self.getInstanceValues('ServiceCapability').map ServiceCapability();
	serviceDescription.serviceDependency+=self.getInstanceValues('ServiceDependency').map ServiceIdentification();
	self.clientDependency->select(d|d.oclIsKindOf(UML::Usage)).supplier->select(s|s.isStereotypeApplied(prompdStereotype)).oclAsType(UML::Component)->forEach(mpd){
		serviceDescription.iepdReference+=mpd.map IEPDReference();
	};
	serviceDescription.serviceSecurityClassification:=self.getInstanceValue('ServiceSecurityClassification').map SecurityClassification();
	serviceDescription.serviceLevelAgreement+=self.getInstanceValues('ServiceLevelAgreement').map ServiceLevelAgreement(serviceDescription);
	serviceDescription.relatedOrganization+=self.getInstanceValues('RelatedOrganization').map Organization();
	serviceDescription.serviceInterface+=self.getInstanceValues('ServiceInterface').map AbstractServiceInterfaceSpecification();
	serviceDescription.realWorldEffect+=self.getInstanceValues('RealWorldEffect').realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::UseCase)).oclAsType(UML::UseCase).map ImplicitUseCase(self);
	serviceDescription.realWorldEffect+=self.getInstanceValues('RealWorldEffect')->select(i|i.realizedPackage()->isEmpty()).map UseCase();

	var modeledServiceInteractions:Set(UML::Interaction)=collaboration.ownedBehavior->select(t|t.oclIsKindOf(UML::Interaction)).oclAsType(UML::Interaction)->asSet();
		modeledServiceInteractions
			->forEach(modeledProvider){
			serviceDescription.serviceInteraction+=modeledProvider.map ServiceInteraction(collaboration);
		};
	serviceDescription.additionalInformation:=self.getInstanceValues('AdditionalInformation').map Description(self);
	serviceDescription.executionContext:=self.getInstanceValue('ExecutionContext').map Description(self);
	serviceDescription.security:=self.getInstanceValue('Security').map Description(self);
	serviceDescription.privacy:=self.getInstanceValue('Privacy').map Description(self);
	serviceDescription.serviceAssumption:=self.getInstanceValue('ServiceAssumption').map Description(self);
	serviceDescription.otherRequirement:=self.getInstanceValue('OtherRequirement').map Description(self);
	serviceDescription.dataProvenance:=self.getInstanceValue('DataProvenance').map Description(self);
	serviceDescription.processModel:=self.getInstanceValue('ProcessModel').map Description(self);
	return serviceDescription;
}
// create an IepdReference for a <<ModelPackageDescription>> Component	
mapping 	UML::Component::IEPDReference():GRAA::IepdReference@graa 
{
	// derived
	var pimmpd:Stdlib::Element=self.GetStereotypeApplication(prompdStereotype).oclAsType(Stdlib::Element);
	var baseURI:String=pimmpd.getMpdBaseURI();
	var iEPDURL:String=baseURI;
	var iEPDName:String=baseURI.getLastSegmentGRA();
	name:=iEPDName;
	iepdurl:=iEPDURL;
}
// in context of a Usage of an IEPD Catalog, add transitive closure of all <<InformationModel>> packages referenced by that IEPD to global 'gatherAllGraSchemas'
 helper UML::Usage::IepdCatalogType()
{
	// accumulate schemas for use during element/type resolution
	self.supplier->select(p|p.oclIsKindOf(UML::Component)).oclAsType(UML::Component)
		->forEach(iepd){gatherAllGraSchemas+=iepd.gatherAllPimSchemas();};
	// iepd catalog constructed in a separate process via NIEM 2.1 UML QVT
}
	
// map InstanceSpecification instantiation of 'SecurityClassification' to SecurityClassification
mapping 	UML::InstanceSpecification::SecurityClassification():GRAA::SecurityClassification@graa 
{
	// derived
		name:=self.name;
}	
// map InstanceSpecification instantiation of 'ServiceCapability' to ServiceCapability
mapping 	UML::InstanceSpecification::ServiceCapability():GRAA::ServiceCapability@graa 
{
	// derived
	documentation:=self.ownedComment.body->asSequence()->first();
}	
// map InstanceSpecification instantiation of 'Description' to Description
mapping 	UML::InstanceSpecification::Description(context:UML::NamedElement):GRAA::Description@graa 
{
	externalDocumentation:=self.getStringValue('ExternalDocumentation');

	// derived
	documentation:=self.ownedComment.body->asSequence()->first();
}	
// map InstanceSpecification instantiation of 'ServiceLevelAgreement' to ServiceLevelAgreement
mapping 	UML::InstanceSpecification::ServiceLevelAgreement(inout diagnosticContext:GRAA::ServiceDescription):GRAA::ServiceLevelAgreement@graa 
{
	approvalRequiredIndicator:=self.getBooleanValue('ApprovalRequiredIndicator');
	licensingRequiredIndicator:=self.getBooleanValue('LicensingRequiredIndicator');
	serviceResponseTime:=self.getStringValue('ServiceResponseTime');
	serviceAverageThroughput:=self.getStringValue('ServiceAverageThroughput');
	serviceMaximumThroughput:=self.getStringValue('ServiceMaximumThroughput');
	serviceAvailability:=self.getStringValue('ServiceAvailability');
	
	umbrellaAgreement+=self.getInstanceValues('UmbrellaAgreement').map Agreement();
	agreement+=self.getInstanceValues('Agreement').map Agreement();
	applicableContract+=self.getInstanceValues('ApplicableContract').map Agreement();
	licensingAgreement:=self.getInstanceValue('LicensingAgreement').map Agreement();
	applicablePolicy+=self.getInstanceValues('ApplicablePolicy').map Agreement();
	
	usageUnitCostAmount:=self.getStringValue('UsageUnitCostAmount');
	creationCostAmount:=self.getStringValue('CreationCostAmount');
	usageCostAmount:=self.getStringValue('UsageCostAmount');
	applicablePoliciesIndicator:=result.applicablePolicy->notEmpty();
	applicableContractsIndicator:=result.applicableContract->notEmpty();
	applicableAgreementsIndicator:=result.agreement->notEmpty();
	applicableUmbrellaAgreementsIndicator:=result.umbrellaAgreement->notEmpty();
}	
// map InstanceSpecification instantiation of 'ServiceInterfaceSpecification' to ServiceInterfaceSpecification
mapping 	UML::InstanceSpecification::AbstractServiceInterfaceSpecification():GRAA::ServiceInterfaceSpecification@graa 
	disjuncts 
		 UML::InstanceSpecification::ServiceInterfaceSpecification
		 {}
// map InstanceSpecification instantiation of 'ServiceInterfaceSpecification' to ServiceInterfaceSpecification
mapping 	UML::InstanceSpecification::ServiceInterfaceSpecification():GRAA::ServiceInterfaceSpecification@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	init{}
	securityImplementedIndicator:=self.getBooleanValue('SecurityImplementedIndicator');
	securityDescriptionText:=self.getStringValue('SecurityDescriptionText');

	targetNamespace:=self.getStringValue('TargetNamespace');
	serviceInterfaceNameAbbreviationText:=self.getStringValue('ServiceInterfaceNameAbbreviationText');
		if(result.serviceInterfaceNameAbbreviationText.oclIsUndefined()or (result.serviceInterfaceNameAbbreviationText=''))then{
			prefix:='prefix';
			diagnostics+='ERROR: no ServiceInterfaceNameAbbreviationText';
	
		}else{
			prefix:=result.serviceInterfaceNameAbbreviationText;
		}	endif;

	messageDefinitionMechanism+=self.getInstanceValues('MessageDefinitionMechanism').map Description(self);
	serviceTesting:=self.getInstanceValue('ServiceTesting').map Description(self);
	physicalModel:=self.getInstanceValue('PhysicalModel').map Description(self);
	serviceInteractionProfile:=self.getInstanceValue('ServiceInteractionProfile').map ServiceInteractionProfile();
	var portDefaults:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('PortDefault');
	var interfaceDefaults:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('InterfaceDefault');
	var operationDefaults:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('OperationDefault');
	var parameterDefaults:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('ParameterDefault');
	var messageDefaults:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('MessageDefault');
	service+=self.getInstanceValues('Service').map AbstractService(null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	// derived
	// the wsdlProperty is the property in the collaboration whose type is a component realized by provider instance
	var theServiceComponent:UML::Component=self.getInstanceValues('Service').realizedComponent()->asSequence()->first();
	var wsdlProperty:UML::Property=	theServiceCollaboration.ownedAttribute
		->select(a|a.type.isServiceIdentification()and(a.type=theServiceComponent))->asSequence()->first();
	
	// get all referenced schemas, both type and element refs
	var schemas:Set(UML::Package)=Set{};
	theServiceComponent.ownedPort.provided.allBehavioralFeatures()->forEach(feature){
		var behavioralFeature:UML::BehavioralFeature=feature.oclAsType(UML::BehavioralFeature);
		// collect both type and element references	
			// use an element (property whose type is messagetype): either 
			feature.raisedException.messagePartElements().getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
				->forEach(p){schemas+=p;};
			if(feature.oclIsKindOf(UML::Reception))then{
				feature.oclAsType(UML::Reception).signal.ownedAttribute.messagePartElements().getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
					->forEach(p){schemas+=p;};
			}else{
				feature.ownedParameter.messagePartElements().getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
					->forEach(p){schemas+=p;};
			}endif;
			
			feature.raisedException.getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
				->forEach(p){schemas+=p;};
			if(feature.oclIsKindOf(UML::Reception))then{
				feature.oclAsType(UML::Reception).signal.ownedAttribute.type.getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
					->forEach(p){schemas+=p;};
			}else{
				feature.ownedParameter.type.getNearestPackage()
				->select(p|not(p.oclIsUndefined()) and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
					->forEach(p){schemas+=p;};
			}endif;
		
	};		
			
	
	schemas->forEach(schema){
		schemaReference+=schema.map SchemaReference(self,result);
	};
}	
// compute the relative path from the ssp catalog to the context <<InformationModel>> Package (schema) based on location of <<ModelPackageDescription>> Component (MPD Catalog)
query UML::Package::sspSchemaRelativePath(mpdcatalog:UML::Component):String{
	var catalog:UML::Package:=mpdcatalog.getNearestPackage();
	var relativePath:String='';
	if(catalog.oclIsUndefined())then{
		relativePath:=self.qualifiedName;
	}else{
		// this form probably never occurs
		var targetPath:String=mpdcatalog.name+self.qualifiedName.substringAfter(catalog.qualifiedName);
		if(targetPath.oclIsUndefined())then{
			// probably best path is simply path with two top levels removed
			targetPath:=mpdcatalog.name+'::'+self.qualifiedName.substringAfter('::').substringAfter('::');
		}endif;
		relativePath:='artifacts::service model::information model::'+targetPath;
		
	}endif;
	relativePath:=relativePath.replace('::','/');
	if(relativePath='')then {relativePath:='./';}endif;
	if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
	return relativePath;	
}
// map <<InformationModel>> Package to SchemaReference
mapping 	UML::Package::SchemaReference(context:UML::NamedElement,inout diagnosticsContext:GRAA::ServiceInterfaceSpecification):GRAA::SchemaReference@graa 
{
	
	var pimStereotypeInstance:Stdlib::Element=self.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=self.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
	namespace:=pimStereotypeInstance.getSchemaTargetNamespace();
	if(namespace.oclIsUndefined())then{
			diagnosticsContext.diagnostics+='ERROR: information model has no targetNamespace';
		namespace:='NoSchemaTargetNamespaceInInformationModel';
	}endif;
	// set prefix to be used for Schema namespace
	prefix:=pimStereotypeInstance.getSsspSchemaDefaultPrefix();
	if(result.prefix.oclIsUndefined()or (result.prefix=''))then{
			diagnosticsContext.diagnostics+='WARNING: information model has no default prefix';
		prefix:=self.name;
	}endif;

	// schemaLocation
	var mpdcatalog:UML::Component:=sppCatalogUml.clientDependency.supplier->select(c|c.oclIsKindOf(UML::Component)).oclAsType(UML::Component)->asSequence()->first();
	var relativePath:String=self.sspSchemaRelativePath(mpdcatalog);	
	schemaLocation:=relativePath;
	
}
// for given <<InformationModel>> Stereotype application, compute the default prefix, which may be defined in <<InformationModel>> tag value
//  in the case of reference schemas, lookup the prefix to be used if it is not explicitly defined
query  Stdlib::Element::getSsspSchemaDefaultPrefix():String { 
	// if namespace has standard prefix defined, use it
    var prefix:String= self.getSchemaDefaultPrefix();
    if(prefix.oclIsUndefined())then{
		var targetNamespace:String=self.getSchemaTargetNamespace();
		prefixToNamespace->forEach(entry){
			if(entry.namespace=targetNamespace)then{
				prefix:=entry.prefix;
			}endif;
		};
    }endif;
    return prefix;
}

// map InstanceSpecification instantiation of 'Organization' to Organization
	mapping 	UML::InstanceSpecification::Organization():GRAA::Organization@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	organizationAcronym:=self.getStringValue('OrganizationAcronym');
	organizationFullAddressText:=self.getStringValue('OrganizationFullAddressText');
	organizationWebSiteUrl:=self.getStringValue('OrganizationWebSiteURL');
	organizationRoleDescriptionText:=self.getStringValue('OrganizationRoleDescriptionText');
	if(organizationRoleDescriptionText.oclIsUndefined())then{
			diagnostics+='ERROR: No Organization Role';
		organizationRoleDescriptionText:='No Organization Role';
	}endif;
	organizationRoleDetailedDescriptionText:=self.getStringValue('OrganizationRoleDetailedDescriptionText');
	organizationPointOfContact:=self.getInstanceValue('OrganizationPointOfContact').map Person();
}	
// map InstanceSpecification instantiation of 'Person' to Person
	mapping 	UML::InstanceSpecification::Person():GRAA::Person@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	contactPersonEmailId:=self.getStringValue('ContactPersonEmailID');
	contactPersonPhoneNumberId:=self.getStringValue('ContactPersonPhoneNumberID');
	contactPersonAddress:=self.getStringValue('ContactPersonAddress');
}	
// common logic for setting content of a participant in the context of a mapping from InstanceSpecification instantiation of a Participant
helper 	UML::InstanceSpecification::inheritsGRAServiceAnnotationBase(inout participant:GRAA::Participant):GRAA::GraServiceAnnotationBase 
{
	participant.template:=self.getStringValue('Template');
	participant.flag+=self.getStringValues('Flag');
	//  derived
		participant.name:=self.name;
		participant.documentation:=self.ownedComment.body->asSequence()->first();
	var realizedElement:UML::NamedElement=self.realizedNamedElement()->asSequence()->first();
	if(participant.name.oclIsUndefined()or(participant.name=''))then{
		participant.name:=realizedElement.name;
	}endif;
	if(participant.documentation.oclIsUndefined())then{
		participant.documentation:=realizedElement.ownedComment.body->asSequence()->first();
	}endif;
	
	participant.modelReference:=realizedElement.mapModelReference()->asSequence()->first();
	participant.requirement:=self.getInstanceValue('Requirement').map InteractionRequirements();
	return participant;
}
// common logic for setting content of a participant in the context of a mapping from InstanceSpecification instantiation of a Participant
helper UML::InstanceSpecification::inheritsGRAServiceAnnotationBaseDefaultAnnotationContext(context:UML::NamedElement,inout participant:GRAA::Participant):GRAA::GraServiceAnnotationBase 
{
	//init{}
	participant.template:=self.getStringValue('Template');
	participant.flag+=self.getStringValues('Flag');
	//  derived
		participant.name:=self.name;
		participant.documentation:=self.ownedComment.body->asSequence()->first();
	var realizedElement:UML::NamedElement=self.realizedNamedElement()->asSequence()->first();
	if(participant.name.oclIsUndefined() or(participant.name=''))then{
		participant.name:=realizedElement.name;
	}endif;
	if(participant.documentation.oclIsUndefined())then{
		participant.documentation:=realizedElement.ownedComment.body->asSequence()->first();
	}endif;
	
	participant.modelReference:=realizedElement.mapModelReference()->asSequence()->first();
	participant.requirement:=self.getInstanceValue('Requirement').map InteractionRequirements();
	return participant;
}
// common logic for setting content of a participant in the context of a mapping from InstanceSpecification instantiation of a Participant
helper 	UML::NamedElement::inheritsImplicitGRAServiceAnnotationBaseSimple(context:UML::NamedElement,inout participant:GRAA::Participant):GRAA::GraServiceAnnotationBase 
{
	//  derived
	participant.name:=self.name;
	participant.documentation:=self.ownedComment.body->asSequence()->first();
	participant.modelReference:=self.mapModelReference();
	return participant;
}	


// common logic for setting content of a participant in the context of a mapping from InstanceSpecification instantiation of a Participant
	helper 	UML::InstanceSpecification::mapParticipant():GRAA::Participant 
{
	var participant:GRAA::Participant=new GRAA::Participant@graa();
	self.inheritsGRAServiceAnnotationBase(participant);
	participant.participatingOrganization:=self.getInstanceValue('ParticipatingOrganization').map Organization();
	participant.generalization:=self.getInstanceValues('Generalization').mapParticipant(self);
	return participant;
}

// common logic for setting content of a participant in the context of a mapping from InstanceSpecification instantiation of a Participant
	helper 	UML::InstanceSpecification::mapParticipant(inout context:UML::NamedElement):GRAA::Participant 
{
	var participant:GRAA::Participant=new GRAA::Participant@graa();
	self.inheritsGRAServiceAnnotationBaseDefaultAnnotationContext(context,participant);
	participant.participatingOrganization:=self.getInstanceValue('ParticipatingOrganization').map Organization();
	participant.generalization:=self.getInstanceValues('Generalization').mapParticipant(self);
	return participant;
}

// common logic for setting content of a participant in the context of a mapping from InstanceSpecification instantiation of a Participant
	helper 	UML::Actor::mapParticipant(inout context:UML::NamedElement):GRAA::Participant 
{
	var participant:GRAA::Participant=new GRAA::Participant@graa();
	self.inheritsImplicitGRAServiceAnnotationBaseSimple(context,participant);
	// empty
	participant.generalization:=self.general->select(g|g.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor).mapParticipant(self);
	return participant;
}

// map a UML UseCase to GRA UseCase for a unique context
	mapping 	UML::UseCase::ImplicitUseCase(context:UML::NamedElement):GRAA::UseCase@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple
	
{
	//  derived

	var modeledProviders:Set(UML::Actor)= self.getProviderActors()->asSet();
	var modeledConsumers:Set(UML::Actor)= self.getConsumerActors()->asSet();
	modeledProviders->forEach(modeledProvider){
		provider+=modeledProvider.mapParticipant(self);
	};
	modeledConsumers->forEach(modeledProvider){
		consumer+=modeledProvider.mapParticipant(self);
	};
	
}	
		
// map a UML UseCase to GRA UseCase 
	mapping 	UML::InstanceSpecification::UseCase():GRAA::UseCase@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBase 
	
{
	var providerInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('Provider')->asSet();
	var consumerInstances:Set(UML::InstanceSpecification)=self.getInstanceValues('Consumer')->asSet();
	//  derived
	var useCases:Set(UML::UseCase)=self.realizedPackage().packagedElement->select(p|p.oclIsKindOf(UML::UseCase)).oclAsType(UML::UseCase)->asSet();
	provider+=providerInstances.mapParticipant();
	consumer+=consumerInstances.mapParticipant();

	var realizedProviders:Set(UML::Actor)= providerInstances.realizedActor()->asSet();
	var realizedConsumers:Set(UML::Actor)= consumerInstances.realizedActor()->asSet();
	var modeledProviders:Set(UML::Actor)= useCases.getProviderActors()->asSet();
	var modeledConsumers:Set(UML::Actor)= useCases.getConsumerActors()->asSet();
	
	modeledProviders->select(p|not(realizedProviders->includes(p)))->forEach(modeledProvider){
		provider+=modeledProvider.mapParticipant(modeledProvider);
	};
	modeledConsumers->select(p|not(realizedConsumers->includes(p)))->forEach(modeledProvider){
		consumer+=modeledProvider.mapParticipant(modeledProvider);
	};
	
}	
// returns set of <<Provider>> Associations which are relationships for the given Element context
query UML::Element::getProviderAssociation():Set(UML::Association){
	return self.getRelationships()
		->select(t|t.oclIsKindOf(UML::Association) and t.getAppliedStereotypes().name->exists(n|n='Provider')).oclAsType(UML::Association)->asSet();
}
// returns set of <<Consumer>> Associations which are relationships for the given Element context
query UML::Element::getConsumerAssociation():Set(UML::Association){
	return self.getRelationships()
		->select(t|t.oclIsKindOf(UML::Association) and t.getAppliedStereotypes().name->exists(n|n='Consumer')).oclAsType(UML::Association)->asSet();
}
	
// returns set of Actors which have <<Provider>> Associations with the given UML UseCase
query UML::UseCase::getProviderActors():Set(UML::Actor){
	return self.getProviderAssociation().ownedEnd.type->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSet();
}
// returns set of Actors which have <<Consumer>> Associations with the given UML UseCase
query UML::UseCase::getConsumerActors():Set(UML::Actor){
	return self.getConsumerAssociation().ownedEnd.type->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSet();
}
// map a UML Interaction to a GRA ServiceInteraction using a given context for uniqueness
mapping 	UML::Interaction::ServiceInteraction(context:UML::NamedElement):GRAA::ServiceInteraction@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple 
{
	var typeTests:Set(UML::Type)=self.lifeline.represents.type->asSet();
	var types:Set(UML::Actor)=typeTests->select(t|t.oclIsKindOf(UML::Actor)).oclAsType(UML::Actor)->asSet();
	types+=typeTests->select(t|not(t.oclIsKindOf(UML::Actor))).realizedActor();
	types->forEach(type){
		participant+=type.mapParticipant(type);
	};
}	

// map a UML InstanceSpecification instantiating a 'Service' to GRA Service
mapping 	UML::InstanceSpecification::AbstractService(modeledComponent:UML::Component,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Service@graa 
	disjuncts 
		 UML::InstanceSpecification::Service
		 {}
// map a UML InstanceSpecification instantiating a 'Service' to GRA Service
mapping 	UML::InstanceSpecification::Service(modeledComponent:UML::Component,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Service@graa 
	//inherits UML::InstanceSpecification::ParticipantDefault 
{

	var interfaceDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('InterfaceDefault');
	var operationDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('OperationDefault');
	var parameterDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('ParameterDefault');
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('MessageDefault');

	var interfaceDefaultsy:Sequence(UML::InstanceSpecification)=interfaceDefaults;
	var operationDefaultsy:Sequence(UML::InstanceSpecification)=operationDefaults;
	var parameterDefaultsy:Sequence(UML::InstanceSpecification)=parameterDefaults;
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(interfaceDefaultsx->notEmpty())then{interfaceDefaultsy:=interfaceDefaultsx;}endif;
	if(operationDefaultsx->notEmpty())then{operationDefaultsy:=operationDefaultsx;}endif;
	if(parameterDefaultsx->notEmpty())then{parameterDefaultsy:=parameterDefaultsx;}endif;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;

	
	// add explicitly modeled port instances; if not modeled, add implicit ports
	var portInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Port')->asSet();
	// uml Ports realized by the explicit port instances
	var portsRealized:Set(UML::Port)= portInstances.realizedPort()->asSet();
	var serviceComponent:UML::Component=self.realizedComponent()->first();
	if(not(modeledComponent.oclIsUndefined()))then{
		serviceComponent:=modeledComponent;
	}endif;
	// ports in uml model owned by the realized component
	var modeledPorts:Set(UML::Port)= serviceComponent.ownedPort;
	var allPortInstances:Set(UML::InstanceSpecification)= portInstances;
	allPortInstances+=portDefaults;
	// each explicitly modeled port instance mapped to AbstractPort
	// each port owned by realized component is mapped, if it was not already included in ports realized by instances
	modeledPorts->forEach(modeledPort){
		var targetPort:GRAA::Port=modeledPort.mapImplicitPort(modeledPort,allPortInstances->asSequence(),interfaceDefaultsy,operationDefaultsy,parameterDefaultsy,messageDefaultsy);
		if(not(targetPort.oclIsUndefined()))then{
			port+=targetPort;
		}endif;
	};
		//Plus SampleData, each with an optional Input and ExpectedOutput
	sampleData+=self.getInstanceValues('SampleData').map SampleData();
		serviceProvider:=serviceComponent.realizedActor().mapParticipant(self)->asSequence()->first();
}
// populate GraServiceAnnotationBase content for given UML NamedElement	
helper 	UML::NamedElement::ImplicitGRAServiceAnnotationBase(inout base:GRAA::GraServiceAnnotationBase) 
{
	if(self.name.oclIsUndefined() or (self.name=''))then{
		// special case:Reception may use signal name
		if(self.oclIsKindOf(UML::Reception))then{
			base.name:=self.oclAsType(UML::Reception).signal.name;
		}endif;
		if(base.name.oclIsUndefined() or (base.name=''))then{
			base.diagnostics+='ERROR: No name';
			base.name:='unNamed';
		}endif;	
	}else{
		base.name:=self.name;
	}endif;
	base.documentation:=self.ownedComment.body->asSequence()->first();
	base.modelReference:=self.mapModelReference();
	return;
}	
// map given UML NamedElement to GraServiceAnnotationBase content with unique context	
mapping 	UML::NamedElement::ImplicitGRAServiceAnnotationBaseSimple(context:UML::NamedElement):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	self.ImplicitGRAServiceAnnotationBase(result);
}	
// map given UML NamedElement to GraServiceAnnotationBase content with unique context and defaults	
mapping 	UML::NamedElement::ImplicitGRAServiceAnnotationBase(context:UML::NamedElement,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::GraServiceAnnotationBase@graa 
{
	init{}
	self.ImplicitGRAServiceAnnotationBase(result);
}
// map context UML Port to a GRA Port given unique context and defaults; 
//  use a matching portDefault or concrete port instance to map to an Abstract Port, otherwise map to Implicit Port	
helper 	UML::Port::mapImplicitPort(context:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port{
	// find instance which is WSDLPort or Port
	// if none, check defaults
	// if none, do implicitPorte
	var resultOperation:GRAA::Port=null;
	// check portDefaults, if default realizes this port, map it
	portDefaults->select(p|p.realizedPort()->exists(rp|self=rp))->forEach(wsdlPort){
		return wsdlPort.map AbstractPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// otherwise, try to map an unrealized default
	portDefaults->select(p|p.realizedPort()->isEmpty())->forEach(wsdlPort){
		return wsdlPort.map AbstractPort(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// general defaults not supported --back track, need to have default here
	// if we get this far, model does not have qualifying port instance, so map implicitly
	return self.map ImplicitPort(self,null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
} 
// general defaults not supported - backtrack,
//	implicit mapping for port when no qualying port instance defined
mapping 	UML::Port::ImplicitPort(context:UML::NamedElement,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
	interface+=self.provided.mapImplicitInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=self.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			diagnostics+='WARNING: UML Port has no name';
			name:=self.type.name;
		}endif;
	}endif;
	//addressUri:='http://'+result.name; // another cardinality change
}	
// map a concrete port instantiation or a default Port applied to a modeled port to a GRA Port, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::AbstractPort(modeledPort:UML::Port,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port@graa 
	disjuncts 
		 UML::InstanceSpecification::Port
		 {}
// map a concrete port instantiation or a default Port applied to a modeled port to a GRA Port, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::Port(modeledPort:UML::Port,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Port@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{
	
	var operationDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('OperationDefault');
	var parameterDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('ParameterDefault');
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('MessageDefault');
	
	var operationDefaultsy:Sequence(UML::InstanceSpecification)=operationDefaults;
	var parameterDefaultsy:Sequence(UML::InstanceSpecification)=parameterDefaults;
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(operationDefaultsx->notEmpty())then{operationDefaultsy:=operationDefaultsx;}endif;
	if(parameterDefaultsx->notEmpty())then{parameterDefaultsy:=parameterDefaultsx;}endif;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;
	
	
	addressUri:=self.getStringValue('AddressURI');
	// add explicitly modeled interfaces; if not modeled, add implicit interfaces
	var interfaceInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Interface')->asSet();
	var interfacesRealized:Set(UML::Interface)= interfaceInstances.realizedInterface()->asSet();
	var servicePorts:Set(UML::Port)=self.realizedPort()->asSet();
	if(not(modeledPort.oclIsUndefined()))then{
		servicePorts:=Set{modeledPort};
	}endif;
	
	var modeledInterfaces:Set(UML::Interface)= servicePorts.provided->asSet();
	var allInterfaceInstances:Set(UML::InstanceSpecification)= interfaceInstances;
	allInterfaceInstances+=interfaceDefaults;
	modeledInterfaces->forEach(modeledInterface){
		var targetInterface:GRAA::Interface=modeledInterface.mapImplicitInterface(modeledPort,portDefaults,allInterfaceInstances->asSequence(),operationDefaultsy,parameterDefaultsy,messageDefaultsy);
		if(not(targetInterface.oclIsUndefined()))then{
			interface+=targetInterface;
		}endif;
	};
	
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=servicePorts.name->asSequence()->first();
		if(result.name.oclIsUndefined() or (result.name=''))then{
			diagnostics+='WARNING: no port name';
			name:=servicePorts.type.name->asSequence()->first();
		}endif;
	}endif;
}	
// map context UML Interface to a GRA Interface given unique context and defaults; 
//  use a matching interfaceDefault or concrete Interface instance to map to an Abstract Interface, otherwise map to Implicit Interface	
helper 	UML::Interface::mapImplicitInterface(context:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface{
	// find instance which is WSDLInterface or Interface
	// if none, check defaults
	// if none, do implicitInterface
	var resultOperation:GRAA::Interface=null;
	// check InterfaceDefaults, if default realizes this port, map it
	interfaceDefaults->select(p|p.realizedInterface()->exists(rp|self=rp))->forEach(operationDefault){
		return operationDefault.map AbstractInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// otherwise, try to map an unrealized default
	interfaceDefaults->select(p|p.realizedInterface()->isEmpty())->forEach(operationDefault){
		return operationDefault.map AbstractInterface(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// general defaults not supported - backtrack
	// if we get this far, then no qualifying interface instance, so we must make implicit interface
	return self.map ImplicitInterface(context,null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
} 
//	implicit mapping for Interface when no qualying Interface instance defined
mapping 	UML::Interface::ImplicitInterface(context:UML::NamedElement,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
	self.allBehavioralFeatures()->forEach(behavioralFeature){
		operation+=behavioralFeature.mapImplicitOperation(behavioralFeature,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
}	
// map a concrete Interface instantiation or a default Interface applied to a modeled Interface to a GRA Interface, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::AbstractInterface(modeledInterface:UML::Interface,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface@graa 
	disjuncts UML::InstanceSpecification::WSDLInterface,
		 UML::InstanceSpecification::Interface
		 {}
// map a concrete Interface instantiation or a default Interface applied to a modeled Interface to a GRA Interface, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::WSDLInterface(modeledInterface:UML::Interface,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlInterface@graa 
	inherits UML::InstanceSpecification::Interface
	when{self.classifier.name->asSet()->includes('WSDLInterface')}
{
		var bindingName:String=self.getInstanceValue('BindingCode').name;
		switch{
			case(bindingName='soap'){
				bindingCode:=GRAW::BindingType::soap;
			};	
			case(bindingName='soap12'){
				bindingCode:=GRAW::BindingType::soap12;
			};	
			case(bindingName='http_get'){
				bindingCode:=GRAW::BindingType::httpGet;
			};	
			case(bindingName='http_put'){
				bindingCode:=GRAW::BindingType::httpPut;
			};	
		};
	
}
// map a concrete Interface instantiation or a default Interface applied to a modeled Interface to a GRA Interface, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::Interface(modeledInterface:UML::Interface,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Interface@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{

	var parameterDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('ParameterDefault');
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('MessageDefault');
	var parameterDefaultsy:Sequence(UML::InstanceSpecification)=parameterDefaults;
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(parameterDefaultsx->notEmpty())then{parameterDefaultsy:=parameterDefaultsx;}endif;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;
	
	// add explicitly modeled operations; if not modeled, add implicit operations
	var operationInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Operation')->asSet();
	var operationsRealized:Set(UML::BehavioralFeature)= operationInstances.realizedBehavioralFeature()->asSet();
	var serviceInterfaces:Set(UML::Interface)=self.realizedInterface()->asSet();
	if(not(modeledInterface.oclIsUndefined()))then{
		serviceInterfaces:=Set{modeledInterface};
	}endif;
	var modeledOperations:Set(UML::BehavioralFeature)= serviceInterfaces.allBehavioralFeatures()->asSet();
	var allOperationInstances:Set(UML::InstanceSpecification)= operationInstances;
	allOperationInstances+=operationDefaults;
	modeledOperations->forEach(modeledOperation){
		var targetOperation:GRAA::Operation=modeledOperation.mapImplicitOperation(modeledOperation,portDefaults,interfaceDefaults,allOperationInstances->asSequence(),parameterDefaults,messageDefaults);
		if(not(targetOperation.oclIsUndefined()))then{
			operation+=targetOperation;
		}endif;
	};
	
}	
// map a UML BehavioralFeature to a GRA Operation
// determine if modeled behavioral feature maps to explicit Operation default, or unmapped Operation Default, or implicit Operation 
helper 	UML::BehavioralFeature::mapImplicitOperation(context:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation{
	// find instance which is WSDLOperation or Operation
	// if none, check defaults
	// if none, do implicitOperation
	var resultOperation:GRAA::Operation=null;
	
	// check InterfaceDefaults, if default realizes this port, map it
	operationDefaults->select(p|p.realizedBehavioralFeature()->exists(rp|self=rp))->forEach(operationDefault){
		return operationDefault.map AbstractOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// otherwise, try to map an unrealized default
	operationDefaults->select(p|p.realizedBehavioralFeature()->isEmpty())->forEach(operationDefault){
		return operationDefault.map AbstractOperation(context,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// general defaults not supported - backtract
	// if we get this far, no qualifying operation instance so we must implicitly create the operation instance
	return self.map ImplicitOperation(context,null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
} 

//	implicit mapping for BehavioralFeature when no qualying Operation instance defined
mapping 	UML::BehavioralFeature::ImplicitOperation(context:UML::NamedElement,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
	actionName:=self.name;
	parameter+=self.raisedException.mapImplicitParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	if(self.oclIsKindOf(UML::Reception))then{
		parameter+=self.oclAsType(UML::Reception).signal.ownedAttribute.mapImplicitParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
		if(result.name.oclIsUndefined()or (result.name=''))then{
			name:=self.oclAsType(UML::Reception).signal.name;
		}endif;
		if(result.actionName.oclIsUndefined()or (result.actionName=''))then{
			actionName:=self.oclAsType(UML::Reception).signal.name;
		}endif;
	}else{
		parameter+=self.ownedParameter.mapImplicitParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	}endif;
	isAsynchronous:=self.oclIsKindOf(UML::Reception);
	actionPurpose:=self.ownedComment.body->asSequence()->first();
}

// map a concrete BehavioralFeature instantiation or a default BehavioralFeature applied to a modeled BehavioralFeature to a GRA Operation, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::AbstractOperation(modeledOperation:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation@graa 
	disjuncts UML::InstanceSpecification::WSDLOperation,
		 UML::InstanceSpecification::Operation
		 {}
// map a concrete WSDLOperation instantiation or a default WSDLOperation applied to a modeled BehavioralFeature to a GRA WSDLOperation, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::WSDLOperation(modeledOperation:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlOperation@graa 
	inherits UML::InstanceSpecification::Operation
	when{self.classifier.name->asSet()->includes('WSDLOperation')}
{
		var kindName:String=self.getInstanceValue('OperationKindCode').name;
		switch{
			case(kindName='doc'){
				operationKindCode:=GRAW::OperationKind::doc;
			};	
			case(kindName='rpc'){
				operationKindCode:=GRAW::OperationKind::rpc;
			};	
		};
}

	
// map a concrete Operation instantiation or a default Operation applied to a modeled BehavioralFeature to a GRA Operation, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::Operation(modeledOperation:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Operation@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{
	var messageDefaultsx:Sequence(UML::InstanceSpecification)=self.getDefaultInstanceValues('MessageDefault');
	var messageDefaultsy:Sequence(UML::InstanceSpecification)=messageDefaults;
	if(messageDefaultsx->notEmpty())then{messageDefaultsy:=messageDefaultsx;}endif;
	// add explicitly modeled messages; if not modeled, add implicit messages
	var parameterInstances:Set(UML::InstanceSpecification)= self.getInstanceValues('Parameter')->asSet();
	var parametersRealized:Set(UML::TypedElement)= parameterInstances.realizedTypedElement()->asSet();
	var serviceOperations:Set(UML::BehavioralFeature)=self.realizedBehavioralFeature()->asSet();
	if(not(modeledOperation.oclIsUndefined()))then{
		serviceOperations:=Set{modeledOperation};
	}endif;
		actionName:=serviceOperations.name->asSequence()->first();
	var modeledMessages:Set(UML::TypedElement)= Set{};
	
	if(modeledOperation.oclIsKindOf(UML::Reception))then{
		modeledMessages+=modeledOperation.oclAsType(UML::Reception).signal.ownedAttribute;
		if(result.name.oclIsUndefined()or (result.name=''))then{
			diagnostics+='WARNING: No (Name) as Reception name';
			name:=modeledOperation.oclAsType(UML::Reception).signal.name;
		}endif;
		if(result.actionName.oclIsUndefined()or (result.actionName=''))then{
			diagnostics+='WARNING: No (actionName) as Reception Name';
			actionName:=modeledOperation.oclAsType(UML::Reception).signal.name;
		}endif;
	}else{
		modeledMessages+=modeledOperation.ownedParameter;
	}endif;
	var allParameterInstances:Set(UML::InstanceSpecification)= parameterInstances;
	allParameterInstances+=parameterDefaults;
	
	modeledMessages->forEach(modeledMessage){
		var targetParameter:GRAA::Parameter=modeledMessage.mapImplicitParameter(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,allParameterInstances->asSequence(),messageDefaultsy);
		if(not(targetParameter.oclIsUndefined()))then{
			parameter+=targetParameter;
		}endif;
	};
	
	// exceptions
	serviceOperations.raisedException->forEach(modeledMessage){
		var targetParameter:GRAA::Parameter=modeledMessage.mapImplicitParameter(modeledOperation,portDefaults,interfaceDefaults,operationDefaults,allParameterInstances->asSequence(),messageDefaultsy);
		if(not(targetParameter.oclIsUndefined()))then{
			parameter+=targetParameter;
		}endif;
		
	};
	
		var messageExchangePatternName:String=self.getInstanceValue('MessageExchangePattern').name;
		switch{
			case(messageExchangePatternName='enquiry'){
				messageExchangePattern:=GRAA::ExchangePattern::enquiry;
			};	
			case(messageExchangePatternName='subscription'){
				messageExchangePattern:=GRAA::ExchangePattern::subscription;
			};	
			case(messageExchangePatternName='notification'){
				messageExchangePattern:=GRAA::ExchangePattern::notification;
			};	
			case(messageExchangePatternName='update'){
				messageExchangePattern:=GRAA::ExchangePattern::update;
			};	
			case(messageExchangePatternName='message'){
				messageExchangePattern:=GRAA::ExchangePattern::message;
			};	
		};
	actionProvenance:=self.getStringValue('ActionProvenance');
	
	// derived
		isAsynchronous:=serviceOperations->exists(p|p.oclIsKindOf(UML::Reception));
		actionPurpose:=serviceOperations.ownedComment.body->asSequence()->first();
}
// map an InstanceSpecification 'SampleData' instantiation to GRA SampleData
mapping 	UML::InstanceSpecification::SampleData():GRAA::SampleData@graa 
{
	// Input, ExpectedOutput
	input+=self.getStringValues('Input');
	expectedOutput:=self.getStringValue('ExpectedOutput');
}	
// map a UML NamedElement to a GRA Parameter
// determine if modeled namedElement maps to explicit Parameter default, or unmapped Parameter Default, or implicit Parameter 
helper 	UML::NamedElement::mapImplicitParameter(context:UML::BehavioralFeature,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter{
	// find instance which is WSDLParameter or Parameter
	// if none, check defaults
	// if none, do ImplicitParameter
	var resultOperation:GRAA::Parameter=null;
	// check parameterDefaults, if default realizes this parameter, map it
	parameterDefaults->select(p|p.realizedNamedElement()->exists(rp|self=rp))->forEach(operationDefault){
		return operationDefault.map AbstractParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// otherwise, try to map an unrealized default
	parameterDefaults->select(p|p.realizedNamedElement()->isEmpty())->forEach(operationDefault){
		return operationDefault.map AbstractParameter(self,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// general defaults not supported - backtract
	// if we get this far, then there are no qualifying parameter instances, so we must create one implicitly
	return self.map ImplicitParameter(context,null,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
} 

//	implicit mapping for BehavioralFeature when no qualying Operation instance defined
mapping 	UML::NamedElement::ImplicitParameter(context:UML::BehavioralFeature,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
	var messagetype:UML::Type=null;
	var partElement:UML::TypedElement=null;
//	var messagetype:UML::NamedElement=null;
	if(self.oclIsKindOf(UML::TypedElement))then{
		messagetype:=self.oclAsType(UML::TypedElement).type;		
	}else{
		if(self.oclIsKindOf(UML::Type))then{	
				messagetype:=self.oclAsType(UML::Type);
		}endif;
	}endif;
	// either a type or an element, depending upon whether style is document or rpc
	partElement:=self.messagePartElement();
	if(self.oclIsKindOf(UML::Parameter))then{	
		//  derived
		switch{
			case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_out){
				use:=graAnnotationModel::ParameterUse::_out;
			};
			case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_inout){
				use:=graAnnotationModel::ParameterUse::_out;
			};
			case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_return){
				use:=graAnnotationModel::ParameterUse::_out;
			};
			else{
				use:=graAnnotationModel::ParameterUse::_in;
			};
		};
	}else{
		if(self.oclIsKindOf(UML::Type))then{	
			//  derived
			use:=graAnnotationModel::ParameterUse::_exception;
		}else{
			use:=graAnnotationModel::ParameterUse::_in;
		}endif;
	}endif;

	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=self.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			name:=messagetype.name;
		}endif;
	}endif;
	message:=messagetype.mapImplicitMessage(self,partElement,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
}
// locate a plausible Property (mapping to XSD Element) which types the context Type
query UML::NamedElement::messagePartElement():UML::Property{
	return self.messagePartElements()->asSequence()->first();
}
// locate all plausible Properties (mapping to XSD Element) which types the context Type
query UML::NamedElement::messagePartElements():Set(UML::Property){
	// context is a typedElement (or a Type in case of Exception)
	var properties:Set(UML::Property)=Set{};
		if(self.oclIsKindOf(UML::Type))then{	
			// exception, find referencing property
				var modeledType:UML::Type=self.oclAsType(UML::Type);
				// no realization, check if there is an exchange which defines such a property
				modeledType.getReferencingTypedElements()
					->select(t|t.oclIsKindOf(UML::Property)).oclAsType(UML::Property)->forEach(typedElement){
						properties+= typedElement;
					};
				// otherwise just find any informationModel defining such a property	
		}else{
			// typedElement: resolve via realization or some exchange property holder
			if(self.oclIsKindOf(UML::TypedElement))then{	
				var modeledType:UML::Type=self.oclAsType(UML::TypedElement).type;
				// no realization, check if there is an exchange which defines such a property
				modeledType.getReferencingTypedElements()
					->select(t|t.oclIsKindOf(UML::Property)).oclAsType(UML::Property)->forEach(typedElement){
						properties+= typedElement;
					};
				// otherwise just find any informationModel defining such a property	
	
			}else{
				// could not resolve
			}endif;
		}endif;
	return properties;// all properties satisfying condition
}
// the typedElements which have as their type the context UML Type
query UML::Type::getReferencingTypedElements():Set(UML::TypedElement)=
	gatherAllGraSchemas.ownedType->select(e|e.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier).attribute
		->select(a|a.type=self)->asSet();
		
		
// map a concrete InstanceSpecification instantiation of 'Parameter' or a default Parameter applied to a modeled Parameter, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::AbstractParameter(modeledMessage:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter@graa 
	disjuncts UML::InstanceSpecification::WSDLParameter,
		 UML::InstanceSpecification::Parameter
		 {}
// map a concrete InstanceSpecification instantiation of 'WSDLParameter' or a default WSDLParameter applied to a modeled Parameter, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::WSDLParameter(modeledMessage:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlParameter@graa 
	inherits UML::InstanceSpecification::Parameter
	when{self.classifier.name->asSet()->includes('WSDLParameter')}
{
	mimeType:=self.getStringValue('MimeType');

}
// map a concrete InstanceSpecification instantiation of 'Parameter' or a default Parameter applied to a modeled Parameter, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::Parameter(modeledParameter:UML::NamedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Parameter@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefault 
{
	var parameterRealized:UML::TypedElement= self.realizedTypedElement()->asSequence()->first();
	if(modeledParameter.oclIsUndefined())then{
		
	}else{
		if(modeledParameter.oclIsKindOf(UML::TypedElement))then{
			parameterRealized:=modeledParameter.oclAsType(UML::TypedElement);
		}endif;
	}endif;
	parameterRealized->forEach(parameter){
		//  derived
		if(parameter.oclIsKindOf(UML::Parameter))then{	
			switch{
				case(parameter.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_out){
					use:=graAnnotationModel::ParameterUse::_out;
				};
				case(parameter.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_inout){
					use:=graAnnotationModel::ParameterUse::_inout;
				};
				case(self.oclAsType(UML::Parameter).direction=UML::ParameterDirectionKind::_return){
					use:=graAnnotationModel::ParameterUse::_out;
				};
				else{
					use:=graAnnotationModel::ParameterUse::_in;
				};
			};
		}else{
					use:=graAnnotationModel::ParameterUse::_in;
		}	endif;
	};
	var parametertype:UML::Type=parameterRealized.type;
	var elementPart:UML::TypedElement=null;
	if(not(parametertype.oclIsUndefined()))then{
		elementPart:=parametertype.messagePartElement();
	}endif;
	// either a type or an element, depending upon whether style is document or rpc
	// exceptions; self will represent the exception type
	var typeRealized:UML::Type= self.realizedType()->asSequence()->first();
	if(not(typeRealized.oclIsUndefined()))then{
		parametertype:=typeRealized;
		if(modeledParameter.oclIsUndefined())then{
			
		}else{
			if(modeledParameter.oclIsKindOf(UML::Type))then{
				parametertype:=modeledParameter.oclAsType(UML::Type);
			}endif;
		}endif;
		elementPart:=parametertype.messagePartElement();
		use:=graAnnotationModel::ParameterUse::_exception;
	}endif;
	if(result.name.oclIsUndefined() or (result.name=''))then{
		name:=parameterRealized.name;
		if(result.name.oclIsUndefined() or (result.name=''))then{
			diagnostics+='ERROR: No parameter name';
			name:=parametertype.name;
		}endif;
	}endif;
	var messageInstances:UML::InstanceSpecification= self.getInstanceValue('Message');
	// if messageInstances is defined and either realizes the modeled parameter or has no realizations, then AbstractMessage; otherwise implicit message
	if(messageInstances.oclIsUndefined() 
		or 
		not(messageInstances.clientDependency->isEmpty() or messageInstances.clientDependency.supplier->includes(parameterRealized))
		)then{
		var targetMessage:GRAA::Message=parametertype.mapImplicitMessage(parameterRealized,elementPart,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
		if(not(targetMessage.oclIsUndefined()))then{
			message:=targetMessage;
		}endif;
		
	}else{
		message:=messageInstances.map AbstractMessage(parametertype,parameterRealized,elementPart,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	}endif;
	
	
	
}	

///////////////////////////////////////////////////////////////////////////////////////////////////
// map a UML Type to a GRA Message
// determine if modeled Type maps to explicit Message default, or unmapped Message Default, or implicit Message 
	
helper 	UML::Type::mapImplicitMessage(context:UML::NamedElement,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message{
	// find instance which is WSDLOperation or Operation
	// if none, check defaults
	// if none, do implicitOperation
	var resultOperation:GRAA::Message=null;
	// check InterfaceDefaults, if default realizes this port, map it
	messageDefaults->select(p|p.realizedNamedElement()->exists(rp|self=rp))->forEach(wsdlMessage){
		return wsdlMessage.map AbstractMessage(self,context,elementPart,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// otherwise, try to map an unrealized default
	messageDefaults->select(p|p.realizedNamedElement()->isEmpty())->forEach(wsdlMessage){
		return wsdlMessage.map AbstractMessage(self,context,elementPart,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
	};
	// general defaults not supported - backtrack
	// if we get this far, then no qualifying message instance in model, so we must implicitly create one

	// we either use type or element, depending upon context;  if we need element backtrack via context

	return self.map ImplicitMessage(context,elementPart,portDefaults,interfaceDefaults,operationDefaults,parameterDefaults,messageDefaults);
} 
//	implicit mapping for Type when no qualying Message instance defined
mapping 	UML::NamedElement::ImplicitMessage(context:UML::NamedElement,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message@graa 
	inherits UML::NamedElement::ImplicitGRAServiceAnnotationBase 
{
//	var messagetype:UML::Type=self;
	var messagetype:UML::NamedElement=self;
	messagetype.Message(result,elementPart);
}
	
// map a concrete InstanceSpecification instantiation of 'Message' or a default Message applied to a modeled Message, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::AbstractMessage(modeledMessage:UML::NamedElement,context:UML::NamedElement,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message@graa 
	disjuncts UML::InstanceSpecification::WSDLMessage,
		 UML::InstanceSpecification::Message
		 {}
// map a concrete InstanceSpecification instantiation of 'WSDLMessage' or a default WSDLMessage applied to a modeled Message, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::WSDLMessage(modeledMessage:UML::NamedElement,context:UML::NamedElement,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAW::WsdlMessage@graa 
	inherits UML::InstanceSpecification::Message
	when{self.classifier.name->asSet()->includes('WSDLMessage')}
{
		var locationCodeName:String=self.getInstanceValue('MessageLocationCode').name;
		switch{
			case(locationCodeName='body'){
				messageLocationCode:=GRAW::MessageLocation::body;
			};	
			case(locationCodeName='header'){
				messageLocationCode:=GRAW::MessageLocation::header;
			};	
			case(locationCodeName='url'){
				messageLocationCode:=GRAW::MessageLocation::url;
			};	
		};

}
// map a concrete InstanceSpecification instantiation of 'Message' or a default Message applied to a modeled Message, assemble and propagate defaults 
mapping 	UML::InstanceSpecification::Message(modeledMessage:UML::NamedElement,context:UML::NamedElement,elementPart:UML::TypedElement,portDefaults:Sequence(UML::InstanceSpecification),
	interfaceDefaults:Sequence(UML::InstanceSpecification),
	operationDefaults:Sequence(UML::InstanceSpecification),
	parameterDefaults:Sequence(UML::InstanceSpecification),
	messageDefaults:Sequence(UML::InstanceSpecification)):GRAA::Message@graa 
	inherits UML::InstanceSpecification::GRAServiceAnnotationBaseDefaultContext 
{
	var messageRealized:UML::NamedElement= self.realizedNamedElement()->asSequence()->first();
	if(modeledMessage.oclIsUndefined())then{
		
	}else{
		messageRealized:=modeledMessage;
	}endif;
	var messagetype:UML::NamedElement=messageRealized;
	messagetype.Message(result,elementPart);
}
// populate the targetMessage based on context type, include both type and element target properties
helper 	UML::NamedElement::Message(inout targetMessage:GRAA::Message,
		elementPart:UML::TypedElement) 
{
	var typePackage:UML::Package=self.getNearestPackage();
	var pimStereotypeInstance:Stdlib::Element=typePackage.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	if(pimStereotypeInstance.oclIsUndefined())then{
		pimStereotypeInstance:=typePackage.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
	}endif;
	// set prefix to be used for Schema namespace
	targetMessage.prefix:=pimStereotypeInstance.getSsspSchemaDefaultPrefix();
	if(targetMessage.prefix.oclIsUndefined()or (targetMessage.prefix=''))then{
		targetMessage.prefix:='prefix';
		targetMessage.diagnostics+='ERROR: no prefix defined for namespace'
	}endif;
	targetMessage.name:=self.toNiemName();
		
	if(elementPart.oclIsUndefined())then{
		targetMessage.diagnostics+='ERROR: No element referencing '+self.qualifiedName;
		targetMessage.elementPrefix:='unknown';
		targetMessage.elementName:='unknown';
	}else{	
		var elementPackage:UML::Package=elementPart.getNearestPackage();
		var elementStereotypeInstance:Stdlib::Element=elementPackage.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
		if(elementStereotypeInstance.oclIsUndefined())then{
			elementStereotypeInstance:=elementPackage.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element);
		}endif;
		// set prefix to be used for Schema namespace
		targetMessage.elementPrefix:=elementStereotypeInstance.getSsspSchemaDefaultPrefix();
		if(targetMessage.elementPrefix.oclIsUndefined()or (targetMessage.elementPrefix=''))then{
			targetMessage.diagnostics+='WARNING: No prefix defined for element';
			targetMessage.elementPrefix:=elementPackage.name;
		}endif;
		targetMessage.elementName:=elementPart.toNiemName();
		targetMessage.elementModelReference:=elementPart.mapModelReference();
	}endif;
	return;		
}	
// map InstanceSpecification instantiation of 'ServiceInteractionProfile' to GRA ServiceInteractionProfile	
	mapping 	UML::InstanceSpecification::ServiceInteractionProfile():GRAA::ServiceInteractionProfile@graa 
{
	sipName:=self.getStringValue('SIPName');
	sipVersion:=self.getStringValue('SIPVersion');
}	
// map InstanceSpecification instantiation of 'Agreement' to GRA Agreement	
	mapping 	UML::InstanceSpecification::Agreement():GRAA::Agreement@graa 
{
	agreementUri:=self.getStringValue('AgreementURI');
	automatedAgreementIndicator:=self.getBooleanValue('AutomatedAgreementIndicator');
	documentation:=self.ownedComment.body->asSequence()->first();
}	
	